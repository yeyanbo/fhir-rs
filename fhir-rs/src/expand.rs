pub mod datatype {
    pub mod primitive {
        use crate::prelude::*;
        use std::fmt::{Display, Formatter};
        use std::str::FromStr;
        pub struct StringDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for string
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<String>,
        }
        impl Primitive for StringDt {
            type T = String;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                StringDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for StringDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for StringDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = String::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for StringDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for StringDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "StringDt".to_string()
            }
        }
        impl Serialize for StringDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for StringDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct StringDtVisitor;
                impl<'de> Visitor<'de> for StringDtVisitor {
                    type Value = StringDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        StringDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<String> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(StringDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", StringDtVisitor)
            }
        }
        impl Executor for StringDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "StringDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "StringDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "StringDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for StringDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "StringDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StringDt {
            #[inline]
            fn clone(&self) -> StringDt {
                StringDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct IdDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for id
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Id>,
        }
        impl Primitive for IdDt {
            type T = Id;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                IdDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for IdDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for IdDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Id::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for IdDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for IdDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "IdDt".to_string()
            }
        }
        impl Serialize for IdDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for IdDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct IdDtVisitor;
                impl<'de> Visitor<'de> for IdDtVisitor {
                    type Value = IdDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        IdDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Id> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(IdDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", IdDtVisitor)
            }
        }
        impl Executor for IdDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "IdDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!("{0}: 无效的路径名:[{1}]", "IdDt", other),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "IdDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IdDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "IdDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdDt {
            #[inline]
            fn clone(&self) -> IdDt {
                IdDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct Base64BinaryDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for base64Binary
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Base64Binary>,
        }
        impl Primitive for Base64BinaryDt {
            type T = Base64Binary;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                Base64BinaryDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for Base64BinaryDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for Base64BinaryDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Base64Binary::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for Base64BinaryDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Base64BinaryDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "Base64BinaryDt".to_string()
            }
        }
        impl Serialize for Base64BinaryDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Base64BinaryDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct Base64BinaryDtVisitor;
                impl<'de> Visitor<'de> for Base64BinaryDtVisitor {
                    type Value = Base64BinaryDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        Base64BinaryDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Base64Binary> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(Base64BinaryDt {
                            id,
                            extension,
                            value,
                        })
                    }
                }
                deserializer.deserialize_struct("", Base64BinaryDtVisitor)
            }
        }
        impl Executor for Base64BinaryDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Base64BinaryDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Base64BinaryDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "Base64BinaryDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Base64BinaryDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Base64BinaryDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Base64BinaryDt {
            #[inline]
            fn clone(&self) -> Base64BinaryDt {
                Base64BinaryDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct MarkdownDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for markdown
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Markdown>,
        }
        impl Primitive for MarkdownDt {
            type T = Markdown;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                MarkdownDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for MarkdownDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for MarkdownDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Markdown::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for MarkdownDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for MarkdownDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "MarkdownDt".to_string()
            }
        }
        impl Serialize for MarkdownDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for MarkdownDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct MarkdownDtVisitor;
                impl<'de> Visitor<'de> for MarkdownDtVisitor {
                    type Value = MarkdownDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        MarkdownDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Markdown> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(MarkdownDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", MarkdownDtVisitor)
            }
        }
        impl Executor for MarkdownDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "MarkdownDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "MarkdownDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "MarkdownDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MarkdownDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "MarkdownDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MarkdownDt {
            #[inline]
            fn clone(&self) -> MarkdownDt {
                MarkdownDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct UriDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for uri
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Uri>,
        }
        impl Primitive for UriDt {
            type T = Uri;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                UriDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for UriDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for UriDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Uri::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for UriDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for UriDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "UriDt".to_string()
            }
        }
        impl Serialize for UriDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for UriDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct UriDtVisitor;
                impl<'de> Visitor<'de> for UriDtVisitor {
                    type Value = UriDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        UriDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Uri> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(UriDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", UriDtVisitor)
            }
        }
        impl Executor for UriDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "UriDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "UriDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "UriDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UriDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "UriDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UriDt {
            #[inline]
            fn clone(&self) -> UriDt {
                UriDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct OidDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for oid
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Oid>,
        }
        impl Primitive for OidDt {
            type T = Oid;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                OidDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for OidDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for OidDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Oid::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for OidDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for OidDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "OidDt".to_string()
            }
        }
        impl Serialize for OidDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for OidDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct OidDtVisitor;
                impl<'de> Visitor<'de> for OidDtVisitor {
                    type Value = OidDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        OidDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Oid> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(OidDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", OidDtVisitor)
            }
        }
        impl Executor for OidDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "OidDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "OidDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "OidDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OidDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "OidDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OidDt {
            #[inline]
            fn clone(&self) -> OidDt {
                OidDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct CanonicalDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for canonical
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Canonical>,
        }
        impl Primitive for CanonicalDt {
            type T = Canonical;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                CanonicalDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for CanonicalDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for CanonicalDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Canonical::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for CanonicalDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for CanonicalDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "CanonicalDt".to_string()
            }
        }
        impl Serialize for CanonicalDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for CanonicalDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct CanonicalDtVisitor;
                impl<'de> Visitor<'de> for CanonicalDtVisitor {
                    type Value = CanonicalDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        CanonicalDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Canonical> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(CanonicalDt {
                            id,
                            extension,
                            value,
                        })
                    }
                }
                deserializer.deserialize_struct("", CanonicalDtVisitor)
            }
        }
        impl Executor for CanonicalDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "CanonicalDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "CanonicalDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "CanonicalDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CanonicalDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "CanonicalDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CanonicalDt {
            #[inline]
            fn clone(&self) -> CanonicalDt {
                CanonicalDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct CodeDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for code
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Code>,
        }
        impl Primitive for CodeDt {
            type T = Code;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                CodeDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for CodeDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for CodeDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Code::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for CodeDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for CodeDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "CodeDt".to_string()
            }
        }
        impl Serialize for CodeDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for CodeDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct CodeDtVisitor;
                impl<'de> Visitor<'de> for CodeDtVisitor {
                    type Value = CodeDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        CodeDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Code> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(CodeDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", CodeDtVisitor)
            }
        }
        impl Executor for CodeDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "CodeDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "CodeDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "CodeDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CodeDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "CodeDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CodeDt {
            #[inline]
            fn clone(&self) -> CodeDt {
                CodeDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        /// 布尔类型
        ///
        /// true | false
        pub struct BooleanDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for boolean
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Boolean>,
        }
        impl Primitive for BooleanDt {
            type T = Boolean;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                BooleanDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for BooleanDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for BooleanDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Boolean::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for BooleanDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for BooleanDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "BooleanDt".to_string()
            }
        }
        impl Serialize for BooleanDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for BooleanDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct BooleanDtVisitor;
                impl<'de> Visitor<'de> for BooleanDtVisitor {
                    type Value = BooleanDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        BooleanDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Boolean> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(BooleanDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", BooleanDtVisitor)
            }
        }
        impl Executor for BooleanDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "BooleanDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "BooleanDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "BooleanDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BooleanDt {
            #[inline]
            fn clone(&self) -> BooleanDt {
                BooleanDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BooleanDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "BooleanDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        /// 正整数类型
        ///
        /// 1..2,147,483,647
        pub struct PositiveIntDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for positiveInt
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<PositiveInt>,
        }
        impl Primitive for PositiveIntDt {
            type T = PositiveInt;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                PositiveIntDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for PositiveIntDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for PositiveIntDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = PositiveInt::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for PositiveIntDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for PositiveIntDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "PositiveIntDt".to_string()
            }
        }
        impl Serialize for PositiveIntDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for PositiveIntDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct PositiveIntDtVisitor;
                impl<'de> Visitor<'de> for PositiveIntDtVisitor {
                    type Value = PositiveIntDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        PositiveIntDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<PositiveInt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(PositiveIntDt {
                            id,
                            extension,
                            value,
                        })
                    }
                }
                deserializer.deserialize_struct("", PositiveIntDtVisitor)
            }
        }
        impl Executor for PositiveIntDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "PositiveIntDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "PositiveIntDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "PositiveIntDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PositiveIntDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "PositiveIntDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PositiveIntDt {
            #[inline]
            fn clone(&self) -> PositiveIntDt {
                PositiveIntDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct IntegerDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for integer
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Integer>,
        }
        impl Primitive for IntegerDt {
            type T = Integer;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                IntegerDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for IntegerDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for IntegerDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Integer::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for IntegerDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for IntegerDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "IntegerDt".to_string()
            }
        }
        impl Serialize for IntegerDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for IntegerDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct IntegerDtVisitor;
                impl<'de> Visitor<'de> for IntegerDtVisitor {
                    type Value = IntegerDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        IntegerDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Integer> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(IntegerDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", IntegerDtVisitor)
            }
        }
        impl Executor for IntegerDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "IntegerDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "IntegerDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "IntegerDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IntegerDt {
            #[inline]
            fn clone(&self) -> IntegerDt {
                IntegerDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IntegerDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "IntegerDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        pub struct Integer64Dt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for integer64
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Integer64>,
        }
        impl Primitive for Integer64Dt {
            type T = Integer64;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                Integer64Dt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for Integer64Dt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for Integer64Dt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Integer64::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for Integer64Dt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Integer64Dt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "Integer64Dt".to_string()
            }
        }
        impl Serialize for Integer64Dt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Integer64Dt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct Integer64DtVisitor;
                impl<'de> Visitor<'de> for Integer64DtVisitor {
                    type Value = Integer64Dt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        Integer64Dt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Integer64> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(Integer64Dt {
                            id,
                            extension,
                            value,
                        })
                    }
                }
                deserializer.deserialize_struct("", Integer64DtVisitor)
            }
        }
        impl Executor for Integer64Dt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Integer64Dt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Integer64Dt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "Integer64Dt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Integer64Dt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Integer64Dt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Integer64Dt {
            #[inline]
            fn clone(&self) -> Integer64Dt {
                Integer64Dt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct DecimalDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for decimal
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Decimal>,
        }
        impl Primitive for DecimalDt {
            type T = Decimal;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                DecimalDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for DecimalDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for DecimalDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Decimal::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for DecimalDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DecimalDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "DecimalDt".to_string()
            }
        }
        impl Serialize for DecimalDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DecimalDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DecimalDtVisitor;
                impl<'de> Visitor<'de> for DecimalDtVisitor {
                    type Value = DecimalDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        DecimalDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Decimal> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(DecimalDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", DecimalDtVisitor)
            }
        }
        impl Executor for DecimalDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "DecimalDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DecimalDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "DecimalDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DecimalDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "DecimalDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DecimalDt {
            #[inline]
            fn clone(&self) -> DecimalDt {
                DecimalDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        /// 日期类型
        ///
        /// 表示日期，包括年月日。格式为YYYY, YYYY-MM, YYYY-MM-DD。不要指定时区。
        pub struct DateDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for date
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Date>,
        }
        impl Primitive for DateDt {
            type T = Date;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                DateDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for DateDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for DateDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Date::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for DateDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DateDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "DateDt".to_string()
            }
        }
        impl Serialize for DateDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DateDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DateDtVisitor;
                impl<'de> Visitor<'de> for DateDtVisitor {
                    type Value = DateDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        DateDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Date> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(DateDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", DateDtVisitor)
            }
        }
        impl Executor for DateDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "DateDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DateDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "DateDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DateDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "DateDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DateDt {
            #[inline]
            fn clone(&self) -> DateDt {
                DateDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        /// 时间类型
        ///
        /// 表示一天内的时间。24小时制，格式为HH::MM:SS。不要指定时区。
        pub struct TimeDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for time
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Time>,
        }
        impl Primitive for TimeDt {
            type T = Time;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                TimeDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for TimeDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for TimeDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Time::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for TimeDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for TimeDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "TimeDt".to_string()
            }
        }
        impl Serialize for TimeDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for TimeDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct TimeDtVisitor;
                impl<'de> Visitor<'de> for TimeDtVisitor {
                    type Value = TimeDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        TimeDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Time> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(TimeDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", TimeDtVisitor)
            }
        }
        impl Executor for TimeDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "TimeDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "TimeDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "TimeDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TimeDt {
            #[inline]
            fn clone(&self) -> TimeDt {
                TimeDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TimeDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "TimeDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        /// 日期与时间
        ///
        /// 时间部分如果存在，必须到秒，如果精度不足，可以使用00填充。
        /// 如果存在时间，则必须提供时区。如果不确定时区，可以使用Z表示当地时区。
        ///
        /// 精度不限，展示形式灵活。可以表示如下几种格式：
        /// * 年 - 2023
        /// * 年月 - 2023-08
        /// * 年月日 - 2023-08-17
        /// * 年月日时分秒 - 2023-08-17T08:21:45Z
        /// * 年月日时分秒(毫秒) - 2023-08-17T08:21:45.234Z
        /// * 年月日时分秒(毫秒)时区 - 2023-08-17T08:21:45.234+08:00
        pub struct DateTimeDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for dateTime
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DateTime>,
        }
        impl Primitive for DateTimeDt {
            type T = DateTime;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                DateTimeDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for DateTimeDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for DateTimeDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = DateTime::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for DateTimeDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DateTimeDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "DateTimeDt".to_string()
            }
        }
        impl Serialize for DateTimeDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DateTimeDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DateTimeDtVisitor;
                impl<'de> Visitor<'de> for DateTimeDtVisitor {
                    type Value = DateTimeDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        DateTimeDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DateTime> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(DateTimeDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", DateTimeDtVisitor)
            }
        }
        impl Executor for DateTimeDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "DateTimeDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DateTimeDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "DateTimeDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DateTimeDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "DateTimeDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DateTimeDt {
            #[inline]
            fn clone(&self) -> DateTimeDt {
                DateTimeDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        /// 日期与时间
        ///
        /// 精度更高，最小精度要到秒，必须有时区。一般这种时间都是由机器生成的。
        ///
        /// 只接受FHIR规范约定的四种格式：
        /// * 2009-12-24T07:12:45Z
        /// * 2009-12-24T07:12:45.234Z
        /// * 2009-12-24T07:12:45+08:00
        /// * 2009-12-24T07:12:45.234+08:00
        ///
        /// 输出时，只有两种：
        /// * 2009-12-24T07:12:45+08:00
        /// * 2009-12-24T07:12:45.234+08:00
        ///
        /// 导入之后，会根据当地的时区将Z转换为对应的时区
        pub struct InstantDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for instant
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Instant>,
        }
        impl Primitive for InstantDt {
            type T = Instant;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                InstantDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for InstantDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for InstantDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Instant::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for InstantDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for InstantDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "InstantDt".to_string()
            }
        }
        impl Serialize for InstantDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for InstantDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct InstantDtVisitor;
                impl<'de> Visitor<'de> for InstantDtVisitor {
                    type Value = InstantDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        InstantDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Instant> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(InstantDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", InstantDtVisitor)
            }
        }
        impl Executor for InstantDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "InstantDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "InstantDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "InstantDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for InstantDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "InstantDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for InstantDt {
            #[inline]
            fn clone(&self) -> InstantDt {
                InstantDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct UnsignedIntDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for unsignedInt
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<UnsignedInt>,
        }
        impl Primitive for UnsignedIntDt {
            type T = UnsignedInt;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                UnsignedIntDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for UnsignedIntDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for UnsignedIntDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = UnsignedInt::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for UnsignedIntDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for UnsignedIntDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "UnsignedIntDt".to_string()
            }
        }
        impl Serialize for UnsignedIntDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for UnsignedIntDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct UnsignedIntDtVisitor;
                impl<'de> Visitor<'de> for UnsignedIntDtVisitor {
                    type Value = UnsignedIntDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        UnsignedIntDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<UnsignedInt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(UnsignedIntDt {
                            id,
                            extension,
                            value,
                        })
                    }
                }
                deserializer.deserialize_struct("", UnsignedIntDtVisitor)
            }
        }
        impl Executor for UnsignedIntDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "UnsignedIntDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "UnsignedIntDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "UnsignedIntDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UnsignedIntDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "UnsignedIntDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UnsignedIntDt {
            #[inline]
            fn clone(&self) -> UnsignedIntDt {
                UnsignedIntDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct UrlDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for url
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Url>,
        }
        impl Primitive for UrlDt {
            type T = Url;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                UrlDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for UrlDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for UrlDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Url::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for UrlDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for UrlDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "UrlDt".to_string()
            }
        }
        impl Serialize for UrlDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for UrlDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct UrlDtVisitor;
                impl<'de> Visitor<'de> for UrlDtVisitor {
                    type Value = UrlDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        UrlDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Url> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(UrlDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", UrlDtVisitor)
            }
        }
        impl Executor for UrlDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "UrlDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "UrlDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "UrlDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UrlDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "UrlDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UrlDt {
            #[inline]
            fn clone(&self) -> UrlDt {
                UrlDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct UuidDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Primitive value for uuid
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Uuid>,
        }
        impl Primitive for UuidDt {
            type T = Uuid;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                UuidDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for UuidDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for UuidDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Uuid::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for UuidDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for UuidDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "UuidDt".to_string()
            }
        }
        impl Serialize for UuidDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for UuidDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct UuidDtVisitor;
                impl<'de> Visitor<'de> for UuidDtVisitor {
                    type Value = UuidDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        UuidDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Uuid> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(UuidDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", UuidDtVisitor)
            }
        }
        impl Executor for UuidDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "UuidDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "UuidDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "UuidDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UuidDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "UuidDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UuidDt {
            #[inline]
            fn clone(&self) -> UuidDt {
                UuidDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        pub struct XhtmlDt {
            /// xml:id (or equivalent in JSON)
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "0",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Actual xhtml
            #[fhir(
                name = "value",
                min = "1",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Xhtml>,
        }
        impl Primitive for XhtmlDt {
            type T = Xhtml;
            fn new<A: Into<Self::T>>(v: A) -> Self {
                XhtmlDt {
                    id: None,
                    extension: None,
                    value: Some(v.into()),
                }
            }
            fn value(&self) -> &Option<Self::T> {
                &self.value
            }
            fn set_value(mut self, v: Self::T) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Display for XhtmlDt {
            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
                match &self.value {
                    Some(v) => v.fmt(f),
                    None => f.write_fmt(format_args!("")),
                }
            }
        }
        impl FromStr for XhtmlDt {
            type Err = FhirError;
            fn from_str(s: &str) -> std::prelude::v1::Result<Self, Self::Err> {
                let val = Xhtml::from_str(s)?;
                Ok(Self {
                    id: None,
                    extension: None,
                    value: Some(val),
                })
            }
        }
        impl Element for XhtmlDt {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for XhtmlDt {
            fn is_empty(&self) -> bool {
                self.value.is_none() & self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "XhtmlDt".to_string()
            }
        }
        impl Serialize for XhtmlDt {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut primitive = serializer.serialize_primitive()?;
                primitive.serialize_id(&self.id)?;
                primitive.serialize_value(&self.value)?;
                primitive.serialize_extension(&self.extension)?;
                primitive.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for XhtmlDt {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct XhtmlDtVisitor;
                impl<'de> Visitor<'de> for XhtmlDtVisitor {
                    type Value = XhtmlDt;
                    fn visit_str(self, v: &str) -> Result<Self::Value> {
                        XhtmlDt::from_str(v)
                    }
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<Xhtml> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(FhirError::error("读到不存在的key了"));
                                }
                            }
                        }
                        Ok(XhtmlDt { id, extension, value })
                    }
                }
                deserializer.deserialize_struct("", XhtmlDtVisitor)
            }
        }
        impl Executor for XhtmlDt {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "XhtmlDt"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "XhtmlDt",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: 无效的路径表达式:{1:#?}",
                                        "XhtmlDt",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for XhtmlDt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "XhtmlDt",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for XhtmlDt {
            #[inline]
            fn clone(&self) -> XhtmlDt {
                XhtmlDt {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        impl From<&str> for StringDt {
            fn from(value: &str) -> Self {
                StringDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for UriDt {
            fn from(value: &str) -> Self {
                UriDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for UrlDt {
            fn from(value: &str) -> Self {
                UrlDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for CanonicalDt {
            fn from(value: &str) -> Self {
                CanonicalDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for UuidDt {
            fn from(value: &str) -> Self {
                UuidDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for OidDt {
            fn from(value: &str) -> Self {
                OidDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for IdDt {
            fn from(value: &str) -> Self {
                IdDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for CodeDt {
            fn from(value: &str) -> Self {
                CodeDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for MarkdownDt {
            fn from(value: &str) -> Self {
                MarkdownDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for Base64BinaryDt {
            fn from(value: &str) -> Self {
                Base64BinaryDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for XhtmlDt {
            fn from(value: &str) -> Self {
                XhtmlDt::from_str(value).unwrap()
            }
        }
        impl From<bool> for BooleanDt {
            fn from(value: bool) -> Self {
                BooleanDt {
                    id: None,
                    extension: None,
                    value: Some(value),
                }
            }
        }
        impl From<u8> for PositiveIntDt {
            fn from(value: u8) -> Self {
                PositiveIntDt {
                    id: None,
                    extension: None,
                    value: Some(value as usize),
                }
            }
        }
        impl From<u16> for PositiveIntDt {
            fn from(value: u16) -> Self {
                PositiveIntDt {
                    id: None,
                    extension: None,
                    value: Some(value as usize),
                }
            }
        }
        impl From<u32> for PositiveIntDt {
            fn from(value: u32) -> Self {
                PositiveIntDt {
                    id: None,
                    extension: None,
                    value: Some(value as usize),
                }
            }
        }
        impl From<i8> for PositiveIntDt {
            fn from(value: i8) -> Self {
                PositiveIntDt {
                    id: None,
                    extension: None,
                    value: Some(value as usize),
                }
            }
        }
        impl From<i16> for PositiveIntDt {
            fn from(value: i16) -> Self {
                PositiveIntDt {
                    id: None,
                    extension: None,
                    value: Some(value as usize),
                }
            }
        }
        impl From<i32> for PositiveIntDt {
            fn from(value: i32) -> Self {
                PositiveIntDt {
                    id: None,
                    extension: None,
                    value: Some(value as usize),
                }
            }
        }
        impl From<u8> for IntegerDt {
            fn from(value: u8) -> Self {
                IntegerDt {
                    id: None,
                    extension: None,
                    value: Some(value as isize),
                }
            }
        }
        impl From<u16> for IntegerDt {
            fn from(value: u16) -> Self {
                IntegerDt {
                    id: None,
                    extension: None,
                    value: Some(value as isize),
                }
            }
        }
        impl From<u32> for IntegerDt {
            fn from(value: u32) -> Self {
                IntegerDt {
                    id: None,
                    extension: None,
                    value: Some(value as isize),
                }
            }
        }
        impl From<i8> for IntegerDt {
            fn from(value: i8) -> Self {
                IntegerDt {
                    id: None,
                    extension: None,
                    value: Some(value as isize),
                }
            }
        }
        impl From<i16> for IntegerDt {
            fn from(value: i16) -> Self {
                IntegerDt {
                    id: None,
                    extension: None,
                    value: Some(value as isize),
                }
            }
        }
        impl From<i32> for IntegerDt {
            fn from(value: i32) -> Self {
                IntegerDt {
                    id: None,
                    extension: None,
                    value: Some(value as isize),
                }
            }
        }
        impl From<i8> for Integer64Dt {
            fn from(value: i8) -> Self {
                Integer64Dt {
                    id: None,
                    extension: None,
                    value: Some(value as i64),
                }
            }
        }
        impl From<i16> for Integer64Dt {
            fn from(value: i16) -> Self {
                Integer64Dt {
                    id: None,
                    extension: None,
                    value: Some(value as i64),
                }
            }
        }
        impl From<i32> for Integer64Dt {
            fn from(value: i32) -> Self {
                Integer64Dt {
                    id: None,
                    extension: None,
                    value: Some(value as i64),
                }
            }
        }
        impl From<i64> for Integer64Dt {
            fn from(value: i64) -> Self {
                Integer64Dt {
                    id: None,
                    extension: None,
                    value: Some(value),
                }
            }
        }
        impl From<&str> for InstantDt {
            fn from(value: &str) -> Self {
                InstantDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for DateTimeDt {
            fn from(value: &str) -> Self {
                DateTimeDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for DateDt {
            fn from(value: &str) -> Self {
                DateDt::from_str(value).unwrap()
            }
        }
        impl From<&str> for TimeDt {
            fn from(value: &str) -> Self {
                TimeDt::from_str(value).unwrap()
            }
        }
    }
    pub mod complex {
        use fhir_derive::Element;
        use crate::prelude::*;
        pub struct Coding {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Identity of the terminology system
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// Version of the system - if relevant
            #[fhir(
                name = "version",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub version: Option<StringDt>,
            /// Symbol in syntax defined by the system
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeDt>,
            /// Representation defined by the system
            #[fhir(
                name = "display",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub display: Option<StringDt>,
            /// If this coding was chosen directly by the user
            #[fhir(
                name = "userSelected",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub user_selected: Option<BooleanDt>,
        }
        impl Element for Coding {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Coding {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.system.is_none() & self.version.is_none()
                    & self.code.is_none() & self.display.is_none()
                    & self.user_selected.is_none()
            }
            fn type_name(&self) -> String {
                "Coding".to_string()
            }
        }
        impl Coding {
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_version<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.version = Some(v.into());
                self
            }
            pub fn set_code<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.code = Some(v.into());
                self
            }
            pub fn set_display<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.display = Some(v.into());
                self
            }
            pub fn set_user_selected<T: Into<BooleanDt>>(mut self, v: T) -> Self {
                self.user_selected = Some(v.into());
                self
            }
        }
        impl Serialize for Coding {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("version", &self.version)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_field("display", &self.display)?;
                serialize_struct.serialize_field("userSelected", &self.user_selected)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Coding {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct CodingVisitor;
                impl<'de> Visitor<'de> for CodingVisitor {
                    type Value = Coding;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut system: Option<UriDt> = None;
                        let mut version: Option<StringDt> = None;
                        let mut code: Option<CodeDt> = None;
                        let mut display: Option<StringDt> = None;
                        let mut user_selected: Option<BooleanDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "version" => {
                                    version = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                "display" => {
                                    display = Some(mapp.next_value()?);
                                }
                                "userSelected" => {
                                    user_selected = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Coding {
                            id,
                            extension,
                            system,
                            version,
                            code,
                            display,
                            user_selected,
                        })
                    }
                }
                deserializer.deserialize_struct("", CodingVisitor)
            }
        }
        impl Executor for Coding {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Coding"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "version" => self.version.exec(&comp),
                            "code" => self.code.exec(&comp),
                            "display" => self.display.exec(&comp),
                            "userSelected" => self.user_selected.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Coding",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Coding {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "system",
                    "version",
                    "code",
                    "display",
                    "user_selected",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.system,
                    &self.version,
                    &self.code,
                    &self.display,
                    &&self.user_selected,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Coding",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Coding {
            #[inline]
            fn clone(&self) -> Coding {
                Coding {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    system: ::core::clone::Clone::clone(&self.system),
                    version: ::core::clone::Clone::clone(&self.version),
                    code: ::core::clone::Clone::clone(&self.code),
                    display: ::core::clone::Clone::clone(&self.display),
                    user_selected: ::core::clone::Clone::clone(&self.user_selected),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Coding {
            #[inline]
            fn default() -> Coding {
                Coding {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    version: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                    display: ::core::default::Default::default(),
                    user_selected: ::core::default::Default::default(),
                }
            }
        }
        pub struct Address {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// home | work | temp | old | billing - purpose of this address
            #[fhir(name = "use", min = "0", max = "1", summary = true, modifier = true)]
            pub use_: Option<CodeDt>,
            /// postal | physical | both
            #[fhir(
                name = "type",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeDt>,
            /// Text representation of the address
            #[fhir(
                name = "text",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub text: Option<StringDt>,
            /// Street name, number, direction & P.O. Box etc.
            #[fhir(
                name = "line",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub line: Option<Vec<StringDt>>,
            /// Name of city, town etc.
            #[fhir(
                name = "city",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub city: Option<StringDt>,
            /// District name (aka county)
            #[fhir(
                name = "district",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub district: Option<StringDt>,
            /// Sub-unit of country (abbreviations ok)
            #[fhir(
                name = "state",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub state: Option<StringDt>,
            /// Postal code for area
            #[fhir(
                name = "postalCode",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub postal_code: Option<StringDt>,
            /// Country (e.g. may be ISO 3166 2 or 3 letter code)
            #[fhir(
                name = "country",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub country: Option<StringDt>,
            /// Time period when address was/is in use
            #[fhir(
                name = "period",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period: Option<Period>,
        }
        impl Element for Address {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Address {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.use_.is_none() & self.type_.is_none()
                    & self.text.is_none() & self.line.is_none() & self.city.is_none()
                    & self.district.is_none() & self.state.is_none()
                    & self.postal_code.is_none() & self.country.is_none()
                    & self.period.is_none()
            }
            fn type_name(&self) -> String {
                "Address".to_string()
            }
        }
        impl Address {
            pub fn set_use_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.use_ = Some(v.into());
                self
            }
            pub fn set_type_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.type_ = Some(v.into());
                self
            }
            pub fn set_text<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.text = Some(v.into());
                self
            }
            pub fn set_line(mut self, v: Vec<StringDt>) -> Self {
                self.line = Some(v);
                self
            }
            pub fn add_line<T: Into<StringDt>>(mut self, v: T) -> Self {
                match self.line {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.line = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_city<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.city = Some(v.into());
                self
            }
            pub fn set_district<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.district = Some(v.into());
                self
            }
            pub fn set_state<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.state = Some(v.into());
                self
            }
            pub fn set_postal_code<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.postal_code = Some(v.into());
                self
            }
            pub fn set_country<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.country = Some(v.into());
                self
            }
            pub fn set_period(mut self, v: Period) -> Self {
                self.period = Some(v);
                self
            }
        }
        impl Serialize for Address {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("use", &self.use_)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("text", &self.text)?;
                serialize_struct.serialize_field("line", &self.line)?;
                serialize_struct.serialize_field("city", &self.city)?;
                serialize_struct.serialize_field("district", &self.district)?;
                serialize_struct.serialize_field("state", &self.state)?;
                serialize_struct.serialize_field("postalCode", &self.postal_code)?;
                serialize_struct.serialize_field("country", &self.country)?;
                serialize_struct.serialize_field("period", &self.period)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Address {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct AddressVisitor;
                impl<'de> Visitor<'de> for AddressVisitor {
                    type Value = Address;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut use_: Option<CodeDt> = None;
                        let mut type_: Option<CodeDt> = None;
                        let mut text: Option<StringDt> = None;
                        let mut line: Option<Vec<StringDt>> = None;
                        let mut city: Option<StringDt> = None;
                        let mut district: Option<StringDt> = None;
                        let mut state: Option<StringDt> = None;
                        let mut postal_code: Option<StringDt> = None;
                        let mut country: Option<StringDt> = None;
                        let mut period: Option<Period> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "use" => {
                                    use_ = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "text" => {
                                    text = Some(mapp.next_value()?);
                                }
                                "line" => {
                                    line = Some(mapp.next_value()?);
                                }
                                "city" => {
                                    city = Some(mapp.next_value()?);
                                }
                                "district" => {
                                    district = Some(mapp.next_value()?);
                                }
                                "state" => {
                                    state = Some(mapp.next_value()?);
                                }
                                "postalCode" => {
                                    postal_code = Some(mapp.next_value()?);
                                }
                                "country" => {
                                    country = Some(mapp.next_value()?);
                                }
                                "period" => {
                                    period = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Address {
                            id,
                            extension,
                            use_,
                            type_,
                            text,
                            line,
                            city,
                            district,
                            state,
                            postal_code,
                            country,
                            period,
                        })
                    }
                }
                deserializer.deserialize_struct("", AddressVisitor)
            }
        }
        impl Executor for Address {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Address"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "use" => self.use_.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "text" => self.text.exec(&comp),
                            "line" => self.line.exec(&comp),
                            "city" => self.city.exec(&comp),
                            "district" => self.district.exec(&comp),
                            "state" => self.state.exec(&comp),
                            "postalCode" => self.postal_code.exec(&comp),
                            "country" => self.country.exec(&comp),
                            "period" => self.period.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Address",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Address {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "use_",
                    "type_",
                    "text",
                    "line",
                    "city",
                    "district",
                    "state",
                    "postal_code",
                    "country",
                    "period",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.use_,
                    &self.type_,
                    &self.text,
                    &self.line,
                    &self.city,
                    &self.district,
                    &self.state,
                    &self.postal_code,
                    &self.country,
                    &&self.period,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Address",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Address {
            #[inline]
            fn clone(&self) -> Address {
                Address {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    use_: ::core::clone::Clone::clone(&self.use_),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    text: ::core::clone::Clone::clone(&self.text),
                    line: ::core::clone::Clone::clone(&self.line),
                    city: ::core::clone::Clone::clone(&self.city),
                    district: ::core::clone::Clone::clone(&self.district),
                    state: ::core::clone::Clone::clone(&self.state),
                    postal_code: ::core::clone::Clone::clone(&self.postal_code),
                    country: ::core::clone::Clone::clone(&self.country),
                    period: ::core::clone::Clone::clone(&self.period),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Address {
            #[inline]
            fn default() -> Address {
                Address {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    use_: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    text: ::core::default::Default::default(),
                    line: ::core::default::Default::default(),
                    city: ::core::default::Default::default(),
                    district: ::core::default::Default::default(),
                    state: ::core::default::Default::default(),
                    postal_code: ::core::default::Default::default(),
                    country: ::core::default::Default::default(),
                    period: ::core::default::Default::default(),
                }
            }
        }
        pub struct Age {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerical value (with implicit precision)
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DecimalDt>,
            /// < | <= | >= | > | ad - how to understand the value
            #[fhir(
                name = "comparator",
                min = "0",
                max = "1",
                summary = true,
                modifier = true
            )]
            pub comparator: Option<CodeDt>,
            /// Unit representation
            #[fhir(
                name = "unit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub unit: Option<StringDt>,
            /// System that defines coded unit form
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// Coded form of the unit
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeDt>,
        }
        impl Element for Age {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Age {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.value.is_none()
                    & self.comparator.is_none() & self.unit.is_none()
                    & self.system.is_none() & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "Age".to_string()
            }
        }
        impl Age {
            pub fn set_value<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_comparator<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.comparator = Some(v.into());
                self
            }
            pub fn set_unit<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.unit = Some(v.into());
                self
            }
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_code<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.code = Some(v.into());
                self
            }
        }
        impl Serialize for Age {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("comparator", &self.comparator)?;
                serialize_struct.serialize_field("unit", &self.unit)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Age {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct AgeVisitor;
                impl<'de> Visitor<'de> for AgeVisitor {
                    type Value = Age;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DecimalDt> = None;
                        let mut comparator: Option<CodeDt> = None;
                        let mut unit: Option<StringDt> = None;
                        let mut system: Option<UriDt> = None;
                        let mut code: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "comparator" => {
                                    comparator = Some(mapp.next_value()?);
                                }
                                "unit" => {
                                    unit = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Age {
                            id,
                            extension,
                            value,
                            comparator,
                            unit,
                            system,
                            code,
                        })
                    }
                }
                deserializer.deserialize_struct("", AgeVisitor)
            }
        }
        impl Executor for Age {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Age"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "comparator" => self.comparator.exec(&comp),
                            "unit" => self.unit.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!("{0}: 无效的路径名:[{1}]", "Age", other),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Age {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "value",
                    "comparator",
                    "unit",
                    "system",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.value,
                    &self.comparator,
                    &self.unit,
                    &self.system,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Age",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Age {
            #[inline]
            fn clone(&self) -> Age {
                Age {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                    comparator: ::core::clone::Clone::clone(&self.comparator),
                    unit: ::core::clone::Clone::clone(&self.unit),
                    system: ::core::clone::Clone::clone(&self.system),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Age {
            #[inline]
            fn default() -> Age {
                Age {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    comparator: ::core::default::Default::default(),
                    unit: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
        pub struct Annotation {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Individual responsible for the annotation
            #[fhir(
                name = "author",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub author: Option<StringDt>,
            /// When the annotation was made
            #[fhir(
                name = "time",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub time: Option<DateTimeDt>,
            /// The annotation  - text content (as markdown)
            #[fhir(
                name = "text",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub text: Option<MarkdownDt>,
        }
        impl Element for Annotation {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Annotation {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.author.is_none() & self.time.is_none()
                    & self.text.is_none()
            }
            fn type_name(&self) -> String {
                "Annotation".to_string()
            }
        }
        impl Annotation {
            pub fn set_author<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.author = Some(v.into());
                self
            }
            pub fn set_time<T: Into<DateTimeDt>>(mut self, v: T) -> Self {
                self.time = Some(v.into());
                self
            }
            pub fn set_text<T: Into<MarkdownDt>>(mut self, v: T) -> Self {
                self.text = Some(v.into());
                self
            }
        }
        impl Serialize for Annotation {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("author", &self.author)?;
                serialize_struct.serialize_field("time", &self.time)?;
                serialize_struct.serialize_field("text", &self.text)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Annotation {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct AnnotationVisitor;
                impl<'de> Visitor<'de> for AnnotationVisitor {
                    type Value = Annotation;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut author: Option<StringDt> = None;
                        let mut time: Option<DateTimeDt> = None;
                        let mut text: Option<MarkdownDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "author" => {
                                    author = Some(mapp.next_value()?);
                                }
                                "time" => {
                                    time = Some(mapp.next_value()?);
                                }
                                "text" => {
                                    text = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Annotation {
                            id,
                            extension,
                            author,
                            time,
                            text,
                        })
                    }
                }
                deserializer.deserialize_struct("", AnnotationVisitor)
            }
        }
        impl Executor for Annotation {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Annotation"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "author" => self.author.exec(&comp),
                            "time" => self.time.exec(&comp),
                            "text" => self.text.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Annotation",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Annotation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "Annotation",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "author",
                    &self.author,
                    "time",
                    &self.time,
                    "text",
                    &&self.text,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Annotation {
            #[inline]
            fn clone(&self) -> Annotation {
                Annotation {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    author: ::core::clone::Clone::clone(&self.author),
                    time: ::core::clone::Clone::clone(&self.time),
                    text: ::core::clone::Clone::clone(&self.text),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Annotation {
            #[inline]
            fn default() -> Annotation {
                Annotation {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    author: ::core::default::Default::default(),
                    time: ::core::default::Default::default(),
                    text: ::core::default::Default::default(),
                }
            }
        }
        pub struct Attachment {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Mime type of the content, with charset etc.
            #[fhir(
                name = "contentType",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub content_type: Option<CodeDt>,
            /// Human language of the content (BCP-47)
            #[fhir(
                name = "language",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub language: Option<CodeDt>,
            /// Data inline, base64ed
            #[fhir(
                name = "data",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub data: Option<Base64BinaryDt>,
            /// Uri where the data can be found
            #[fhir(
                name = "url",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub url: Option<UrlDt>,
            /// Number of bytes of content (if url provided)
            #[fhir(
                name = "size",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub size: Option<Integer64Dt>,
            /// Hash of the data (sha-1, base64ed)
            #[fhir(
                name = "hash",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub hash: Option<Base64BinaryDt>,
            /// Label to display in place of the data
            #[fhir(
                name = "title",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub title: Option<StringDt>,
            /// Date attachment was first created
            #[fhir(
                name = "creation",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub creation: Option<DateTimeDt>,
            /// Height of the image in pixels (photo/video)
            #[fhir(
                name = "height",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub height: Option<PositiveIntDt>,
            /// Width of the image in pixels (photo/video)
            #[fhir(
                name = "width",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub width: Option<PositiveIntDt>,
            /// Number of frames if > 1 (photo)
            #[fhir(
                name = "frames",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub frames: Option<PositiveIntDt>,
            /// Length in seconds (audio / video)
            #[fhir(
                name = "duration",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub duration: Option<DecimalDt>,
            /// Number of printed pages
            #[fhir(
                name = "pages",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub pages: Option<PositiveIntDt>,
        }
        impl Element for Attachment {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Attachment {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.content_type.is_none()
                    & self.language.is_none() & self.data.is_none() & self.url.is_none()
                    & self.size.is_none() & self.hash.is_none() & self.title.is_none()
                    & self.creation.is_none() & self.height.is_none()
                    & self.width.is_none() & self.frames.is_none()
                    & self.duration.is_none() & self.pages.is_none()
            }
            fn type_name(&self) -> String {
                "Attachment".to_string()
            }
        }
        impl Attachment {
            pub fn set_content_type<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.content_type = Some(v.into());
                self
            }
            pub fn set_language<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.language = Some(v.into());
                self
            }
            pub fn set_data<T: Into<Base64BinaryDt>>(mut self, v: T) -> Self {
                self.data = Some(v.into());
                self
            }
            pub fn set_url<T: Into<UrlDt>>(mut self, v: T) -> Self {
                self.url = Some(v.into());
                self
            }
            pub fn set_size<T: Into<Integer64Dt>>(mut self, v: T) -> Self {
                self.size = Some(v.into());
                self
            }
            pub fn set_hash<T: Into<Base64BinaryDt>>(mut self, v: T) -> Self {
                self.hash = Some(v.into());
                self
            }
            pub fn set_title<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.title = Some(v.into());
                self
            }
            pub fn set_creation<T: Into<DateTimeDt>>(mut self, v: T) -> Self {
                self.creation = Some(v.into());
                self
            }
            pub fn set_height<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.height = Some(v.into());
                self
            }
            pub fn set_width<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.width = Some(v.into());
                self
            }
            pub fn set_frames<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.frames = Some(v.into());
                self
            }
            pub fn set_duration<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.duration = Some(v.into());
                self
            }
            pub fn set_pages<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.pages = Some(v.into());
                self
            }
        }
        impl Serialize for Attachment {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("contentType", &self.content_type)?;
                serialize_struct.serialize_field("language", &self.language)?;
                serialize_struct.serialize_field("data", &self.data)?;
                serialize_struct.serialize_field("url", &self.url)?;
                serialize_struct.serialize_field("size", &self.size)?;
                serialize_struct.serialize_field("hash", &self.hash)?;
                serialize_struct.serialize_field("title", &self.title)?;
                serialize_struct.serialize_field("creation", &self.creation)?;
                serialize_struct.serialize_field("height", &self.height)?;
                serialize_struct.serialize_field("width", &self.width)?;
                serialize_struct.serialize_field("frames", &self.frames)?;
                serialize_struct.serialize_field("duration", &self.duration)?;
                serialize_struct.serialize_field("pages", &self.pages)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Attachment {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct AttachmentVisitor;
                impl<'de> Visitor<'de> for AttachmentVisitor {
                    type Value = Attachment;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut content_type: Option<CodeDt> = None;
                        let mut language: Option<CodeDt> = None;
                        let mut data: Option<Base64BinaryDt> = None;
                        let mut url: Option<UrlDt> = None;
                        let mut size: Option<Integer64Dt> = None;
                        let mut hash: Option<Base64BinaryDt> = None;
                        let mut title: Option<StringDt> = None;
                        let mut creation: Option<DateTimeDt> = None;
                        let mut height: Option<PositiveIntDt> = None;
                        let mut width: Option<PositiveIntDt> = None;
                        let mut frames: Option<PositiveIntDt> = None;
                        let mut duration: Option<DecimalDt> = None;
                        let mut pages: Option<PositiveIntDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "contentType" => {
                                    content_type = Some(mapp.next_value()?);
                                }
                                "language" => {
                                    language = Some(mapp.next_value()?);
                                }
                                "data" => {
                                    data = Some(mapp.next_value()?);
                                }
                                "url" => {
                                    url = Some(mapp.next_value()?);
                                }
                                "size" => {
                                    size = Some(mapp.next_value()?);
                                }
                                "hash" => {
                                    hash = Some(mapp.next_value()?);
                                }
                                "title" => {
                                    title = Some(mapp.next_value()?);
                                }
                                "creation" => {
                                    creation = Some(mapp.next_value()?);
                                }
                                "height" => {
                                    height = Some(mapp.next_value()?);
                                }
                                "width" => {
                                    width = Some(mapp.next_value()?);
                                }
                                "frames" => {
                                    frames = Some(mapp.next_value()?);
                                }
                                "duration" => {
                                    duration = Some(mapp.next_value()?);
                                }
                                "pages" => {
                                    pages = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Attachment {
                            id,
                            extension,
                            content_type,
                            language,
                            data,
                            url,
                            size,
                            hash,
                            title,
                            creation,
                            height,
                            width,
                            frames,
                            duration,
                            pages,
                        })
                    }
                }
                deserializer.deserialize_struct("", AttachmentVisitor)
            }
        }
        impl Executor for Attachment {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Attachment"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "contentType" => self.content_type.exec(&comp),
                            "language" => self.language.exec(&comp),
                            "data" => self.data.exec(&comp),
                            "url" => self.url.exec(&comp),
                            "size" => self.size.exec(&comp),
                            "hash" => self.hash.exec(&comp),
                            "title" => self.title.exec(&comp),
                            "creation" => self.creation.exec(&comp),
                            "height" => self.height.exec(&comp),
                            "width" => self.width.exec(&comp),
                            "frames" => self.frames.exec(&comp),
                            "duration" => self.duration.exec(&comp),
                            "pages" => self.pages.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Attachment",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Attachment {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "content_type",
                    "language",
                    "data",
                    "url",
                    "size",
                    "hash",
                    "title",
                    "creation",
                    "height",
                    "width",
                    "frames",
                    "duration",
                    "pages",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.content_type,
                    &self.language,
                    &self.data,
                    &self.url,
                    &self.size,
                    &self.hash,
                    &self.title,
                    &self.creation,
                    &self.height,
                    &self.width,
                    &self.frames,
                    &self.duration,
                    &&self.pages,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Attachment",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Attachment {
            #[inline]
            fn clone(&self) -> Attachment {
                Attachment {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    content_type: ::core::clone::Clone::clone(&self.content_type),
                    language: ::core::clone::Clone::clone(&self.language),
                    data: ::core::clone::Clone::clone(&self.data),
                    url: ::core::clone::Clone::clone(&self.url),
                    size: ::core::clone::Clone::clone(&self.size),
                    hash: ::core::clone::Clone::clone(&self.hash),
                    title: ::core::clone::Clone::clone(&self.title),
                    creation: ::core::clone::Clone::clone(&self.creation),
                    height: ::core::clone::Clone::clone(&self.height),
                    width: ::core::clone::Clone::clone(&self.width),
                    frames: ::core::clone::Clone::clone(&self.frames),
                    duration: ::core::clone::Clone::clone(&self.duration),
                    pages: ::core::clone::Clone::clone(&self.pages),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Attachment {
            #[inline]
            fn default() -> Attachment {
                Attachment {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    content_type: ::core::default::Default::default(),
                    language: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                    url: ::core::default::Default::default(),
                    size: ::core::default::Default::default(),
                    hash: ::core::default::Default::default(),
                    title: ::core::default::Default::default(),
                    creation: ::core::default::Default::default(),
                    height: ::core::default::Default::default(),
                    width: ::core::default::Default::default(),
                    frames: ::core::default::Default::default(),
                    duration: ::core::default::Default::default(),
                    pages: ::core::default::Default::default(),
                }
            }
        }
        pub struct Availability {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Times the {item} is available
            #[fhir(
                name = "availableTime",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub available_time: Option<Vec<AvailabilityAvailableTimeElement>>,
            /// Not available during this time due to provided reason
            #[fhir(
                name = "notAvailableTime",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub not_available_time: Option<Vec<AvailabilityNotAvailableTimeElement>>,
        }
        impl Element for Availability {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Availability {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.available_time.is_none()
                    & self.not_available_time.is_none()
            }
            fn type_name(&self) -> String {
                "Availability".to_string()
            }
        }
        impl Availability {
            pub fn set_available_time(
                mut self,
                v: Vec<AvailabilityAvailableTimeElement>,
            ) -> Self {
                self.available_time = Some(v);
                self
            }
            pub fn add_available_time(
                mut self,
                v: AvailabilityAvailableTimeElement,
            ) -> Self {
                match self.available_time {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.available_time = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_not_available_time(
                mut self,
                v: Vec<AvailabilityNotAvailableTimeElement>,
            ) -> Self {
                self.not_available_time = Some(v);
                self
            }
            pub fn add_not_available_time(
                mut self,
                v: AvailabilityNotAvailableTimeElement,
            ) -> Self {
                match self.not_available_time {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.not_available_time = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for Availability {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("availableTime", &self.available_time)?;
                serialize_struct
                    .serialize_field("notAvailableTime", &self.not_available_time)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Availability {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct AvailabilityVisitor;
                impl<'de> Visitor<'de> for AvailabilityVisitor {
                    type Value = Availability;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut available_time: Option<
                            Vec<AvailabilityAvailableTimeElement>,
                        > = None;
                        let mut not_available_time: Option<
                            Vec<AvailabilityNotAvailableTimeElement>,
                        > = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "availableTime" => {
                                    available_time = Some(mapp.next_value()?);
                                }
                                "notAvailableTime" => {
                                    not_available_time = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Availability {
                            id,
                            extension,
                            available_time,
                            not_available_time,
                        })
                    }
                }
                deserializer.deserialize_struct("", AvailabilityVisitor)
            }
        }
        impl Executor for Availability {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Availability"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "availableTime" => self.available_time.exec(&comp),
                            "notAvailableTime" => self.not_available_time.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Availability",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Availability {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Availability",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "available_time",
                    &self.available_time,
                    "not_available_time",
                    &&self.not_available_time,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Availability {
            #[inline]
            fn clone(&self) -> Availability {
                Availability {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    available_time: ::core::clone::Clone::clone(&self.available_time),
                    not_available_time: ::core::clone::Clone::clone(
                        &self.not_available_time,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Availability {
            #[inline]
            fn default() -> Availability {
                Availability {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    available_time: ::core::default::Default::default(),
                    not_available_time: ::core::default::Default::default(),
                }
            }
        }
        pub struct AvailabilityAvailableTimeElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// mon | tue | wed | thu | fri | sat | sun
            #[fhir(
                name = "daysOfWeek",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub days_of_week: Option<Vec<CodeDt>>,
            /// Always available? i.e. 24 hour service
            #[fhir(
                name = "allDay",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub all_day: Option<BooleanDt>,
            /// Opening time of day (ignored if allDay = true)
            #[fhir(
                name = "availableStartTime",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub available_start_time: Option<TimeDt>,
            /// Closing time of day (ignored if allDay = true)
            #[fhir(
                name = "availableEndTime",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub available_end_time: Option<TimeDt>,
        }
        impl Element for AvailabilityAvailableTimeElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for AvailabilityAvailableTimeElement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.days_of_week.is_none()
                    & self.all_day.is_none() & self.available_start_time.is_none()
                    & self.available_end_time.is_none()
            }
            fn type_name(&self) -> String {
                "AvailabilityAvailableTimeElement".to_string()
            }
        }
        impl AvailabilityAvailableTimeElement {
            pub fn set_days_of_week(mut self, v: Vec<CodeDt>) -> Self {
                self.days_of_week = Some(v);
                self
            }
            pub fn add_days_of_week<T: Into<CodeDt>>(mut self, v: T) -> Self {
                match self.days_of_week {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.days_of_week = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_all_day<T: Into<BooleanDt>>(mut self, v: T) -> Self {
                self.all_day = Some(v.into());
                self
            }
            pub fn set_available_start_time<T: Into<TimeDt>>(mut self, v: T) -> Self {
                self.available_start_time = Some(v.into());
                self
            }
            pub fn set_available_end_time<T: Into<TimeDt>>(mut self, v: T) -> Self {
                self.available_end_time = Some(v.into());
                self
            }
        }
        impl Serialize for AvailabilityAvailableTimeElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("daysOfWeek", &self.days_of_week)?;
                serialize_struct.serialize_field("allDay", &self.all_day)?;
                serialize_struct
                    .serialize_field("availableStartTime", &self.available_start_time)?;
                serialize_struct
                    .serialize_field("availableEndTime", &self.available_end_time)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for AvailabilityAvailableTimeElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct AvailabilityAvailableTimeElementVisitor;
                impl<'de> Visitor<'de> for AvailabilityAvailableTimeElementVisitor {
                    type Value = AvailabilityAvailableTimeElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut days_of_week: Option<Vec<CodeDt>> = None;
                        let mut all_day: Option<BooleanDt> = None;
                        let mut available_start_time: Option<TimeDt> = None;
                        let mut available_end_time: Option<TimeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "daysOfWeek" => {
                                    days_of_week = Some(mapp.next_value()?);
                                }
                                "allDay" => {
                                    all_day = Some(mapp.next_value()?);
                                }
                                "availableStartTime" => {
                                    available_start_time = Some(mapp.next_value()?);
                                }
                                "availableEndTime" => {
                                    available_end_time = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(AvailabilityAvailableTimeElement {
                            id,
                            extension,
                            days_of_week,
                            all_day,
                            available_start_time,
                            available_end_time,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", AvailabilityAvailableTimeElementVisitor)
            }
        }
        impl Executor for AvailabilityAvailableTimeElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "AvailabilityAvailableTimeElement",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "daysOfWeek" => self.days_of_week.exec(&comp),
                            "allDay" => self.all_day.exec(&comp),
                            "availableStartTime" => self.available_start_time.exec(&comp),
                            "availableEndTime" => self.available_end_time.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "AvailabilityAvailableTimeElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AvailabilityAvailableTimeElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "days_of_week",
                    "all_day",
                    "available_start_time",
                    "available_end_time",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.days_of_week,
                    &self.all_day,
                    &self.available_start_time,
                    &&self.available_end_time,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "AvailabilityAvailableTimeElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AvailabilityAvailableTimeElement {
            #[inline]
            fn clone(&self) -> AvailabilityAvailableTimeElement {
                AvailabilityAvailableTimeElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    days_of_week: ::core::clone::Clone::clone(&self.days_of_week),
                    all_day: ::core::clone::Clone::clone(&self.all_day),
                    available_start_time: ::core::clone::Clone::clone(
                        &self.available_start_time,
                    ),
                    available_end_time: ::core::clone::Clone::clone(
                        &self.available_end_time,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AvailabilityAvailableTimeElement {
            #[inline]
            fn default() -> AvailabilityAvailableTimeElement {
                AvailabilityAvailableTimeElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    days_of_week: ::core::default::Default::default(),
                    all_day: ::core::default::Default::default(),
                    available_start_time: ::core::default::Default::default(),
                    available_end_time: ::core::default::Default::default(),
                }
            }
        }
        pub struct AvailabilityNotAvailableTimeElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Reason presented to the user explaining why time not available
            #[fhir(
                name = "description",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub description: Option<StringDt>,
            /// Service not available during this period
            #[fhir(
                name = "during",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub during: Option<Period>,
        }
        impl Element for AvailabilityNotAvailableTimeElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for AvailabilityNotAvailableTimeElement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.description.is_none()
                    & self.during.is_none()
            }
            fn type_name(&self) -> String {
                "AvailabilityNotAvailableTimeElement".to_string()
            }
        }
        impl AvailabilityNotAvailableTimeElement {
            pub fn set_description<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.description = Some(v.into());
                self
            }
            pub fn set_during(mut self, v: Period) -> Self {
                self.during = Some(v);
                self
            }
        }
        impl Serialize for AvailabilityNotAvailableTimeElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("description", &self.description)?;
                serialize_struct.serialize_field("during", &self.during)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for AvailabilityNotAvailableTimeElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct AvailabilityNotAvailableTimeElementVisitor;
                impl<'de> Visitor<'de> for AvailabilityNotAvailableTimeElementVisitor {
                    type Value = AvailabilityNotAvailableTimeElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut description: Option<StringDt> = None;
                        let mut during: Option<Period> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "description" => {
                                    description = Some(mapp.next_value()?);
                                }
                                "during" => {
                                    during = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(AvailabilityNotAvailableTimeElement {
                            id,
                            extension,
                            description,
                            during,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", AvailabilityNotAvailableTimeElementVisitor)
            }
        }
        impl Executor for AvailabilityNotAvailableTimeElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "AvailabilityNotAvailableTimeElement",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "description" => self.description.exec(&comp),
                            "during" => self.during.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "AvailabilityNotAvailableTimeElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AvailabilityNotAvailableTimeElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "AvailabilityNotAvailableTimeElement",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "description",
                    &self.description,
                    "during",
                    &&self.during,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AvailabilityNotAvailableTimeElement {
            #[inline]
            fn clone(&self) -> AvailabilityNotAvailableTimeElement {
                AvailabilityNotAvailableTimeElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    description: ::core::clone::Clone::clone(&self.description),
                    during: ::core::clone::Clone::clone(&self.during),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AvailabilityNotAvailableTimeElement {
            #[inline]
            fn default() -> AvailabilityNotAvailableTimeElement {
                AvailabilityNotAvailableTimeElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    description: ::core::default::Default::default(),
                    during: ::core::default::Default::default(),
                }
            }
        }
        pub struct BackboneType {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Extensions that cannot be ignored even if unrecognized
            #[fhir(
                name = "modifierExtension",
                min = "0",
                max = "*",
                summary = true,
                modifier = true
            )]
            pub modifier_extension: Option<Vec<Extension>>,
        }
        impl Element for BackboneType {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for BackboneType {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.modifier_extension.is_none()
            }
            fn type_name(&self) -> String {
                "BackboneType".to_string()
            }
        }
        impl BackboneType {
            pub fn set_modifier_extension(mut self, v: Vec<Extension>) -> Self {
                self.modifier_extension = Some(v);
                self
            }
            pub fn add_modifier_extension(mut self, v: Extension) -> Self {
                match self.modifier_extension {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.modifier_extension = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for BackboneType {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct
                    .serialize_field("modifierExtension", &self.modifier_extension)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for BackboneType {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct BackboneTypeVisitor;
                impl<'de> Visitor<'de> for BackboneTypeVisitor {
                    type Value = BackboneType;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut modifier_extension: Option<Vec<Extension>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "modifierExtension" => {
                                    modifier_extension = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(BackboneType {
                            id,
                            extension,
                            modifier_extension,
                        })
                    }
                }
                deserializer.deserialize_struct("", BackboneTypeVisitor)
            }
        }
        impl Executor for BackboneType {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "BackboneType"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "modifierExtension" => self.modifier_extension.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "BackboneType",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BackboneType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "BackboneType",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "modifier_extension",
                    &&self.modifier_extension,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BackboneType {
            #[inline]
            fn clone(&self) -> BackboneType {
                BackboneType {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    modifier_extension: ::core::clone::Clone::clone(
                        &self.modifier_extension,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for BackboneType {
            #[inline]
            fn default() -> BackboneType {
                BackboneType {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    modifier_extension: ::core::default::Default::default(),
                }
            }
        }
        pub struct CodeableConcept {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Code defined by a terminology system
            #[fhir(
                name = "coding",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub coding: Option<Vec<Coding>>,
            /// Plain text representation of the concept
            #[fhir(
                name = "text",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub text: Option<StringDt>,
        }
        impl Element for CodeableConcept {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for CodeableConcept {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.coding.is_none() & self.text.is_none()
            }
            fn type_name(&self) -> String {
                "CodeableConcept".to_string()
            }
        }
        impl CodeableConcept {
            pub fn set_coding(mut self, v: Vec<Coding>) -> Self {
                self.coding = Some(v);
                self
            }
            pub fn add_coding(mut self, v: Coding) -> Self {
                match self.coding {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.coding = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_text<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.text = Some(v.into());
                self
            }
        }
        impl Serialize for CodeableConcept {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("coding", &self.coding)?;
                serialize_struct.serialize_field("text", &self.text)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for CodeableConcept {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct CodeableConceptVisitor;
                impl<'de> Visitor<'de> for CodeableConceptVisitor {
                    type Value = CodeableConcept;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut coding: Option<Vec<Coding>> = None;
                        let mut text: Option<StringDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "coding" => {
                                    coding = Some(mapp.next_value()?);
                                }
                                "text" => {
                                    text = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(CodeableConcept {
                            id,
                            extension,
                            coding,
                            text,
                        })
                    }
                }
                deserializer.deserialize_struct("", CodeableConceptVisitor)
            }
        }
        impl Executor for CodeableConcept {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "CodeableConcept"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "coding" => self.coding.exec(&comp),
                            "text" => self.text.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "CodeableConcept",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CodeableConcept {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "CodeableConcept",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "coding",
                    &self.coding,
                    "text",
                    &&self.text,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CodeableConcept {
            #[inline]
            fn clone(&self) -> CodeableConcept {
                CodeableConcept {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    coding: ::core::clone::Clone::clone(&self.coding),
                    text: ::core::clone::Clone::clone(&self.text),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CodeableConcept {
            #[inline]
            fn default() -> CodeableConcept {
                CodeableConcept {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    coding: ::core::default::Default::default(),
                    text: ::core::default::Default::default(),
                }
            }
        }
        pub struct CodeableReference {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Reference to a concept (by class)
            #[fhir(
                name = "concept",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub concept: Option<CodeableConcept>,
            /// Reference to a resource (by instance)
            #[fhir(
                name = "reference",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub reference: Option<Reference>,
        }
        impl Element for CodeableReference {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for CodeableReference {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.concept.is_none()
                    & self.reference.is_none()
            }
            fn type_name(&self) -> String {
                "CodeableReference".to_string()
            }
        }
        impl CodeableReference {
            pub fn set_concept(mut self, v: CodeableConcept) -> Self {
                self.concept = Some(v);
                self
            }
            pub fn set_reference(mut self, v: Reference) -> Self {
                self.reference = Some(v);
                self
            }
        }
        impl Serialize for CodeableReference {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("concept", &self.concept)?;
                serialize_struct.serialize_field("reference", &self.reference)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for CodeableReference {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct CodeableReferenceVisitor;
                impl<'de> Visitor<'de> for CodeableReferenceVisitor {
                    type Value = CodeableReference;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut concept: Option<CodeableConcept> = None;
                        let mut reference: Option<Reference> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "concept" => {
                                    concept = Some(mapp.next_value()?);
                                }
                                "reference" => {
                                    reference = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(CodeableReference {
                            id,
                            extension,
                            concept,
                            reference,
                        })
                    }
                }
                deserializer.deserialize_struct("", CodeableReferenceVisitor)
            }
        }
        impl Executor for CodeableReference {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "CodeableReference",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "concept" => self.concept.exec(&comp),
                            "reference" => self.reference.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "CodeableReference",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CodeableReference {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "CodeableReference",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "concept",
                    &self.concept,
                    "reference",
                    &&self.reference,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CodeableReference {
            #[inline]
            fn clone(&self) -> CodeableReference {
                CodeableReference {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    concept: ::core::clone::Clone::clone(&self.concept),
                    reference: ::core::clone::Clone::clone(&self.reference),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CodeableReference {
            #[inline]
            fn default() -> CodeableReference {
                CodeableReference {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    concept: ::core::default::Default::default(),
                    reference: ::core::default::Default::default(),
                }
            }
        }
        pub struct ContactDetail {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Name of an individual to contact
            #[fhir(
                name = "name",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub name: Option<StringDt>,
            /// Contact details for individual or organization
            #[fhir(
                name = "telecom",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub telecom: Option<Vec<ContactPoint>>,
        }
        impl Element for ContactDetail {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ContactDetail {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.name.is_none() & self.telecom.is_none()
            }
            fn type_name(&self) -> String {
                "ContactDetail".to_string()
            }
        }
        impl ContactDetail {
            pub fn set_name<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.name = Some(v.into());
                self
            }
            pub fn set_telecom(mut self, v: Vec<ContactPoint>) -> Self {
                self.telecom = Some(v);
                self
            }
            pub fn add_telecom(mut self, v: ContactPoint) -> Self {
                match self.telecom {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.telecom = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for ContactDetail {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("name", &self.name)?;
                serialize_struct.serialize_field("telecom", &self.telecom)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ContactDetail {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ContactDetailVisitor;
                impl<'de> Visitor<'de> for ContactDetailVisitor {
                    type Value = ContactDetail;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut name: Option<StringDt> = None;
                        let mut telecom: Option<Vec<ContactPoint>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "name" => {
                                    name = Some(mapp.next_value()?);
                                }
                                "telecom" => {
                                    telecom = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ContactDetail {
                            id,
                            extension,
                            name,
                            telecom,
                        })
                    }
                }
                deserializer.deserialize_struct("", ContactDetailVisitor)
            }
        }
        impl Executor for ContactDetail {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "ContactDetail"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "name" => self.name.exec(&comp),
                            "telecom" => self.telecom.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ContactDetail",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ContactDetail {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ContactDetail",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "name",
                    &self.name,
                    "telecom",
                    &&self.telecom,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ContactDetail {
            #[inline]
            fn clone(&self) -> ContactDetail {
                ContactDetail {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    name: ::core::clone::Clone::clone(&self.name),
                    telecom: ::core::clone::Clone::clone(&self.telecom),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ContactDetail {
            #[inline]
            fn default() -> ContactDetail {
                ContactDetail {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    telecom: ::core::default::Default::default(),
                }
            }
        }
        pub struct ContactPoint {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// phone | fax | email | pager | url | sms | other
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<CodeDt>,
            /// The actual contact point details
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<StringDt>,
            /// home | work | temp | old | mobile - purpose of this contact point
            #[fhir(name = "use", min = "0", max = "1", summary = true, modifier = true)]
            pub use_: Option<CodeDt>,
            /// Specify preferred order of use (1 = highest)
            #[fhir(
                name = "rank",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub rank: Option<PositiveIntDt>,
            /// Time period when the contact point was/is in use
            #[fhir(
                name = "period",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period: Option<Period>,
        }
        impl Element for ContactPoint {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ContactPoint {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.system.is_none() & self.value.is_none()
                    & self.use_.is_none() & self.rank.is_none() & self.period.is_none()
            }
            fn type_name(&self) -> String {
                "ContactPoint".to_string()
            }
        }
        impl ContactPoint {
            pub fn set_system<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_value<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_use_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.use_ = Some(v.into());
                self
            }
            pub fn set_rank<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.rank = Some(v.into());
                self
            }
            pub fn set_period(mut self, v: Period) -> Self {
                self.period = Some(v);
                self
            }
        }
        impl Serialize for ContactPoint {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("use", &self.use_)?;
                serialize_struct.serialize_field("rank", &self.rank)?;
                serialize_struct.serialize_field("period", &self.period)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ContactPoint {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ContactPointVisitor;
                impl<'de> Visitor<'de> for ContactPointVisitor {
                    type Value = ContactPoint;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut system: Option<CodeDt> = None;
                        let mut value: Option<StringDt> = None;
                        let mut use_: Option<CodeDt> = None;
                        let mut rank: Option<PositiveIntDt> = None;
                        let mut period: Option<Period> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "use" => {
                                    use_ = Some(mapp.next_value()?);
                                }
                                "rank" => {
                                    rank = Some(mapp.next_value()?);
                                }
                                "period" => {
                                    period = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ContactPoint {
                            id,
                            extension,
                            system,
                            value,
                            use_,
                            rank,
                            period,
                        })
                    }
                }
                deserializer.deserialize_struct("", ContactPointVisitor)
            }
        }
        impl Executor for ContactPoint {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "ContactPoint"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "use" => self.use_.exec(&comp),
                            "rank" => self.rank.exec(&comp),
                            "period" => self.period.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ContactPoint",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ContactPoint {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "system",
                    "value",
                    "use_",
                    "rank",
                    "period",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.system,
                    &self.value,
                    &self.use_,
                    &self.rank,
                    &&self.period,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ContactPoint",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ContactPoint {
            #[inline]
            fn clone(&self) -> ContactPoint {
                ContactPoint {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    system: ::core::clone::Clone::clone(&self.system),
                    value: ::core::clone::Clone::clone(&self.value),
                    use_: ::core::clone::Clone::clone(&self.use_),
                    rank: ::core::clone::Clone::clone(&self.rank),
                    period: ::core::clone::Clone::clone(&self.period),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ContactPoint {
            #[inline]
            fn default() -> ContactPoint {
                ContactPoint {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    use_: ::core::default::Default::default(),
                    rank: ::core::default::Default::default(),
                    period: ::core::default::Default::default(),
                }
            }
        }
        pub struct Contributor {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// author | editor | reviewer | endorser
            #[fhir(
                name = "type",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeDt>,
            /// Who contributed the content
            #[fhir(
                name = "name",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub name: Option<StringDt>,
            /// Contact details of the contributor
            #[fhir(
                name = "contact",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub contact: Option<Vec<ContactDetail>>,
        }
        impl Element for Contributor {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Contributor {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.type_.is_none() & self.name.is_none()
                    & self.contact.is_none()
            }
            fn type_name(&self) -> String {
                "Contributor".to_string()
            }
        }
        impl Contributor {
            pub fn set_type_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.type_ = Some(v.into());
                self
            }
            pub fn set_name<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.name = Some(v.into());
                self
            }
            pub fn set_contact(mut self, v: Vec<ContactDetail>) -> Self {
                self.contact = Some(v);
                self
            }
            pub fn add_contact(mut self, v: ContactDetail) -> Self {
                match self.contact {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.contact = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for Contributor {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("name", &self.name)?;
                serialize_struct.serialize_field("contact", &self.contact)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Contributor {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ContributorVisitor;
                impl<'de> Visitor<'de> for ContributorVisitor {
                    type Value = Contributor;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<CodeDt> = None;
                        let mut name: Option<StringDt> = None;
                        let mut contact: Option<Vec<ContactDetail>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "name" => {
                                    name = Some(mapp.next_value()?);
                                }
                                "contact" => {
                                    contact = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Contributor {
                            id,
                            extension,
                            type_,
                            name,
                            contact,
                        })
                    }
                }
                deserializer.deserialize_struct("", ContributorVisitor)
            }
        }
        impl Executor for Contributor {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Contributor"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "name" => self.name.exec(&comp),
                            "contact" => self.contact.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Contributor",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Contributor {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "Contributor",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "type_",
                    &self.type_,
                    "name",
                    &self.name,
                    "contact",
                    &&self.contact,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Contributor {
            #[inline]
            fn clone(&self) -> Contributor {
                Contributor {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    name: ::core::clone::Clone::clone(&self.name),
                    contact: ::core::clone::Clone::clone(&self.contact),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Contributor {
            #[inline]
            fn default() -> Contributor {
                Contributor {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    contact: ::core::default::Default::default(),
                }
            }
        }
        pub struct Count {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerical value (with implicit precision)
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DecimalDt>,
            /// < | <= | >= | > | ad - how to understand the value
            #[fhir(
                name = "comparator",
                min = "0",
                max = "1",
                summary = true,
                modifier = true
            )]
            pub comparator: Option<CodeDt>,
            /// Unit representation
            #[fhir(
                name = "unit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub unit: Option<StringDt>,
            /// System that defines coded unit form
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// Coded form of the unit
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeDt>,
        }
        impl Element for Count {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Count {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.value.is_none()
                    & self.comparator.is_none() & self.unit.is_none()
                    & self.system.is_none() & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "Count".to_string()
            }
        }
        impl Count {
            pub fn set_value<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_comparator<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.comparator = Some(v.into());
                self
            }
            pub fn set_unit<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.unit = Some(v.into());
                self
            }
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_code<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.code = Some(v.into());
                self
            }
        }
        impl Serialize for Count {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("comparator", &self.comparator)?;
                serialize_struct.serialize_field("unit", &self.unit)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Count {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct CountVisitor;
                impl<'de> Visitor<'de> for CountVisitor {
                    type Value = Count;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DecimalDt> = None;
                        let mut comparator: Option<CodeDt> = None;
                        let mut unit: Option<StringDt> = None;
                        let mut system: Option<UriDt> = None;
                        let mut code: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "comparator" => {
                                    comparator = Some(mapp.next_value()?);
                                }
                                "unit" => {
                                    unit = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Count {
                            id,
                            extension,
                            value,
                            comparator,
                            unit,
                            system,
                            code,
                        })
                    }
                }
                deserializer.deserialize_struct("", CountVisitor)
            }
        }
        impl Executor for Count {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Count"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "comparator" => self.comparator.exec(&comp),
                            "unit" => self.unit.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Count",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Count {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "value",
                    "comparator",
                    "unit",
                    "system",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.value,
                    &self.comparator,
                    &self.unit,
                    &self.system,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Count",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Count {
            #[inline]
            fn clone(&self) -> Count {
                Count {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                    comparator: ::core::clone::Clone::clone(&self.comparator),
                    unit: ::core::clone::Clone::clone(&self.unit),
                    system: ::core::clone::Clone::clone(&self.system),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Count {
            #[inline]
            fn default() -> Count {
                Count {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    comparator: ::core::default::Default::default(),
                    unit: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
        pub struct DataRequirement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// The type of the required data
            #[fhir(
                name = "type",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeDt>,
            /// The profile of the required data
            #[fhir(
                name = "profile",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub profile: Option<Vec<CanonicalDt>>,
            /// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
            #[fhir(
                name = "subject",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub subject: Option<Reference>,
            /// Indicates specific structure elements that are referenced by the knowledge module
            #[fhir(
                name = "mustSupport",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub must_support: Option<Vec<StringDt>>,
            /// What codes are expected
            #[fhir(
                name = "codeFilter",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code_filter: Option<Vec<DataRequirementCodeFilterElement>>,
            /// What dates/date ranges are expected
            #[fhir(
                name = "dateFilter",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub date_filter: Option<Vec<DataRequirementDateFilterElement>>,
            /// What values are expected
            #[fhir(
                name = "valueFilter",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value_filter: Option<Vec<DataRequirementValueFilterElement>>,
            /// Number of results
            #[fhir(
                name = "limit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub limit: Option<PositiveIntDt>,
            /// Order of the results
            #[fhir(
                name = "sort",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub sort: Option<Vec<DataRequirementSortElement>>,
        }
        impl Element for DataRequirement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DataRequirement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.type_.is_none() & self.profile.is_none()
                    & self.subject.is_none() & self.must_support.is_none()
                    & self.code_filter.is_none() & self.date_filter.is_none()
                    & self.value_filter.is_none() & self.limit.is_none()
                    & self.sort.is_none()
            }
            fn type_name(&self) -> String {
                "DataRequirement".to_string()
            }
        }
        impl DataRequirement {
            pub fn set_type_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.type_ = Some(v.into());
                self
            }
            pub fn set_profile(mut self, v: Vec<CanonicalDt>) -> Self {
                self.profile = Some(v);
                self
            }
            pub fn add_profile<T: Into<CanonicalDt>>(mut self, v: T) -> Self {
                match self.profile {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.profile = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_subject(mut self, v: Reference) -> Self {
                self.subject = Some(v);
                self
            }
            pub fn set_must_support(mut self, v: Vec<StringDt>) -> Self {
                self.must_support = Some(v);
                self
            }
            pub fn add_must_support<T: Into<StringDt>>(mut self, v: T) -> Self {
                match self.must_support {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.must_support = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_code_filter(
                mut self,
                v: Vec<DataRequirementCodeFilterElement>,
            ) -> Self {
                self.code_filter = Some(v);
                self
            }
            pub fn add_code_filter(
                mut self,
                v: DataRequirementCodeFilterElement,
            ) -> Self {
                match self.code_filter {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.code_filter = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_date_filter(
                mut self,
                v: Vec<DataRequirementDateFilterElement>,
            ) -> Self {
                self.date_filter = Some(v);
                self
            }
            pub fn add_date_filter(
                mut self,
                v: DataRequirementDateFilterElement,
            ) -> Self {
                match self.date_filter {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.date_filter = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_value_filter(
                mut self,
                v: Vec<DataRequirementValueFilterElement>,
            ) -> Self {
                self.value_filter = Some(v);
                self
            }
            pub fn add_value_filter(
                mut self,
                v: DataRequirementValueFilterElement,
            ) -> Self {
                match self.value_filter {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.value_filter = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_limit<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.limit = Some(v.into());
                self
            }
            pub fn set_sort(mut self, v: Vec<DataRequirementSortElement>) -> Self {
                self.sort = Some(v);
                self
            }
            pub fn add_sort(mut self, v: DataRequirementSortElement) -> Self {
                match self.sort {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.sort = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for DataRequirement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("profile", &self.profile)?;
                serialize_struct.serialize_field("subject", &self.subject)?;
                serialize_struct.serialize_field("mustSupport", &self.must_support)?;
                serialize_struct.serialize_field("codeFilter", &self.code_filter)?;
                serialize_struct.serialize_field("dateFilter", &self.date_filter)?;
                serialize_struct.serialize_field("valueFilter", &self.value_filter)?;
                serialize_struct.serialize_field("limit", &self.limit)?;
                serialize_struct.serialize_field("sort", &self.sort)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DataRequirement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DataRequirementVisitor;
                impl<'de> Visitor<'de> for DataRequirementVisitor {
                    type Value = DataRequirement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<CodeDt> = None;
                        let mut profile: Option<Vec<CanonicalDt>> = None;
                        let mut subject: Option<Reference> = None;
                        let mut must_support: Option<Vec<StringDt>> = None;
                        let mut code_filter: Option<
                            Vec<DataRequirementCodeFilterElement>,
                        > = None;
                        let mut date_filter: Option<
                            Vec<DataRequirementDateFilterElement>,
                        > = None;
                        let mut value_filter: Option<
                            Vec<DataRequirementValueFilterElement>,
                        > = None;
                        let mut limit: Option<PositiveIntDt> = None;
                        let mut sort: Option<Vec<DataRequirementSortElement>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "profile" => {
                                    profile = Some(mapp.next_value()?);
                                }
                                "subject" => {
                                    subject = Some(mapp.next_value()?);
                                }
                                "mustSupport" => {
                                    must_support = Some(mapp.next_value()?);
                                }
                                "codeFilter" => {
                                    code_filter = Some(mapp.next_value()?);
                                }
                                "dateFilter" => {
                                    date_filter = Some(mapp.next_value()?);
                                }
                                "valueFilter" => {
                                    value_filter = Some(mapp.next_value()?);
                                }
                                "limit" => {
                                    limit = Some(mapp.next_value()?);
                                }
                                "sort" => {
                                    sort = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(DataRequirement {
                            id,
                            extension,
                            type_,
                            profile,
                            subject,
                            must_support,
                            code_filter,
                            date_filter,
                            value_filter,
                            limit,
                            sort,
                        })
                    }
                }
                deserializer.deserialize_struct("", DataRequirementVisitor)
            }
        }
        impl Executor for DataRequirement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "DataRequirement"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "profile" => self.profile.exec(&comp),
                            "subject" => self.subject.exec(&comp),
                            "mustSupport" => self.must_support.exec(&comp),
                            "codeFilter" => self.code_filter.exec(&comp),
                            "dateFilter" => self.date_filter.exec(&comp),
                            "valueFilter" => self.value_filter.exec(&comp),
                            "limit" => self.limit.exec(&comp),
                            "sort" => self.sort.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DataRequirement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DataRequirement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "type_",
                    "profile",
                    "subject",
                    "must_support",
                    "code_filter",
                    "date_filter",
                    "value_filter",
                    "limit",
                    "sort",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.type_,
                    &self.profile,
                    &self.subject,
                    &self.must_support,
                    &self.code_filter,
                    &self.date_filter,
                    &self.value_filter,
                    &self.limit,
                    &&self.sort,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "DataRequirement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DataRequirement {
            #[inline]
            fn clone(&self) -> DataRequirement {
                DataRequirement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    profile: ::core::clone::Clone::clone(&self.profile),
                    subject: ::core::clone::Clone::clone(&self.subject),
                    must_support: ::core::clone::Clone::clone(&self.must_support),
                    code_filter: ::core::clone::Clone::clone(&self.code_filter),
                    date_filter: ::core::clone::Clone::clone(&self.date_filter),
                    value_filter: ::core::clone::Clone::clone(&self.value_filter),
                    limit: ::core::clone::Clone::clone(&self.limit),
                    sort: ::core::clone::Clone::clone(&self.sort),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DataRequirement {
            #[inline]
            fn default() -> DataRequirement {
                DataRequirement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    profile: ::core::default::Default::default(),
                    subject: ::core::default::Default::default(),
                    must_support: ::core::default::Default::default(),
                    code_filter: ::core::default::Default::default(),
                    date_filter: ::core::default::Default::default(),
                    value_filter: ::core::default::Default::default(),
                    limit: ::core::default::Default::default(),
                    sort: ::core::default::Default::default(),
                }
            }
        }
        pub struct DataRequirementSortElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// The name of the attribute to perform the sort
            #[fhir(
                name = "path",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub path: Option<StringDt>,
            /// ascending | descending
            #[fhir(
                name = "direction",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub direction: Option<CodeDt>,
        }
        impl Element for DataRequirementSortElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DataRequirementSortElement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.path.is_none() & self.direction.is_none()
            }
            fn type_name(&self) -> String {
                "DataRequirementSortElement".to_string()
            }
        }
        impl DataRequirementSortElement {
            pub fn set_path<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.path = Some(v.into());
                self
            }
            pub fn set_direction<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.direction = Some(v.into());
                self
            }
        }
        impl Serialize for DataRequirementSortElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("path", &self.path)?;
                serialize_struct.serialize_field("direction", &self.direction)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DataRequirementSortElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DataRequirementSortElementVisitor;
                impl<'de> Visitor<'de> for DataRequirementSortElementVisitor {
                    type Value = DataRequirementSortElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut path: Option<StringDt> = None;
                        let mut direction: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "path" => {
                                    path = Some(mapp.next_value()?);
                                }
                                "direction" => {
                                    direction = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(DataRequirementSortElement {
                            id,
                            extension,
                            path,
                            direction,
                        })
                    }
                }
                deserializer.deserialize_struct("", DataRequirementSortElementVisitor)
            }
        }
        impl Executor for DataRequirementSortElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "DataRequirementSortElement",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "path" => self.path.exec(&comp),
                            "direction" => self.direction.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DataRequirementSortElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DataRequirementSortElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "DataRequirementSortElement",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "path",
                    &self.path,
                    "direction",
                    &&self.direction,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DataRequirementSortElement {
            #[inline]
            fn clone(&self) -> DataRequirementSortElement {
                DataRequirementSortElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    path: ::core::clone::Clone::clone(&self.path),
                    direction: ::core::clone::Clone::clone(&self.direction),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DataRequirementSortElement {
            #[inline]
            fn default() -> DataRequirementSortElement {
                DataRequirementSortElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    path: ::core::default::Default::default(),
                    direction: ::core::default::Default::default(),
                }
            }
        }
        pub struct DataRequirementCodeFilterElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// A code-valued attribute to filter on
            #[fhir(
                name = "path",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub path: Option<StringDt>,
            /// A coded (token) parameter to search on
            #[fhir(
                name = "searchParam",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub search_param: Option<StringDt>,
            /// ValueSet for the filter
            #[fhir(
                name = "valueSet",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value_set: Option<CanonicalDt>,
            /// What code is expected
            #[fhir(
                name = "code",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<Vec<Coding>>,
        }
        impl Element for DataRequirementCodeFilterElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DataRequirementCodeFilterElement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.path.is_none()
                    & self.search_param.is_none() & self.value_set.is_none()
                    & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "DataRequirementCodeFilterElement".to_string()
            }
        }
        impl DataRequirementCodeFilterElement {
            pub fn set_path<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.path = Some(v.into());
                self
            }
            pub fn set_search_param<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.search_param = Some(v.into());
                self
            }
            pub fn set_value_set<T: Into<CanonicalDt>>(mut self, v: T) -> Self {
                self.value_set = Some(v.into());
                self
            }
            pub fn set_code(mut self, v: Vec<Coding>) -> Self {
                self.code = Some(v);
                self
            }
            pub fn add_code(mut self, v: Coding) -> Self {
                match self.code {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.code = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for DataRequirementCodeFilterElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("path", &self.path)?;
                serialize_struct.serialize_field("searchParam", &self.search_param)?;
                serialize_struct.serialize_field("valueSet", &self.value_set)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DataRequirementCodeFilterElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DataRequirementCodeFilterElementVisitor;
                impl<'de> Visitor<'de> for DataRequirementCodeFilterElementVisitor {
                    type Value = DataRequirementCodeFilterElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut path: Option<StringDt> = None;
                        let mut search_param: Option<StringDt> = None;
                        let mut value_set: Option<CanonicalDt> = None;
                        let mut code: Option<Vec<Coding>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "path" => {
                                    path = Some(mapp.next_value()?);
                                }
                                "searchParam" => {
                                    search_param = Some(mapp.next_value()?);
                                }
                                "valueSet" => {
                                    value_set = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(DataRequirementCodeFilterElement {
                            id,
                            extension,
                            path,
                            search_param,
                            value_set,
                            code,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", DataRequirementCodeFilterElementVisitor)
            }
        }
        impl Executor for DataRequirementCodeFilterElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "DataRequirementCodeFilterElement",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "path" => self.path.exec(&comp),
                            "searchParam" => self.search_param.exec(&comp),
                            "valueSet" => self.value_set.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DataRequirementCodeFilterElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DataRequirementCodeFilterElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "path",
                    "search_param",
                    "value_set",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.path,
                    &self.search_param,
                    &self.value_set,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "DataRequirementCodeFilterElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DataRequirementCodeFilterElement {
            #[inline]
            fn clone(&self) -> DataRequirementCodeFilterElement {
                DataRequirementCodeFilterElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    path: ::core::clone::Clone::clone(&self.path),
                    search_param: ::core::clone::Clone::clone(&self.search_param),
                    value_set: ::core::clone::Clone::clone(&self.value_set),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DataRequirementCodeFilterElement {
            #[inline]
            fn default() -> DataRequirementCodeFilterElement {
                DataRequirementCodeFilterElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    path: ::core::default::Default::default(),
                    search_param: ::core::default::Default::default(),
                    value_set: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
        pub struct DataRequirementValueFilterElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// An attribute to filter on
            #[fhir(
                name = "path",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub path: Option<StringDt>,
            /// A parameter to search on
            #[fhir(
                name = "searchParam",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub search_param: Option<StringDt>,
            /// eq | gt | lt | ge | le | sa | eb
            #[fhir(
                name = "comparator",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub comparator: Option<CodeDt>,
            /// The value of the filter, as a Period, DateTime, or Duration value
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Duration>,
        }
        impl Element for DataRequirementValueFilterElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DataRequirementValueFilterElement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.path.is_none()
                    & self.search_param.is_none() & self.comparator.is_none()
                    & self.value.is_none()
            }
            fn type_name(&self) -> String {
                "DataRequirementValueFilterElement".to_string()
            }
        }
        impl DataRequirementValueFilterElement {
            pub fn set_path<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.path = Some(v.into());
                self
            }
            pub fn set_search_param<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.search_param = Some(v.into());
                self
            }
            pub fn set_comparator<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.comparator = Some(v.into());
                self
            }
            pub fn set_value(mut self, v: Duration) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Serialize for DataRequirementValueFilterElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("path", &self.path)?;
                serialize_struct.serialize_field("searchParam", &self.search_param)?;
                serialize_struct.serialize_field("comparator", &self.comparator)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DataRequirementValueFilterElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DataRequirementValueFilterElementVisitor;
                impl<'de> Visitor<'de> for DataRequirementValueFilterElementVisitor {
                    type Value = DataRequirementValueFilterElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut path: Option<StringDt> = None;
                        let mut search_param: Option<StringDt> = None;
                        let mut comparator: Option<CodeDt> = None;
                        let mut value: Option<Duration> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "path" => {
                                    path = Some(mapp.next_value()?);
                                }
                                "searchParam" => {
                                    search_param = Some(mapp.next_value()?);
                                }
                                "comparator" => {
                                    comparator = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(DataRequirementValueFilterElement {
                            id,
                            extension,
                            path,
                            search_param,
                            comparator,
                            value,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", DataRequirementValueFilterElementVisitor)
            }
        }
        impl Executor for DataRequirementValueFilterElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "DataRequirementValueFilterElement",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "path" => self.path.exec(&comp),
                            "searchParam" => self.search_param.exec(&comp),
                            "comparator" => self.comparator.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DataRequirementValueFilterElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DataRequirementValueFilterElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "path",
                    "search_param",
                    "comparator",
                    "value",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.path,
                    &self.search_param,
                    &self.comparator,
                    &&self.value,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "DataRequirementValueFilterElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DataRequirementValueFilterElement {
            #[inline]
            fn clone(&self) -> DataRequirementValueFilterElement {
                DataRequirementValueFilterElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    path: ::core::clone::Clone::clone(&self.path),
                    search_param: ::core::clone::Clone::clone(&self.search_param),
                    comparator: ::core::clone::Clone::clone(&self.comparator),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DataRequirementValueFilterElement {
            #[inline]
            fn default() -> DataRequirementValueFilterElement {
                DataRequirementValueFilterElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    path: ::core::default::Default::default(),
                    search_param: ::core::default::Default::default(),
                    comparator: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        pub struct DataRequirementDateFilterElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// A date-valued attribute to filter on
            #[fhir(
                name = "path",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub path: Option<StringDt>,
            /// A date valued parameter to search on
            #[fhir(
                name = "searchParam",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub search_param: Option<StringDt>,
            /// The value of the filter, as a Period, DateTime, or Duration value
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Duration>,
        }
        impl Element for DataRequirementDateFilterElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DataRequirementDateFilterElement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.path.is_none()
                    & self.search_param.is_none() & self.value.is_none()
            }
            fn type_name(&self) -> String {
                "DataRequirementDateFilterElement".to_string()
            }
        }
        impl DataRequirementDateFilterElement {
            pub fn set_path<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.path = Some(v.into());
                self
            }
            pub fn set_search_param<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.search_param = Some(v.into());
                self
            }
            pub fn set_value(mut self, v: Duration) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Serialize for DataRequirementDateFilterElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("path", &self.path)?;
                serialize_struct.serialize_field("searchParam", &self.search_param)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DataRequirementDateFilterElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DataRequirementDateFilterElementVisitor;
                impl<'de> Visitor<'de> for DataRequirementDateFilterElementVisitor {
                    type Value = DataRequirementDateFilterElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut path: Option<StringDt> = None;
                        let mut search_param: Option<StringDt> = None;
                        let mut value: Option<Duration> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "path" => {
                                    path = Some(mapp.next_value()?);
                                }
                                "searchParam" => {
                                    search_param = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(DataRequirementDateFilterElement {
                            id,
                            extension,
                            path,
                            search_param,
                            value,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", DataRequirementDateFilterElementVisitor)
            }
        }
        impl Executor for DataRequirementDateFilterElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "DataRequirementDateFilterElement",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "path" => self.path.exec(&comp),
                            "searchParam" => self.search_param.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DataRequirementDateFilterElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DataRequirementDateFilterElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "DataRequirementDateFilterElement",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "path",
                    &self.path,
                    "search_param",
                    &self.search_param,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DataRequirementDateFilterElement {
            #[inline]
            fn clone(&self) -> DataRequirementDateFilterElement {
                DataRequirementDateFilterElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    path: ::core::clone::Clone::clone(&self.path),
                    search_param: ::core::clone::Clone::clone(&self.search_param),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DataRequirementDateFilterElement {
            #[inline]
            fn default() -> DataRequirementDateFilterElement {
                DataRequirementDateFilterElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    path: ::core::default::Default::default(),
                    search_param: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        pub struct Complex {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
        }
        impl Element for Complex {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Complex {
            fn is_empty(&self) -> bool {
                self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "Complex".to_string()
            }
        }
        impl Complex {}
        impl Serialize for Complex {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Complex {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ComplexVisitor;
                impl<'de> Visitor<'de> for ComplexVisitor {
                    type Value = Complex;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Complex { id, extension })
                    }
                }
                deserializer.deserialize_struct("", ComplexVisitor)
            }
        }
        impl Executor for Complex {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Complex"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Complex",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Complex {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Complex",
                    "id",
                    &self.id,
                    "extension",
                    &&self.extension,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Complex {
            #[inline]
            fn clone(&self) -> Complex {
                Complex {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Complex {
            #[inline]
            fn default() -> Complex {
                Complex {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                }
            }
        }
        pub struct Distance {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerical value (with implicit precision)
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DecimalDt>,
            /// < | <= | >= | > | ad - how to understand the value
            #[fhir(
                name = "comparator",
                min = "0",
                max = "1",
                summary = true,
                modifier = true
            )]
            pub comparator: Option<CodeDt>,
            /// Unit representation
            #[fhir(
                name = "unit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub unit: Option<StringDt>,
            /// System that defines coded unit form
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// Coded form of the unit
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeDt>,
        }
        impl Element for Distance {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Distance {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.value.is_none()
                    & self.comparator.is_none() & self.unit.is_none()
                    & self.system.is_none() & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "Distance".to_string()
            }
        }
        impl Distance {
            pub fn set_value<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_comparator<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.comparator = Some(v.into());
                self
            }
            pub fn set_unit<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.unit = Some(v.into());
                self
            }
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_code<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.code = Some(v.into());
                self
            }
        }
        impl Serialize for Distance {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("comparator", &self.comparator)?;
                serialize_struct.serialize_field("unit", &self.unit)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Distance {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DistanceVisitor;
                impl<'de> Visitor<'de> for DistanceVisitor {
                    type Value = Distance;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DecimalDt> = None;
                        let mut comparator: Option<CodeDt> = None;
                        let mut unit: Option<StringDt> = None;
                        let mut system: Option<UriDt> = None;
                        let mut code: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "comparator" => {
                                    comparator = Some(mapp.next_value()?);
                                }
                                "unit" => {
                                    unit = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Distance {
                            id,
                            extension,
                            value,
                            comparator,
                            unit,
                            system,
                            code,
                        })
                    }
                }
                deserializer.deserialize_struct("", DistanceVisitor)
            }
        }
        impl Executor for Distance {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Distance"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "comparator" => self.comparator.exec(&comp),
                            "unit" => self.unit.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Distance",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Distance {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "value",
                    "comparator",
                    "unit",
                    "system",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.value,
                    &self.comparator,
                    &self.unit,
                    &self.system,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Distance",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Distance {
            #[inline]
            fn clone(&self) -> Distance {
                Distance {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                    comparator: ::core::clone::Clone::clone(&self.comparator),
                    unit: ::core::clone::Clone::clone(&self.unit),
                    system: ::core::clone::Clone::clone(&self.system),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Distance {
            #[inline]
            fn default() -> Distance {
                Distance {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    comparator: ::core::default::Default::default(),
                    unit: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
        pub struct Dosage {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Extensions that cannot be ignored even if unrecognized
            #[fhir(
                name = "modifierExtension",
                min = "0",
                max = "*",
                summary = true,
                modifier = true
            )]
            pub modifier_extension: Option<Vec<Extension>>,
            /// The order of the dosage instructions
            #[fhir(
                name = "sequence",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub sequence: Option<IntegerDt>,
            /// Free text dosage instructions e.g. SIG
            #[fhir(
                name = "text",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub text: Option<StringDt>,
            /// Supplemental instruction or warnings to the patient - e.g. "with meals", "may cause drowsiness"
            #[fhir(
                name = "additionalInstruction",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub additional_instruction: Option<Vec<CodeableConcept>>,
            /// Patient or consumer oriented instructions
            #[fhir(
                name = "patientInstruction",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub patient_instruction: Option<StringDt>,
            /// When medication should be administered
            #[fhir(
                name = "timing",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub timing: Option<Timing>,
            /// Take "as needed"
            #[fhir(
                name = "asNeeded",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub as_needed: Option<BooleanDt>,
            /// Take "as needed" (for x)
            #[fhir(
                name = "asNeededFor",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub as_needed_for: Option<Vec<CodeableConcept>>,
            /// Body site to administer to
            #[fhir(
                name = "site",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub site: Option<CodeableConcept>,
            /// How drug should enter body
            #[fhir(
                name = "route",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub route: Option<CodeableConcept>,
            /// Technique for administering medication
            #[fhir(
                name = "method",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub method: Option<CodeableConcept>,
            /// Amount of medication administered, to be administered or typical amount to be administered
            #[fhir(
                name = "doseAndRate",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub dose_and_rate: Option<Vec<DosageDoseAndRateElement>>,
            /// Upper limit on medication per unit of time
            #[fhir(
                name = "maxDosePerPeriod",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max_dose_per_period: Option<Vec<Ratio>>,
            /// Upper limit on medication per administration
            #[fhir(
                name = "maxDosePerAdministration",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max_dose_per_administration: Option<Quantity>,
            /// Upper limit on medication per lifetime of the patient
            #[fhir(
                name = "maxDosePerLifetime",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max_dose_per_lifetime: Option<Quantity>,
        }
        impl Element for Dosage {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Dosage {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.modifier_extension.is_none()
                    & self.sequence.is_none() & self.text.is_none()
                    & self.additional_instruction.is_none()
                    & self.patient_instruction.is_none() & self.timing.is_none()
                    & self.as_needed.is_none() & self.as_needed_for.is_none()
                    & self.site.is_none() & self.route.is_none() & self.method.is_none()
                    & self.dose_and_rate.is_none() & self.max_dose_per_period.is_none()
                    & self.max_dose_per_administration.is_none()
                    & self.max_dose_per_lifetime.is_none()
            }
            fn type_name(&self) -> String {
                "Dosage".to_string()
            }
        }
        impl Dosage {
            pub fn set_modifier_extension(mut self, v: Vec<Extension>) -> Self {
                self.modifier_extension = Some(v);
                self
            }
            pub fn add_modifier_extension(mut self, v: Extension) -> Self {
                match self.modifier_extension {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.modifier_extension = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_sequence<T: Into<IntegerDt>>(mut self, v: T) -> Self {
                self.sequence = Some(v.into());
                self
            }
            pub fn set_text<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.text = Some(v.into());
                self
            }
            pub fn set_additional_instruction(
                mut self,
                v: Vec<CodeableConcept>,
            ) -> Self {
                self.additional_instruction = Some(v);
                self
            }
            pub fn add_additional_instruction(mut self, v: CodeableConcept) -> Self {
                match self.additional_instruction {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.additional_instruction = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_patient_instruction<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.patient_instruction = Some(v.into());
                self
            }
            pub fn set_timing(mut self, v: Timing) -> Self {
                self.timing = Some(v);
                self
            }
            pub fn set_as_needed<T: Into<BooleanDt>>(mut self, v: T) -> Self {
                self.as_needed = Some(v.into());
                self
            }
            pub fn set_as_needed_for(mut self, v: Vec<CodeableConcept>) -> Self {
                self.as_needed_for = Some(v);
                self
            }
            pub fn add_as_needed_for(mut self, v: CodeableConcept) -> Self {
                match self.as_needed_for {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.as_needed_for = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_site(mut self, v: CodeableConcept) -> Self {
                self.site = Some(v);
                self
            }
            pub fn set_route(mut self, v: CodeableConcept) -> Self {
                self.route = Some(v);
                self
            }
            pub fn set_method(mut self, v: CodeableConcept) -> Self {
                self.method = Some(v);
                self
            }
            pub fn set_dose_and_rate(
                mut self,
                v: Vec<DosageDoseAndRateElement>,
            ) -> Self {
                self.dose_and_rate = Some(v);
                self
            }
            pub fn add_dose_and_rate(mut self, v: DosageDoseAndRateElement) -> Self {
                match self.dose_and_rate {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.dose_and_rate = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_max_dose_per_period(mut self, v: Vec<Ratio>) -> Self {
                self.max_dose_per_period = Some(v);
                self
            }
            pub fn add_max_dose_per_period(mut self, v: Ratio) -> Self {
                match self.max_dose_per_period {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.max_dose_per_period = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_max_dose_per_administration(mut self, v: Quantity) -> Self {
                self.max_dose_per_administration = Some(v);
                self
            }
            pub fn set_max_dose_per_lifetime(mut self, v: Quantity) -> Self {
                self.max_dose_per_lifetime = Some(v);
                self
            }
        }
        impl Serialize for Dosage {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct
                    .serialize_field("modifierExtension", &self.modifier_extension)?;
                serialize_struct.serialize_field("sequence", &self.sequence)?;
                serialize_struct.serialize_field("text", &self.text)?;
                serialize_struct
                    .serialize_field(
                        "additionalInstruction",
                        &self.additional_instruction,
                    )?;
                serialize_struct
                    .serialize_field("patientInstruction", &self.patient_instruction)?;
                serialize_struct.serialize_field("timing", &self.timing)?;
                serialize_struct.serialize_field("asNeeded", &self.as_needed)?;
                serialize_struct.serialize_field("asNeededFor", &self.as_needed_for)?;
                serialize_struct.serialize_field("site", &self.site)?;
                serialize_struct.serialize_field("route", &self.route)?;
                serialize_struct.serialize_field("method", &self.method)?;
                serialize_struct.serialize_field("doseAndRate", &self.dose_and_rate)?;
                serialize_struct
                    .serialize_field("maxDosePerPeriod", &self.max_dose_per_period)?;
                serialize_struct
                    .serialize_field(
                        "maxDosePerAdministration",
                        &self.max_dose_per_administration,
                    )?;
                serialize_struct
                    .serialize_field("maxDosePerLifetime", &self.max_dose_per_lifetime)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Dosage {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DosageVisitor;
                impl<'de> Visitor<'de> for DosageVisitor {
                    type Value = Dosage;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut modifier_extension: Option<Vec<Extension>> = None;
                        let mut sequence: Option<IntegerDt> = None;
                        let mut text: Option<StringDt> = None;
                        let mut additional_instruction: Option<Vec<CodeableConcept>> = None;
                        let mut patient_instruction: Option<StringDt> = None;
                        let mut timing: Option<Timing> = None;
                        let mut as_needed: Option<BooleanDt> = None;
                        let mut as_needed_for: Option<Vec<CodeableConcept>> = None;
                        let mut site: Option<CodeableConcept> = None;
                        let mut route: Option<CodeableConcept> = None;
                        let mut method: Option<CodeableConcept> = None;
                        let mut dose_and_rate: Option<Vec<DosageDoseAndRateElement>> = None;
                        let mut max_dose_per_period: Option<Vec<Ratio>> = None;
                        let mut max_dose_per_administration: Option<Quantity> = None;
                        let mut max_dose_per_lifetime: Option<Quantity> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "modifierExtension" => {
                                    modifier_extension = Some(mapp.next_value()?);
                                }
                                "sequence" => {
                                    sequence = Some(mapp.next_value()?);
                                }
                                "text" => {
                                    text = Some(mapp.next_value()?);
                                }
                                "additionalInstruction" => {
                                    additional_instruction = Some(mapp.next_value()?);
                                }
                                "patientInstruction" => {
                                    patient_instruction = Some(mapp.next_value()?);
                                }
                                "timing" => {
                                    timing = Some(mapp.next_value()?);
                                }
                                "asNeeded" => {
                                    as_needed = Some(mapp.next_value()?);
                                }
                                "asNeededFor" => {
                                    as_needed_for = Some(mapp.next_value()?);
                                }
                                "site" => {
                                    site = Some(mapp.next_value()?);
                                }
                                "route" => {
                                    route = Some(mapp.next_value()?);
                                }
                                "method" => {
                                    method = Some(mapp.next_value()?);
                                }
                                "doseAndRate" => {
                                    dose_and_rate = Some(mapp.next_value()?);
                                }
                                "maxDosePerPeriod" => {
                                    max_dose_per_period = Some(mapp.next_value()?);
                                }
                                "maxDosePerAdministration" => {
                                    max_dose_per_administration = Some(mapp.next_value()?);
                                }
                                "maxDosePerLifetime" => {
                                    max_dose_per_lifetime = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Dosage {
                            id,
                            extension,
                            modifier_extension,
                            sequence,
                            text,
                            additional_instruction,
                            patient_instruction,
                            timing,
                            as_needed,
                            as_needed_for,
                            site,
                            route,
                            method,
                            dose_and_rate,
                            max_dose_per_period,
                            max_dose_per_administration,
                            max_dose_per_lifetime,
                        })
                    }
                }
                deserializer.deserialize_struct("", DosageVisitor)
            }
        }
        impl Executor for Dosage {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Dosage"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "modifierExtension" => self.modifier_extension.exec(&comp),
                            "sequence" => self.sequence.exec(&comp),
                            "text" => self.text.exec(&comp),
                            "additionalInstruction" => {
                                self.additional_instruction.exec(&comp)
                            }
                            "patientInstruction" => self.patient_instruction.exec(&comp),
                            "timing" => self.timing.exec(&comp),
                            "asNeeded" => self.as_needed.exec(&comp),
                            "asNeededFor" => self.as_needed_for.exec(&comp),
                            "site" => self.site.exec(&comp),
                            "route" => self.route.exec(&comp),
                            "method" => self.method.exec(&comp),
                            "doseAndRate" => self.dose_and_rate.exec(&comp),
                            "maxDosePerPeriod" => self.max_dose_per_period.exec(&comp),
                            "maxDosePerAdministration" => {
                                self.max_dose_per_administration.exec(&comp)
                            }
                            "maxDosePerLifetime" => {
                                self.max_dose_per_lifetime.exec(&comp)
                            }
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Dosage",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Dosage {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "modifier_extension",
                    "sequence",
                    "text",
                    "additional_instruction",
                    "patient_instruction",
                    "timing",
                    "as_needed",
                    "as_needed_for",
                    "site",
                    "route",
                    "method",
                    "dose_and_rate",
                    "max_dose_per_period",
                    "max_dose_per_administration",
                    "max_dose_per_lifetime",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.modifier_extension,
                    &self.sequence,
                    &self.text,
                    &self.additional_instruction,
                    &self.patient_instruction,
                    &self.timing,
                    &self.as_needed,
                    &self.as_needed_for,
                    &self.site,
                    &self.route,
                    &self.method,
                    &self.dose_and_rate,
                    &self.max_dose_per_period,
                    &self.max_dose_per_administration,
                    &&self.max_dose_per_lifetime,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Dosage",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Dosage {
            #[inline]
            fn clone(&self) -> Dosage {
                Dosage {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    modifier_extension: ::core::clone::Clone::clone(
                        &self.modifier_extension,
                    ),
                    sequence: ::core::clone::Clone::clone(&self.sequence),
                    text: ::core::clone::Clone::clone(&self.text),
                    additional_instruction: ::core::clone::Clone::clone(
                        &self.additional_instruction,
                    ),
                    patient_instruction: ::core::clone::Clone::clone(
                        &self.patient_instruction,
                    ),
                    timing: ::core::clone::Clone::clone(&self.timing),
                    as_needed: ::core::clone::Clone::clone(&self.as_needed),
                    as_needed_for: ::core::clone::Clone::clone(&self.as_needed_for),
                    site: ::core::clone::Clone::clone(&self.site),
                    route: ::core::clone::Clone::clone(&self.route),
                    method: ::core::clone::Clone::clone(&self.method),
                    dose_and_rate: ::core::clone::Clone::clone(&self.dose_and_rate),
                    max_dose_per_period: ::core::clone::Clone::clone(
                        &self.max_dose_per_period,
                    ),
                    max_dose_per_administration: ::core::clone::Clone::clone(
                        &self.max_dose_per_administration,
                    ),
                    max_dose_per_lifetime: ::core::clone::Clone::clone(
                        &self.max_dose_per_lifetime,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Dosage {
            #[inline]
            fn default() -> Dosage {
                Dosage {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    modifier_extension: ::core::default::Default::default(),
                    sequence: ::core::default::Default::default(),
                    text: ::core::default::Default::default(),
                    additional_instruction: ::core::default::Default::default(),
                    patient_instruction: ::core::default::Default::default(),
                    timing: ::core::default::Default::default(),
                    as_needed: ::core::default::Default::default(),
                    as_needed_for: ::core::default::Default::default(),
                    site: ::core::default::Default::default(),
                    route: ::core::default::Default::default(),
                    method: ::core::default::Default::default(),
                    dose_and_rate: ::core::default::Default::default(),
                    max_dose_per_period: ::core::default::Default::default(),
                    max_dose_per_administration: ::core::default::Default::default(),
                    max_dose_per_lifetime: ::core::default::Default::default(),
                }
            }
        }
        pub struct DosageDoseAndRateElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// The kind of dose or rate specified
            #[fhir(
                name = "type",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeableConcept>,
            /// Amount of medication per dose
            #[fhir(
                name = "dose",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub dose: Option<Quantity>,
            /// Amount of medication per unit of time
            #[fhir(
                name = "rate",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub rate: Option<Quantity>,
        }
        impl Element for DosageDoseAndRateElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for DosageDoseAndRateElement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.type_.is_none() & self.dose.is_none()
                    & self.rate.is_none()
            }
            fn type_name(&self) -> String {
                "DosageDoseAndRateElement".to_string()
            }
        }
        impl DosageDoseAndRateElement {
            pub fn set_type_(mut self, v: CodeableConcept) -> Self {
                self.type_ = Some(v);
                self
            }
            pub fn set_dose(mut self, v: Quantity) -> Self {
                self.dose = Some(v);
                self
            }
            pub fn set_rate(mut self, v: Quantity) -> Self {
                self.rate = Some(v);
                self
            }
        }
        impl Serialize for DosageDoseAndRateElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("dose", &self.dose)?;
                serialize_struct.serialize_field("rate", &self.rate)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for DosageDoseAndRateElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DosageDoseAndRateElementVisitor;
                impl<'de> Visitor<'de> for DosageDoseAndRateElementVisitor {
                    type Value = DosageDoseAndRateElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<CodeableConcept> = None;
                        let mut dose: Option<Quantity> = None;
                        let mut rate: Option<Quantity> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "dose" => {
                                    dose = Some(mapp.next_value()?);
                                }
                                "rate" => {
                                    rate = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(DosageDoseAndRateElement {
                            id,
                            extension,
                            type_,
                            dose,
                            rate,
                        })
                    }
                }
                deserializer.deserialize_struct("", DosageDoseAndRateElementVisitor)
            }
        }
        impl Executor for DosageDoseAndRateElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "DosageDoseAndRateElement",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "dose" => self.dose.exec(&comp),
                            "rate" => self.rate.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "DosageDoseAndRateElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DosageDoseAndRateElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "DosageDoseAndRateElement",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "type_",
                    &self.type_,
                    "dose",
                    &self.dose,
                    "rate",
                    &&self.rate,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DosageDoseAndRateElement {
            #[inline]
            fn clone(&self) -> DosageDoseAndRateElement {
                DosageDoseAndRateElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    dose: ::core::clone::Clone::clone(&self.dose),
                    rate: ::core::clone::Clone::clone(&self.rate),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DosageDoseAndRateElement {
            #[inline]
            fn default() -> DosageDoseAndRateElement {
                DosageDoseAndRateElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    dose: ::core::default::Default::default(),
                    rate: ::core::default::Default::default(),
                }
            }
        }
        pub struct Duration {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerical value (with implicit precision)
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DecimalDt>,
            /// < | <= | >= | > | ad - how to understand the value
            #[fhir(
                name = "comparator",
                min = "0",
                max = "1",
                summary = true,
                modifier = true
            )]
            pub comparator: Option<CodeDt>,
            /// Unit representation
            #[fhir(
                name = "unit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub unit: Option<StringDt>,
            /// System that defines coded unit form
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// Coded form of the unit
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeDt>,
        }
        impl Element for Duration {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Duration {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.value.is_none()
                    & self.comparator.is_none() & self.unit.is_none()
                    & self.system.is_none() & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "Duration".to_string()
            }
        }
        impl Duration {
            pub fn set_value<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_comparator<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.comparator = Some(v.into());
                self
            }
            pub fn set_unit<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.unit = Some(v.into());
                self
            }
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_code<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.code = Some(v.into());
                self
            }
        }
        impl Serialize for Duration {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("comparator", &self.comparator)?;
                serialize_struct.serialize_field("unit", &self.unit)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Duration {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct DurationVisitor;
                impl<'de> Visitor<'de> for DurationVisitor {
                    type Value = Duration;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DecimalDt> = None;
                        let mut comparator: Option<CodeDt> = None;
                        let mut unit: Option<StringDt> = None;
                        let mut system: Option<UriDt> = None;
                        let mut code: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "comparator" => {
                                    comparator = Some(mapp.next_value()?);
                                }
                                "unit" => {
                                    unit = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Duration {
                            id,
                            extension,
                            value,
                            comparator,
                            unit,
                            system,
                            code,
                        })
                    }
                }
                deserializer.deserialize_struct("", DurationVisitor)
            }
        }
        impl Executor for Duration {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Duration"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "comparator" => self.comparator.exec(&comp),
                            "unit" => self.unit.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Duration",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Duration {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "value",
                    "comparator",
                    "unit",
                    "system",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.value,
                    &self.comparator,
                    &self.unit,
                    &self.system,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Duration",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Duration {
            #[inline]
            fn clone(&self) -> Duration {
                Duration {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                    comparator: ::core::clone::Clone::clone(&self.comparator),
                    unit: ::core::clone::Clone::clone(&self.unit),
                    system: ::core::clone::Clone::clone(&self.system),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Duration {
            #[inline]
            fn default() -> Duration {
                Duration {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    comparator: ::core::default::Default::default(),
                    unit: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinition {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Extensions that cannot be ignored even if unrecognized
            #[fhir(
                name = "modifierExtension",
                min = "0",
                max = "*",
                summary = true,
                modifier = true
            )]
            pub modifier_extension: Option<Vec<Extension>>,
            /// Path of the element in the hierarchy of elements
            #[fhir(
                name = "path",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub path: Option<StringDt>,
            /// xmlAttr | xmlText | typeAttr | cdaText | xhtml
            #[fhir(
                name = "representation",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub representation: Option<Vec<CodeDt>>,
            /// Name for this particular element (in a set of slices)
            #[fhir(
                name = "sliceName",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub slice_name: Option<StringDt>,
            /// If this slice definition constrains an inherited slice definition (or not)
            #[fhir(
                name = "sliceIsConstraining",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub slice_is_constraining: Option<BooleanDt>,
            /// Name for element to display with or prompt for element
            #[fhir(
                name = "label",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub label: Option<StringDt>,
            /// Corresponding codes in terminologies
            #[fhir(
                name = "code",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<Vec<Coding>>,
            /// This element is sliced - slices follow
            #[fhir(
                name = "slicing",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub slicing: Option<ElementDefinitionSlicingElement>,
            /// Concise definition for space-constrained presentation
            #[fhir(
                name = "short",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub short: Option<StringDt>,
            /// Full formal definition as narrative text
            #[fhir(
                name = "definition",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub definition: Option<MarkdownDt>,
            /// Comments about the use of this element
            #[fhir(
                name = "comment",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub comment: Option<MarkdownDt>,
            /// Why this resource has been created
            #[fhir(
                name = "requirements",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub requirements: Option<MarkdownDt>,
            /// Other names
            #[fhir(
                name = "alias",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub alias: Option<Vec<StringDt>>,
            /// Minimum Cardinality
            #[fhir(
                name = "min",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub min: Option<UnsignedIntDt>,
            /// Maximum Cardinality (a number or *)
            #[fhir(
                name = "max",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max: Option<StringDt>,
            #[fhir(
                name = "base",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub base: Option<ElementDefinitionBaseElement>,
            /// Reference to definition of content for the element
            #[fhir(
                name = "contentReference",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub content_reference: Option<UriDt>,
            #[fhir(
                name = "type",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<Vec<ElementDefinitionTypeElement>>,
            /// Specified value if missing from instance
            #[fhir(
                name = "defaultValue",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub default_value: Option<Meta>,
            /// Implicit meaning when this element is missing
            #[fhir(
                name = "meaningWhenMissing",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub meaning_when_missing: Option<MarkdownDt>,
            /// What the order of the elements means
            #[fhir(
                name = "orderMeaning",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub order_meaning: Option<StringDt>,
            /// Value must be exactly this
            #[fhir(
                name = "fixed",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub fixed: Option<Meta>,
            /// Value must have at least these property values
            #[fhir(
                name = "pattern",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = "Uri|CodeableConcept"
            )]
            pub pattern: Option<AnyType>,
            /// Example value (as defined for type)
            #[fhir(
                name = "example",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub example: Option<Vec<ElementDefinitionExampleElement>>,
            /// Minimum Allowed Value (for some types)
            #[fhir(
                name = "minValue",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub min_value: Option<Quantity>,
            /// Maximum Allowed Value (for some types)
            #[fhir(
                name = "maxValue",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max_value: Option<Quantity>,
            /// Max length for string type data
            #[fhir(
                name = "maxLength",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max_length: Option<IntegerDt>,
            /// Reference to invariant about presence
            #[fhir(
                name = "condition",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub condition: Option<Vec<IdDt>>,
            /// Condition that must evaluate to true
            #[fhir(
                name = "constraint",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub constraint: Option<Vec<ElementDefinitionConstraintElement>>,
            /// For primitives, that a value must be present - not replaced by an extension
            #[fhir(
                name = "mustHaveValue",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub must_have_value: Option<BooleanDt>,
            /// Extensions that are allowed to replace a primitive value
            #[fhir(
                name = "valueAlternatives",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value_alternatives: Option<Vec<CanonicalDt>>,
            /// If the element must be supported (discouraged - see obligations)
            #[fhir(
                name = "mustSupport",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub must_support: Option<BooleanDt>,
            /// If this modifies the meaning of other elements
            #[fhir(
                name = "isModifier",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub is_modifier: Option<BooleanDt>,
            /// Reason that this element is marked as a modifier
            #[fhir(
                name = "isModifierReason",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub is_modifier_reason: Option<StringDt>,
            /// Include when _summary = true?
            #[fhir(
                name = "isSummary",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub is_summary: Option<BooleanDt>,
            /// ValueSet details if this is coded
            #[fhir(
                name = "binding",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub binding: Option<ElementDefinitionBindingElement>,
            /// Map element to another set of definitions
            #[fhir(
                name = "mapping",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub mapping: Option<Vec<ElementDefinitionMappingElement>>,
        }
        impl Element for ElementDefinition {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinition {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.modifier_extension.is_none()
                    & self.path.is_none() & self.representation.is_none()
                    & self.slice_name.is_none() & self.slice_is_constraining.is_none()
                    & self.label.is_none() & self.code.is_none() & self.slicing.is_none()
                    & self.short.is_none() & self.definition.is_none()
                    & self.comment.is_none() & self.requirements.is_none()
                    & self.alias.is_none() & self.min.is_none() & self.max.is_none()
                    & self.base.is_none() & self.content_reference.is_none()
                    & self.type_.is_none() & self.default_value.is_none()
                    & self.meaning_when_missing.is_none() & self.order_meaning.is_none()
                    & self.fixed.is_none() & self.pattern.is_none()
                    & self.example.is_none() & self.min_value.is_none()
                    & self.max_value.is_none() & self.max_length.is_none()
                    & self.condition.is_none() & self.constraint.is_none()
                    & self.must_have_value.is_none() & self.value_alternatives.is_none()
                    & self.must_support.is_none() & self.is_modifier.is_none()
                    & self.is_modifier_reason.is_none() & self.is_summary.is_none()
                    & self.binding.is_none() & self.mapping.is_none()
            }
            fn type_name(&self) -> String {
                "ElementDefinition".to_string()
            }
        }
        impl ElementDefinition {
            pub fn set_modifier_extension(mut self, v: Vec<Extension>) -> Self {
                self.modifier_extension = Some(v);
                self
            }
            pub fn add_modifier_extension(mut self, v: Extension) -> Self {
                match self.modifier_extension {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.modifier_extension = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_path<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.path = Some(v.into());
                self
            }
            pub fn set_representation(mut self, v: Vec<CodeDt>) -> Self {
                self.representation = Some(v);
                self
            }
            pub fn add_representation<T: Into<CodeDt>>(mut self, v: T) -> Self {
                match self.representation {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.representation = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_slice_name<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.slice_name = Some(v.into());
                self
            }
            pub fn set_slice_is_constraining<T: Into<BooleanDt>>(
                mut self,
                v: T,
            ) -> Self {
                self.slice_is_constraining = Some(v.into());
                self
            }
            pub fn set_label<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.label = Some(v.into());
                self
            }
            pub fn set_code(mut self, v: Vec<Coding>) -> Self {
                self.code = Some(v);
                self
            }
            pub fn add_code(mut self, v: Coding) -> Self {
                match self.code {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.code = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_slicing(mut self, v: ElementDefinitionSlicingElement) -> Self {
                self.slicing = Some(v);
                self
            }
            pub fn set_short<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.short = Some(v.into());
                self
            }
            pub fn set_definition<T: Into<MarkdownDt>>(mut self, v: T) -> Self {
                self.definition = Some(v.into());
                self
            }
            pub fn set_comment<T: Into<MarkdownDt>>(mut self, v: T) -> Self {
                self.comment = Some(v.into());
                self
            }
            pub fn set_requirements<T: Into<MarkdownDt>>(mut self, v: T) -> Self {
                self.requirements = Some(v.into());
                self
            }
            pub fn set_alias(mut self, v: Vec<StringDt>) -> Self {
                self.alias = Some(v);
                self
            }
            pub fn add_alias<T: Into<StringDt>>(mut self, v: T) -> Self {
                match self.alias {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.alias = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_min<T: Into<UnsignedIntDt>>(mut self, v: T) -> Self {
                self.min = Some(v.into());
                self
            }
            pub fn set_max<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.max = Some(v.into());
                self
            }
            pub fn set_base(mut self, v: ElementDefinitionBaseElement) -> Self {
                self.base = Some(v);
                self
            }
            pub fn set_content_reference<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.content_reference = Some(v.into());
                self
            }
            pub fn set_type_(mut self, v: Vec<ElementDefinitionTypeElement>) -> Self {
                self.type_ = Some(v);
                self
            }
            pub fn add_type_(mut self, v: ElementDefinitionTypeElement) -> Self {
                match self.type_ {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.type_ = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_default_value(mut self, v: Meta) -> Self {
                self.default_value = Some(v);
                self
            }
            pub fn set_meaning_when_missing<T: Into<MarkdownDt>>(
                mut self,
                v: T,
            ) -> Self {
                self.meaning_when_missing = Some(v.into());
                self
            }
            pub fn set_order_meaning<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.order_meaning = Some(v.into());
                self
            }
            pub fn set_fixed(mut self, v: Meta) -> Self {
                self.fixed = Some(v);
                self
            }
            pub fn set_pattern(mut self, v: AnyType) -> Self {
                self.pattern = Some(v);
                self
            }
            pub fn set_example(
                mut self,
                v: Vec<ElementDefinitionExampleElement>,
            ) -> Self {
                self.example = Some(v);
                self
            }
            pub fn add_example(mut self, v: ElementDefinitionExampleElement) -> Self {
                match self.example {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.example = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_min_value(mut self, v: Quantity) -> Self {
                self.min_value = Some(v);
                self
            }
            pub fn set_max_value(mut self, v: Quantity) -> Self {
                self.max_value = Some(v);
                self
            }
            pub fn set_max_length<T: Into<IntegerDt>>(mut self, v: T) -> Self {
                self.max_length = Some(v.into());
                self
            }
            pub fn set_condition(mut self, v: Vec<IdDt>) -> Self {
                self.condition = Some(v);
                self
            }
            pub fn add_condition<T: Into<IdDt>>(mut self, v: T) -> Self {
                match self.condition {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.condition = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_constraint(
                mut self,
                v: Vec<ElementDefinitionConstraintElement>,
            ) -> Self {
                self.constraint = Some(v);
                self
            }
            pub fn add_constraint(
                mut self,
                v: ElementDefinitionConstraintElement,
            ) -> Self {
                match self.constraint {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.constraint = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_must_have_value<T: Into<BooleanDt>>(mut self, v: T) -> Self {
                self.must_have_value = Some(v.into());
                self
            }
            pub fn set_value_alternatives(mut self, v: Vec<CanonicalDt>) -> Self {
                self.value_alternatives = Some(v);
                self
            }
            pub fn add_value_alternatives<T: Into<CanonicalDt>>(mut self, v: T) -> Self {
                match self.value_alternatives {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.value_alternatives = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_must_support<T: Into<BooleanDt>>(mut self, v: T) -> Self {
                self.must_support = Some(v.into());
                self
            }
            pub fn set_is_modifier<T: Into<BooleanDt>>(mut self, v: T) -> Self {
                self.is_modifier = Some(v.into());
                self
            }
            pub fn set_is_modifier_reason<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.is_modifier_reason = Some(v.into());
                self
            }
            pub fn set_is_summary<T: Into<BooleanDt>>(mut self, v: T) -> Self {
                self.is_summary = Some(v.into());
                self
            }
            pub fn set_binding(mut self, v: ElementDefinitionBindingElement) -> Self {
                self.binding = Some(v);
                self
            }
            pub fn set_mapping(
                mut self,
                v: Vec<ElementDefinitionMappingElement>,
            ) -> Self {
                self.mapping = Some(v);
                self
            }
            pub fn add_mapping(mut self, v: ElementDefinitionMappingElement) -> Self {
                match self.mapping {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.mapping = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for ElementDefinition {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct
                    .serialize_field("modifierExtension", &self.modifier_extension)?;
                serialize_struct.serialize_field("path", &self.path)?;
                serialize_struct
                    .serialize_field("representation", &self.representation)?;
                serialize_struct.serialize_field("sliceName", &self.slice_name)?;
                serialize_struct
                    .serialize_field(
                        "sliceIsConstraining",
                        &self.slice_is_constraining,
                    )?;
                serialize_struct.serialize_field("label", &self.label)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_field("slicing", &self.slicing)?;
                serialize_struct.serialize_field("short", &self.short)?;
                serialize_struct.serialize_field("definition", &self.definition)?;
                serialize_struct.serialize_field("comment", &self.comment)?;
                serialize_struct.serialize_field("requirements", &self.requirements)?;
                serialize_struct.serialize_field("alias", &self.alias)?;
                serialize_struct.serialize_field("min", &self.min)?;
                serialize_struct.serialize_field("max", &self.max)?;
                serialize_struct.serialize_field("base", &self.base)?;
                serialize_struct
                    .serialize_field("contentReference", &self.content_reference)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("defaultValue", &self.default_value)?;
                serialize_struct
                    .serialize_field("meaningWhenMissing", &self.meaning_when_missing)?;
                serialize_struct.serialize_field("orderMeaning", &self.order_meaning)?;
                serialize_struct.serialize_field("fixed", &self.fixed)?;
                serialize_struct.serialize_field("pattern", &self.pattern)?;
                serialize_struct.serialize_field("example", &self.example)?;
                serialize_struct.serialize_field("minValue", &self.min_value)?;
                serialize_struct.serialize_field("maxValue", &self.max_value)?;
                serialize_struct.serialize_field("maxLength", &self.max_length)?;
                serialize_struct.serialize_field("condition", &self.condition)?;
                serialize_struct.serialize_field("constraint", &self.constraint)?;
                serialize_struct
                    .serialize_field("mustHaveValue", &self.must_have_value)?;
                serialize_struct
                    .serialize_field("valueAlternatives", &self.value_alternatives)?;
                serialize_struct.serialize_field("mustSupport", &self.must_support)?;
                serialize_struct.serialize_field("isModifier", &self.is_modifier)?;
                serialize_struct
                    .serialize_field("isModifierReason", &self.is_modifier_reason)?;
                serialize_struct.serialize_field("isSummary", &self.is_summary)?;
                serialize_struct.serialize_field("binding", &self.binding)?;
                serialize_struct.serialize_field("mapping", &self.mapping)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinition {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionVisitor;
                impl<'de> Visitor<'de> for ElementDefinitionVisitor {
                    type Value = ElementDefinition;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut modifier_extension: Option<Vec<Extension>> = None;
                        let mut path: Option<StringDt> = None;
                        let mut representation: Option<Vec<CodeDt>> = None;
                        let mut slice_name: Option<StringDt> = None;
                        let mut slice_is_constraining: Option<BooleanDt> = None;
                        let mut label: Option<StringDt> = None;
                        let mut code: Option<Vec<Coding>> = None;
                        let mut slicing: Option<ElementDefinitionSlicingElement> = None;
                        let mut short: Option<StringDt> = None;
                        let mut definition: Option<MarkdownDt> = None;
                        let mut comment: Option<MarkdownDt> = None;
                        let mut requirements: Option<MarkdownDt> = None;
                        let mut alias: Option<Vec<StringDt>> = None;
                        let mut min: Option<UnsignedIntDt> = None;
                        let mut max: Option<StringDt> = None;
                        let mut base: Option<ElementDefinitionBaseElement> = None;
                        let mut content_reference: Option<UriDt> = None;
                        let mut type_: Option<Vec<ElementDefinitionTypeElement>> = None;
                        let mut default_value: Option<Meta> = None;
                        let mut meaning_when_missing: Option<MarkdownDt> = None;
                        let mut order_meaning: Option<StringDt> = None;
                        let mut fixed: Option<Meta> = None;
                        let mut pattern: Option<AnyType> = None;
                        let mut example: Option<Vec<ElementDefinitionExampleElement>> = None;
                        let mut min_value: Option<Quantity> = None;
                        let mut max_value: Option<Quantity> = None;
                        let mut max_length: Option<IntegerDt> = None;
                        let mut condition: Option<Vec<IdDt>> = None;
                        let mut constraint: Option<
                            Vec<ElementDefinitionConstraintElement>,
                        > = None;
                        let mut must_have_value: Option<BooleanDt> = None;
                        let mut value_alternatives: Option<Vec<CanonicalDt>> = None;
                        let mut must_support: Option<BooleanDt> = None;
                        let mut is_modifier: Option<BooleanDt> = None;
                        let mut is_modifier_reason: Option<StringDt> = None;
                        let mut is_summary: Option<BooleanDt> = None;
                        let mut binding: Option<ElementDefinitionBindingElement> = None;
                        let mut mapping: Option<Vec<ElementDefinitionMappingElement>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "modifierExtension" => {
                                    modifier_extension = Some(mapp.next_value()?);
                                }
                                "path" => {
                                    path = Some(mapp.next_value()?);
                                }
                                "representation" => {
                                    representation = Some(mapp.next_value()?);
                                }
                                "sliceName" => {
                                    slice_name = Some(mapp.next_value()?);
                                }
                                "sliceIsConstraining" => {
                                    slice_is_constraining = Some(mapp.next_value()?);
                                }
                                "label" => {
                                    label = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                "slicing" => {
                                    slicing = Some(mapp.next_value()?);
                                }
                                "short" => {
                                    short = Some(mapp.next_value()?);
                                }
                                "definition" => {
                                    definition = Some(mapp.next_value()?);
                                }
                                "comment" => {
                                    comment = Some(mapp.next_value()?);
                                }
                                "requirements" => {
                                    requirements = Some(mapp.next_value()?);
                                }
                                "alias" => {
                                    alias = Some(mapp.next_value()?);
                                }
                                "min" => {
                                    min = Some(mapp.next_value()?);
                                }
                                "max" => {
                                    max = Some(mapp.next_value()?);
                                }
                                "base" => {
                                    base = Some(mapp.next_value()?);
                                }
                                "contentReference" => {
                                    content_reference = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "defaultValue" => {
                                    default_value = Some(mapp.next_value()?);
                                }
                                "meaningWhenMissing" => {
                                    meaning_when_missing = Some(mapp.next_value()?);
                                }
                                "orderMeaning" => {
                                    order_meaning = Some(mapp.next_value()?);
                                }
                                "fixed" => {
                                    fixed = Some(mapp.next_value()?);
                                }
                                k_value if k_value.starts_with("pattern") => {
                                    let ttt = k_value.replace("pattern", "");
                                    pattern = match ttt.as_str() {
                                        "Uri" => Some(AnyType::Uri(mapp.next_value()?)),
                                        "CodeableConcept" => {
                                            Some(AnyType::CodeableConcept(mapp.next_value()?))
                                        }
                                        _ => {
                                            return Err(
                                                FhirError::Message({
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("{0}不在可选类型范围之内", &k_value),
                                                    );
                                                    res
                                                }),
                                            );
                                        }
                                    };
                                }
                                "example" => {
                                    example = Some(mapp.next_value()?);
                                }
                                "minValue" => {
                                    min_value = Some(mapp.next_value()?);
                                }
                                "maxValue" => {
                                    max_value = Some(mapp.next_value()?);
                                }
                                "maxLength" => {
                                    max_length = Some(mapp.next_value()?);
                                }
                                "condition" => {
                                    condition = Some(mapp.next_value()?);
                                }
                                "constraint" => {
                                    constraint = Some(mapp.next_value()?);
                                }
                                "mustHaveValue" => {
                                    must_have_value = Some(mapp.next_value()?);
                                }
                                "valueAlternatives" => {
                                    value_alternatives = Some(mapp.next_value()?);
                                }
                                "mustSupport" => {
                                    must_support = Some(mapp.next_value()?);
                                }
                                "isModifier" => {
                                    is_modifier = Some(mapp.next_value()?);
                                }
                                "isModifierReason" => {
                                    is_modifier_reason = Some(mapp.next_value()?);
                                }
                                "isSummary" => {
                                    is_summary = Some(mapp.next_value()?);
                                }
                                "binding" => {
                                    binding = Some(mapp.next_value()?);
                                }
                                "mapping" => {
                                    mapping = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinition {
                            id,
                            extension,
                            modifier_extension,
                            path,
                            representation,
                            slice_name,
                            slice_is_constraining,
                            label,
                            code,
                            slicing,
                            short,
                            definition,
                            comment,
                            requirements,
                            alias,
                            min,
                            max,
                            base,
                            content_reference,
                            type_,
                            default_value,
                            meaning_when_missing,
                            order_meaning,
                            fixed,
                            pattern,
                            example,
                            min_value,
                            max_value,
                            max_length,
                            condition,
                            constraint,
                            must_have_value,
                            value_alternatives,
                            must_support,
                            is_modifier,
                            is_modifier_reason,
                            is_summary,
                            binding,
                            mapping,
                        })
                    }
                }
                deserializer.deserialize_struct("", ElementDefinitionVisitor)
            }
        }
        impl Executor for ElementDefinition {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "ElementDefinition",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "modifierExtension" => self.modifier_extension.exec(&comp),
                            "path" => self.path.exec(&comp),
                            "representation" => self.representation.exec(&comp),
                            "sliceName" => self.slice_name.exec(&comp),
                            "sliceIsConstraining" => {
                                self.slice_is_constraining.exec(&comp)
                            }
                            "label" => self.label.exec(&comp),
                            "code" => self.code.exec(&comp),
                            "slicing" => self.slicing.exec(&comp),
                            "short" => self.short.exec(&comp),
                            "definition" => self.definition.exec(&comp),
                            "comment" => self.comment.exec(&comp),
                            "requirements" => self.requirements.exec(&comp),
                            "alias" => self.alias.exec(&comp),
                            "min" => self.min.exec(&comp),
                            "max" => self.max.exec(&comp),
                            "base" => self.base.exec(&comp),
                            "contentReference" => self.content_reference.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "defaultValue" => self.default_value.exec(&comp),
                            "meaningWhenMissing" => self.meaning_when_missing.exec(&comp),
                            "orderMeaning" => self.order_meaning.exec(&comp),
                            "fixed" => self.fixed.exec(&comp),
                            "pattern" => self.pattern.exec(&comp),
                            "example" => self.example.exec(&comp),
                            "minValue" => self.min_value.exec(&comp),
                            "maxValue" => self.max_value.exec(&comp),
                            "maxLength" => self.max_length.exec(&comp),
                            "condition" => self.condition.exec(&comp),
                            "constraint" => self.constraint.exec(&comp),
                            "mustHaveValue" => self.must_have_value.exec(&comp),
                            "valueAlternatives" => self.value_alternatives.exec(&comp),
                            "mustSupport" => self.must_support.exec(&comp),
                            "isModifier" => self.is_modifier.exec(&comp),
                            "isModifierReason" => self.is_modifier_reason.exec(&comp),
                            "isSummary" => self.is_summary.exec(&comp),
                            "binding" => self.binding.exec(&comp),
                            "mapping" => self.mapping.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinition",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinition {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "modifier_extension",
                    "path",
                    "representation",
                    "slice_name",
                    "slice_is_constraining",
                    "label",
                    "code",
                    "slicing",
                    "short",
                    "definition",
                    "comment",
                    "requirements",
                    "alias",
                    "min",
                    "max",
                    "base",
                    "content_reference",
                    "type_",
                    "default_value",
                    "meaning_when_missing",
                    "order_meaning",
                    "fixed",
                    "pattern",
                    "example",
                    "min_value",
                    "max_value",
                    "max_length",
                    "condition",
                    "constraint",
                    "must_have_value",
                    "value_alternatives",
                    "must_support",
                    "is_modifier",
                    "is_modifier_reason",
                    "is_summary",
                    "binding",
                    "mapping",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.modifier_extension,
                    &self.path,
                    &self.representation,
                    &self.slice_name,
                    &self.slice_is_constraining,
                    &self.label,
                    &self.code,
                    &self.slicing,
                    &self.short,
                    &self.definition,
                    &self.comment,
                    &self.requirements,
                    &self.alias,
                    &self.min,
                    &self.max,
                    &self.base,
                    &self.content_reference,
                    &self.type_,
                    &self.default_value,
                    &self.meaning_when_missing,
                    &self.order_meaning,
                    &self.fixed,
                    &self.pattern,
                    &self.example,
                    &self.min_value,
                    &self.max_value,
                    &self.max_length,
                    &self.condition,
                    &self.constraint,
                    &self.must_have_value,
                    &self.value_alternatives,
                    &self.must_support,
                    &self.is_modifier,
                    &self.is_modifier_reason,
                    &self.is_summary,
                    &self.binding,
                    &&self.mapping,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ElementDefinition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinition {
            #[inline]
            fn clone(&self) -> ElementDefinition {
                ElementDefinition {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    modifier_extension: ::core::clone::Clone::clone(
                        &self.modifier_extension,
                    ),
                    path: ::core::clone::Clone::clone(&self.path),
                    representation: ::core::clone::Clone::clone(&self.representation),
                    slice_name: ::core::clone::Clone::clone(&self.slice_name),
                    slice_is_constraining: ::core::clone::Clone::clone(
                        &self.slice_is_constraining,
                    ),
                    label: ::core::clone::Clone::clone(&self.label),
                    code: ::core::clone::Clone::clone(&self.code),
                    slicing: ::core::clone::Clone::clone(&self.slicing),
                    short: ::core::clone::Clone::clone(&self.short),
                    definition: ::core::clone::Clone::clone(&self.definition),
                    comment: ::core::clone::Clone::clone(&self.comment),
                    requirements: ::core::clone::Clone::clone(&self.requirements),
                    alias: ::core::clone::Clone::clone(&self.alias),
                    min: ::core::clone::Clone::clone(&self.min),
                    max: ::core::clone::Clone::clone(&self.max),
                    base: ::core::clone::Clone::clone(&self.base),
                    content_reference: ::core::clone::Clone::clone(
                        &self.content_reference,
                    ),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    default_value: ::core::clone::Clone::clone(&self.default_value),
                    meaning_when_missing: ::core::clone::Clone::clone(
                        &self.meaning_when_missing,
                    ),
                    order_meaning: ::core::clone::Clone::clone(&self.order_meaning),
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    pattern: ::core::clone::Clone::clone(&self.pattern),
                    example: ::core::clone::Clone::clone(&self.example),
                    min_value: ::core::clone::Clone::clone(&self.min_value),
                    max_value: ::core::clone::Clone::clone(&self.max_value),
                    max_length: ::core::clone::Clone::clone(&self.max_length),
                    condition: ::core::clone::Clone::clone(&self.condition),
                    constraint: ::core::clone::Clone::clone(&self.constraint),
                    must_have_value: ::core::clone::Clone::clone(&self.must_have_value),
                    value_alternatives: ::core::clone::Clone::clone(
                        &self.value_alternatives,
                    ),
                    must_support: ::core::clone::Clone::clone(&self.must_support),
                    is_modifier: ::core::clone::Clone::clone(&self.is_modifier),
                    is_modifier_reason: ::core::clone::Clone::clone(
                        &self.is_modifier_reason,
                    ),
                    is_summary: ::core::clone::Clone::clone(&self.is_summary),
                    binding: ::core::clone::Clone::clone(&self.binding),
                    mapping: ::core::clone::Clone::clone(&self.mapping),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinition {
            #[inline]
            fn default() -> ElementDefinition {
                ElementDefinition {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    modifier_extension: ::core::default::Default::default(),
                    path: ::core::default::Default::default(),
                    representation: ::core::default::Default::default(),
                    slice_name: ::core::default::Default::default(),
                    slice_is_constraining: ::core::default::Default::default(),
                    label: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                    slicing: ::core::default::Default::default(),
                    short: ::core::default::Default::default(),
                    definition: ::core::default::Default::default(),
                    comment: ::core::default::Default::default(),
                    requirements: ::core::default::Default::default(),
                    alias: ::core::default::Default::default(),
                    min: ::core::default::Default::default(),
                    max: ::core::default::Default::default(),
                    base: ::core::default::Default::default(),
                    content_reference: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    default_value: ::core::default::Default::default(),
                    meaning_when_missing: ::core::default::Default::default(),
                    order_meaning: ::core::default::Default::default(),
                    fixed: ::core::default::Default::default(),
                    pattern: ::core::default::Default::default(),
                    example: ::core::default::Default::default(),
                    min_value: ::core::default::Default::default(),
                    max_value: ::core::default::Default::default(),
                    max_length: ::core::default::Default::default(),
                    condition: ::core::default::Default::default(),
                    constraint: ::core::default::Default::default(),
                    must_have_value: ::core::default::Default::default(),
                    value_alternatives: ::core::default::Default::default(),
                    must_support: ::core::default::Default::default(),
                    is_modifier: ::core::default::Default::default(),
                    is_modifier_reason: ::core::default::Default::default(),
                    is_summary: ::core::default::Default::default(),
                    binding: ::core::default::Default::default(),
                    mapping: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionBaseElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Path that identifies the base element
            #[fhir(
                name = "path",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub path: Option<StringDt>,
            /// Min cardinality of the base element
            #[fhir(
                name = "min",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub min: Option<UnsignedIntDt>,
            /// Max cardinality of the base element
            #[fhir(
                name = "max",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max: Option<StringDt>,
        }
        impl Element for ElementDefinitionBaseElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionBaseElement {
            fn type_name(&self) -> String {
                "ElementDefinitionBaseElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionBaseElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("path", &self.path)?;
                serialize_struct.serialize_field("min", &self.min)?;
                serialize_struct.serialize_field("max", &self.max)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionBaseElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionBaseElementVisitor;
                impl<'de> Visitor<'de> for ElementDefinitionBaseElementVisitor {
                    type Value = ElementDefinitionBaseElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut path: Option<StringDt> = None;
                        let mut min: Option<UnsignedIntDt> = None;
                        let mut max: Option<StringDt> = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "path" => {
                                    path = Some(mapp.next_value()?);
                                }
                                "min" => {
                                    min = Some(mapp.next_value()?);
                                }
                                "max" => {
                                    max = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionBaseElement {
                            id,
                            extension,
                            path,
                            min,
                            max,
                        })
                    }
                }
                deserializer.deserialize_struct("", ElementDefinitionBaseElementVisitor)
            }
        }
        impl Executor for ElementDefinitionBaseElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "path" => self.path.exec(&comp),
                            "min" => self.min.exec(&comp),
                            "max" => self.max.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionBaseElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionBaseElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "ElementDefinitionBaseElement",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "path",
                    &self.path,
                    "min",
                    &self.min,
                    "max",
                    &&self.max,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionBaseElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionBaseElement {
                ElementDefinitionBaseElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    path: ::core::clone::Clone::clone(&self.path),
                    min: ::core::clone::Clone::clone(&self.min),
                    max: ::core::clone::Clone::clone(&self.max),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionBaseElement {
            #[inline]
            fn default() -> ElementDefinitionBaseElement {
                ElementDefinitionBaseElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    path: ::core::default::Default::default(),
                    min: ::core::default::Default::default(),
                    max: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionSlicingElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Element values that are used to distinguish the slices
            #[fhir(
                name = "discriminator",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub discriminator: Option<Vec<ElementDefinitionSlicingDiscriminatorElement>>,
            /// Text description of how slicing works (or not)
            #[fhir(
                name = "description",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub description: Option<StringDt>,
            /// If elements must be in same order as slices
            #[fhir(
                name = "ordered",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub ordered: Option<BooleanDt>,
            /// closed | open | openAtEnd
            #[fhir(
                name = "rules",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub rules: Option<CodeDt>,
        }
        impl Element for ElementDefinitionSlicingElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionSlicingElement {
            fn type_name(&self) -> String {
                "ElementDefinitionSlicingElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionSlicingElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("discriminator", &self.discriminator)?;
                serialize_struct.serialize_field("description", &self.description)?;
                serialize_struct.serialize_field("ordered", &self.ordered)?;
                serialize_struct.serialize_field("rules", &self.rules)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionSlicingElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionSlicingElementVisitor;
                impl<'de> Visitor<'de> for ElementDefinitionSlicingElementVisitor {
                    type Value = ElementDefinitionSlicingElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut discriminator: Option<
                            Vec<ElementDefinitionSlicingDiscriminatorElement>,
                        > = None;
                        let mut description: Option<StringDt> = None;
                        let mut ordered: Option<BooleanDt> = None;
                        let mut rules: Option<CodeDt> = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "discriminator" => {
                                    discriminator = Some(mapp.next_value()?);
                                }
                                "description" => {
                                    description = Some(mapp.next_value()?);
                                }
                                "ordered" => {
                                    ordered = Some(mapp.next_value()?);
                                }
                                "rules" => {
                                    rules = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionSlicingElement {
                            id,
                            extension,
                            discriminator,
                            description,
                            ordered,
                            rules,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", ElementDefinitionSlicingElementVisitor)
            }
        }
        impl Executor for ElementDefinitionSlicingElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "discriminator" => self.discriminator.exec(&comp),
                            "description" => self.description.exec(&comp),
                            "ordered" => self.ordered.exec(&comp),
                            "rules" => self.rules.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionSlicingElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionSlicingElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "discriminator",
                    "description",
                    "ordered",
                    "rules",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.discriminator,
                    &self.description,
                    &self.ordered,
                    &&self.rules,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ElementDefinitionSlicingElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionSlicingElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionSlicingElement {
                ElementDefinitionSlicingElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    discriminator: ::core::clone::Clone::clone(&self.discriminator),
                    description: ::core::clone::Clone::clone(&self.description),
                    ordered: ::core::clone::Clone::clone(&self.ordered),
                    rules: ::core::clone::Clone::clone(&self.rules),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionSlicingElement {
            #[inline]
            fn default() -> ElementDefinitionSlicingElement {
                ElementDefinitionSlicingElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    discriminator: ::core::default::Default::default(),
                    description: ::core::default::Default::default(),
                    ordered: ::core::default::Default::default(),
                    rules: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionSlicingDiscriminatorElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// value | exists | type | profile | position
            #[fhir(
                name = "type",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeDt>,
            /// Path to element value
            #[fhir(
                name = "path",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub path: Option<StringDt>,
        }
        impl Element for ElementDefinitionSlicingDiscriminatorElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionSlicingDiscriminatorElement {
            fn type_name(&self) -> String {
                "ElementDefinitionSlicingDiscriminatorElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionSlicingDiscriminatorElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("path", &self.path)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionSlicingDiscriminatorElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionSlicingDiscriminatorElementVisitor;
                impl<'de> Visitor<'de>
                for ElementDefinitionSlicingDiscriminatorElementVisitor {
                    type Value = ElementDefinitionSlicingDiscriminatorElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<CodeDt> = None;
                        let mut path: Option<StringDt> = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "path" => {
                                    path = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionSlicingDiscriminatorElement {
                            id,
                            extension,
                            type_,
                            path,
                        })
                    }
                }
                deserializer
                    .deserialize_struct(
                        "",
                        ElementDefinitionSlicingDiscriminatorElementVisitor,
                    )
            }
        }
        impl Executor for ElementDefinitionSlicingDiscriminatorElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "path" => self.path.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionSlicingDiscriminatorElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionSlicingDiscriminatorElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ElementDefinitionSlicingDiscriminatorElement",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "type_",
                    &self.type_,
                    "path",
                    &&self.path,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionSlicingDiscriminatorElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionSlicingDiscriminatorElement {
                ElementDefinitionSlicingDiscriminatorElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    path: ::core::clone::Clone::clone(&self.path),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionSlicingDiscriminatorElement {
            #[inline]
            fn default() -> ElementDefinitionSlicingDiscriminatorElement {
                ElementDefinitionSlicingDiscriminatorElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    path: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionMappingElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Reference to mapping declaration
            #[fhir(
                name = "identity",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub identity: Option<IdDt>,
            /// Computable language of mapping
            #[fhir(
                name = "language",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub language: Option<CodeDt>,
            /// Details of the mapping
            #[fhir(
                name = "map",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub map: Option<StringDt>,
            /// Comments about the mapping or its use
            #[fhir(
                name = "comment",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub comment: Option<MarkdownDt>,
        }
        impl Element for ElementDefinitionMappingElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionMappingElement {
            fn type_name(&self) -> String {
                "ElementDefinitionMappingElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionMappingElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("identity", &self.identity)?;
                serialize_struct.serialize_field("language", &self.language)?;
                serialize_struct.serialize_field("map", &self.map)?;
                serialize_struct.serialize_field("comment", &self.comment)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionMappingElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionMappingElementVisitor;
                impl<'de> Visitor<'de> for ElementDefinitionMappingElementVisitor {
                    type Value = ElementDefinitionMappingElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut identity: Option<IdDt> = None;
                        let mut language: Option<CodeDt> = None;
                        let mut map: Option<StringDt> = None;
                        let mut comment: Option<MarkdownDt> = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "identity" => {
                                    identity = Some(mapp.next_value()?);
                                }
                                "language" => {
                                    language = Some(mapp.next_value()?);
                                }
                                "map" => {
                                    map = Some(mapp.next_value()?);
                                }
                                "comment" => {
                                    comment = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionMappingElement {
                            id,
                            extension,
                            identity,
                            language,
                            map,
                            comment,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", ElementDefinitionMappingElementVisitor)
            }
        }
        impl Executor for ElementDefinitionMappingElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "identity" => self.identity.exec(&comp),
                            "language" => self.language.exec(&comp),
                            "map" => self.map.exec(&comp),
                            "comment" => self.comment.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionMappingElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionMappingElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "identity",
                    "language",
                    "map",
                    "comment",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.identity,
                    &self.language,
                    &self.map,
                    &&self.comment,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ElementDefinitionMappingElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionMappingElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionMappingElement {
                ElementDefinitionMappingElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    identity: ::core::clone::Clone::clone(&self.identity),
                    language: ::core::clone::Clone::clone(&self.language),
                    map: ::core::clone::Clone::clone(&self.map),
                    comment: ::core::clone::Clone::clone(&self.comment),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionMappingElement {
            #[inline]
            fn default() -> ElementDefinitionMappingElement {
                ElementDefinitionMappingElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    identity: ::core::default::Default::default(),
                    language: ::core::default::Default::default(),
                    map: ::core::default::Default::default(),
                    comment: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionTypeElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Data type or Resource (reference to definition)
            #[fhir(
                name = "code",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<UriDt>,
            /// Profiles (StructureDefinition or IG) - one must apply
            #[fhir(
                name = "profile",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub profile: Option<Vec<CanonicalDt>>,
            /// Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply
            #[fhir(
                name = "targetProfile",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub target_profile: Option<Vec<CanonicalDt>>,
            /// contained | referenced | bundled - how aggregated
            #[fhir(
                name = "aggregation",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub aggregation: Option<Vec<CodeDt>>,
            /// either | independent | specific
            #[fhir(
                name = "versioning",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub versioning: Option<CodeDt>,
        }
        impl Element for ElementDefinitionTypeElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionTypeElement {
            fn type_name(&self) -> String {
                "ElementDefinitionTypeElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionTypeElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_field("profile", &self.profile)?;
                serialize_struct.serialize_field("targetProfile", &self.target_profile)?;
                serialize_struct.serialize_field("aggregation", &self.aggregation)?;
                serialize_struct.serialize_field("versioning", &self.versioning)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionTypeElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionTypeElementVisitor;
                impl<'de> Visitor<'de> for ElementDefinitionTypeElementVisitor {
                    type Value = ElementDefinitionTypeElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut code: Option<UriDt> = None;
                        let mut profile: Option<Vec<CanonicalDt>> = None;
                        let mut target_profile: Option<Vec<CanonicalDt>> = None;
                        let mut aggregation: Option<Vec<CodeDt>> = None;
                        let mut versioning: Option<CodeDt> = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                "profile" => {
                                    profile = Some(mapp.next_value()?);
                                }
                                "targetProfile" => {
                                    target_profile = Some(mapp.next_value()?);
                                }
                                "aggregation" => {
                                    aggregation = Some(mapp.next_value()?);
                                }
                                "versioning" => {
                                    versioning = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionTypeElement {
                            id,
                            extension,
                            code,
                            profile,
                            target_profile,
                            aggregation,
                            versioning,
                        })
                    }
                }
                deserializer.deserialize_struct("", ElementDefinitionTypeElementVisitor)
            }
        }
        impl Executor for ElementDefinitionTypeElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "code" => self.code.exec(&comp),
                            "profile" => self.profile.exec(&comp),
                            "targetProfile" => self.target_profile.exec(&comp),
                            "aggregation" => self.aggregation.exec(&comp),
                            "versioning" => self.versioning.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionTypeElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionTypeElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "code",
                    "profile",
                    "target_profile",
                    "aggregation",
                    "versioning",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.code,
                    &self.profile,
                    &self.target_profile,
                    &self.aggregation,
                    &&self.versioning,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ElementDefinitionTypeElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionTypeElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionTypeElement {
                ElementDefinitionTypeElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    code: ::core::clone::Clone::clone(&self.code),
                    profile: ::core::clone::Clone::clone(&self.profile),
                    target_profile: ::core::clone::Clone::clone(&self.target_profile),
                    aggregation: ::core::clone::Clone::clone(&self.aggregation),
                    versioning: ::core::clone::Clone::clone(&self.versioning),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionTypeElement {
            #[inline]
            fn default() -> ElementDefinitionTypeElement {
                ElementDefinitionTypeElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                    profile: ::core::default::Default::default(),
                    target_profile: ::core::default::Default::default(),
                    aggregation: ::core::default::Default::default(),
                    versioning: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionBindingElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// required | extensible | preferred | example
            #[fhir(
                name = "strength",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub strength: Option<CodeDt>,
            /// Intended use of codes in the bound value set
            #[fhir(
                name = "description",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub description: Option<MarkdownDt>,
            /// Source of value set
            #[fhir(
                name = "valueSet",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value_set: Option<CanonicalDt>,
            /// Additional Bindings - more rules about the binding
            #[fhir(
                name = "additional",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub additional: Option<Vec<ElementDefinitionBindingAdditionalElement>>,
        }
        impl Element for ElementDefinitionBindingElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionBindingElement {
            fn type_name(&self) -> String {
                "ElementDefinitionBindingElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionBindingElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("strength", &self.strength)?;
                serialize_struct.serialize_field("description", &self.description)?;
                serialize_struct.serialize_field("valueSet", &self.value_set)?;
                serialize_struct.serialize_field("additional", &self.additional)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionBindingElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionBindingElementVisitor;
                impl<'de> Visitor<'de> for ElementDefinitionBindingElementVisitor {
                    type Value = ElementDefinitionBindingElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut strength: Option<CodeDt> = None;
                        let mut description: Option<MarkdownDt> = None;
                        let mut value_set: Option<CanonicalDt> = None;
                        let mut additional: Option<
                            Vec<ElementDefinitionBindingAdditionalElement>,
                        > = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "strength" => {
                                    strength = Some(mapp.next_value()?);
                                }
                                "description" => {
                                    description = Some(mapp.next_value()?);
                                }
                                "valueSet" => {
                                    value_set = Some(mapp.next_value()?);
                                }
                                "additional" => {
                                    additional = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionBindingElement {
                            id,
                            extension,
                            strength,
                            description,
                            value_set,
                            additional,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", ElementDefinitionBindingElementVisitor)
            }
        }
        impl Executor for ElementDefinitionBindingElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "strength" => self.strength.exec(&comp),
                            "description" => self.description.exec(&comp),
                            "valueSet" => self.value_set.exec(&comp),
                            "additional" => self.additional.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionBindingElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionBindingElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "strength",
                    "description",
                    "value_set",
                    "additional",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.strength,
                    &self.description,
                    &self.value_set,
                    &&self.additional,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ElementDefinitionBindingElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionBindingElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionBindingElement {
                ElementDefinitionBindingElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    strength: ::core::clone::Clone::clone(&self.strength),
                    description: ::core::clone::Clone::clone(&self.description),
                    value_set: ::core::clone::Clone::clone(&self.value_set),
                    additional: ::core::clone::Clone::clone(&self.additional),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionBindingElement {
            #[inline]
            fn default() -> ElementDefinitionBindingElement {
                ElementDefinitionBindingElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    strength: ::core::default::Default::default(),
                    description: ::core::default::Default::default(),
                    value_set: ::core::default::Default::default(),
                    additional: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionBindingAdditionalElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// maximum | minimum | required | extensible | candidate | current | preferred | ui | starter | component
            #[fhir(
                name = "purpose",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub purpose: Option<CodeDt>,
            /// The value set for the additional binding
            #[fhir(
                name = "valueSet",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value_set: Option<CanonicalDt>,
            /// Documentation of the purpose of use of the binding
            #[fhir(
                name = "documentation",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub documentation: Option<MarkdownDt>,
            /// Concise documentation - for summary tables
            #[fhir(
                name = "shortDoco",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub short_doco: Option<StringDt>,
            /// Qualifies the usage - jurisdiction, gender, workflow status etc.
            #[fhir(
                name = "usage",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub usage: Option<Vec<UsageContext>>,
            /// Whether binding can applies to all repeats, or just one
            #[fhir(
                name = "any",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub any: Option<BooleanDt>,
        }
        impl Element for ElementDefinitionBindingAdditionalElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionBindingAdditionalElement {
            fn type_name(&self) -> String {
                "ElementDefinitionBindingAdditionalElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionBindingAdditionalElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("purpose", &self.purpose)?;
                serialize_struct.serialize_field("valueSet", &self.value_set)?;
                serialize_struct.serialize_field("documentation", &self.documentation)?;
                serialize_struct.serialize_field("shortDoco", &self.short_doco)?;
                serialize_struct.serialize_field("usage", &self.usage)?;
                serialize_struct.serialize_field("any", &self.any)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionBindingAdditionalElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionBindingAdditionalElementVisitor;
                impl<'de> Visitor<'de>
                for ElementDefinitionBindingAdditionalElementVisitor {
                    type Value = ElementDefinitionBindingAdditionalElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut purpose: Option<CodeDt> = None;
                        let mut value_set: Option<CanonicalDt> = None;
                        let mut documentation: Option<MarkdownDt> = None;
                        let mut short_doco: Option<StringDt> = None;
                        let mut usage: Option<Vec<UsageContext>> = None;
                        let mut any: Option<BooleanDt> = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "purpose" => {
                                    purpose = Some(mapp.next_value()?);
                                }
                                "valueSet" => {
                                    value_set = Some(mapp.next_value()?);
                                }
                                "documentation" => {
                                    documentation = Some(mapp.next_value()?);
                                }
                                "shortDoco" => {
                                    short_doco = Some(mapp.next_value()?);
                                }
                                "usage" => {
                                    usage = Some(mapp.next_value()?);
                                }
                                "any" => {
                                    any = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionBindingAdditionalElement {
                            id,
                            extension,
                            purpose,
                            value_set,
                            documentation,
                            short_doco,
                            usage,
                            any,
                        })
                    }
                }
                deserializer
                    .deserialize_struct(
                        "",
                        ElementDefinitionBindingAdditionalElementVisitor,
                    )
            }
        }
        impl Executor for ElementDefinitionBindingAdditionalElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "purpose" => self.purpose.exec(&comp),
                            "valueSet" => self.value_set.exec(&comp),
                            "documentation" => self.documentation.exec(&comp),
                            "shortDoco" => self.short_doco.exec(&comp),
                            "usage" => self.usage.exec(&comp),
                            "any" => self.any.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionBindingAdditionalElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionBindingAdditionalElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "purpose",
                    "value_set",
                    "documentation",
                    "short_doco",
                    "usage",
                    "any",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.purpose,
                    &self.value_set,
                    &self.documentation,
                    &self.short_doco,
                    &self.usage,
                    &&self.any,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ElementDefinitionBindingAdditionalElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionBindingAdditionalElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionBindingAdditionalElement {
                ElementDefinitionBindingAdditionalElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    purpose: ::core::clone::Clone::clone(&self.purpose),
                    value_set: ::core::clone::Clone::clone(&self.value_set),
                    documentation: ::core::clone::Clone::clone(&self.documentation),
                    short_doco: ::core::clone::Clone::clone(&self.short_doco),
                    usage: ::core::clone::Clone::clone(&self.usage),
                    any: ::core::clone::Clone::clone(&self.any),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionBindingAdditionalElement {
            #[inline]
            fn default() -> ElementDefinitionBindingAdditionalElement {
                ElementDefinitionBindingAdditionalElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    purpose: ::core::default::Default::default(),
                    value_set: ::core::default::Default::default(),
                    documentation: ::core::default::Default::default(),
                    short_doco: ::core::default::Default::default(),
                    usage: ::core::default::Default::default(),
                    any: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionExampleElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Describes the purpose of this example
            #[fhir(
                name = "label",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub label: Option<StringDt>,
            /// Value of Example (one of allowed types)
            #[fhir(
                name = "value",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = "Uri|String"
            )]
            pub value: Option<AnyType>,
        }
        impl Element for ElementDefinitionExampleElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionExampleElement {
            fn type_name(&self) -> String {
                "ElementDefinitionExampleElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionExampleElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("label", &self.label)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionExampleElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionExampleElementVisitor;
                impl<'de> Visitor<'de> for ElementDefinitionExampleElementVisitor {
                    type Value = ElementDefinitionExampleElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut label: Option<StringDt> = None;
                        let mut value: Option<AnyType> = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "label" => {
                                    label = Some(mapp.next_value()?);
                                }
                                k_value if k_value.starts_with("value") => {
                                    let ttt = k_value.replace("value", "");
                                    value = match ttt.as_str() {
                                        "Uri" => Some(AnyType::Uri(mapp.next_value()?)),
                                        "String" => Some(AnyType::String(mapp.next_value()?)),
                                        _ => {
                                            return Err(
                                                FhirError::Message({
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("{0}不在可选类型范围之内", &k_value),
                                                    );
                                                    res
                                                }),
                                            );
                                        }
                                    };
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionExampleElement {
                            id,
                            extension,
                            label,
                            value,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", ElementDefinitionExampleElementVisitor)
            }
        }
        impl Executor for ElementDefinitionExampleElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "label" => self.label.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionExampleElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionExampleElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ElementDefinitionExampleElement",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "label",
                    &self.label,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionExampleElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionExampleElement {
                ElementDefinitionExampleElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    label: ::core::clone::Clone::clone(&self.label),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionExampleElement {
            #[inline]
            fn default() -> ElementDefinitionExampleElement {
                ElementDefinitionExampleElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    label: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        pub struct ElementDefinitionConstraintElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Target of 'condition' reference above
            #[fhir(
                name = "key",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub key: Option<IdDt>,
            /// Why this constraint is necessary or appropriate
            #[fhir(
                name = "requirements",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub requirements: Option<MarkdownDt>,
            /// error | warning
            #[fhir(
                name = "severity",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub severity: Option<CodeDt>,
            /// Suppress warning or hint in profile
            #[fhir(
                name = "suppress",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub suppress: Option<BooleanDt>,
            /// Human description of constraint
            #[fhir(
                name = "human",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub human: Option<StringDt>,
            /// FHIRPath expression of constraint
            #[fhir(
                name = "expression",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub expression: Option<StringDt>,
            /// Reference to original source of constraint
            #[fhir(
                name = "source",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub source: Option<CanonicalDt>,
        }
        impl Element for ElementDefinitionConstraintElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ElementDefinitionConstraintElement {
            fn type_name(&self) -> String {
                "ElementDefinitionConstraintElement".to_string()
            }
        }
        impl Serialize for ElementDefinitionConstraintElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("key", &self.key)?;
                serialize_struct.serialize_field("requirements", &self.requirements)?;
                serialize_struct.serialize_field("severity", &self.severity)?;
                serialize_struct.serialize_field("suppress", &self.suppress)?;
                serialize_struct.serialize_field("human", &self.human)?;
                serialize_struct.serialize_field("expression", &self.expression)?;
                serialize_struct.serialize_field("source", &self.source)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ElementDefinitionConstraintElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ElementDefinitionConstraintElementVisitor;
                impl<'de> Visitor<'de> for ElementDefinitionConstraintElementVisitor {
                    type Value = ElementDefinitionConstraintElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut key: Option<IdDt> = None;
                        let mut requirements: Option<MarkdownDt> = None;
                        let mut severity: Option<CodeDt> = None;
                        let mut suppress: Option<BooleanDt> = None;
                        let mut human: Option<StringDt> = None;
                        let mut expression: Option<StringDt> = None;
                        let mut source: Option<CanonicalDt> = None;
                        while let Some(keys) = mapp.next_key()? {
                            match keys.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "key" => {
                                    key = Some(mapp.next_value()?);
                                }
                                "requirements" => {
                                    requirements = Some(mapp.next_value()?);
                                }
                                "severity" => {
                                    severity = Some(mapp.next_value()?);
                                }
                                "suppress" => {
                                    suppress = Some(mapp.next_value()?);
                                }
                                "human" => {
                                    human = Some(mapp.next_value()?);
                                }
                                "expression" => {
                                    expression = Some(mapp.next_value()?);
                                }
                                "source" => {
                                    source = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", keys),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ElementDefinitionConstraintElement {
                            id,
                            extension,
                            key,
                            requirements,
                            severity,
                            suppress,
                            human,
                            expression,
                            source,
                        })
                    }
                }
                deserializer
                    .deserialize_struct("", ElementDefinitionConstraintElementVisitor)
            }
        }
        impl Executor for ElementDefinitionConstraintElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "key" => self.key.exec(&comp),
                            "requirements" => self.requirements.exec(&comp),
                            "severity" => self.severity.exec(&comp),
                            "suppress" => self.suppress.exec(&comp),
                            "human" => self.human.exec(&comp),
                            "expression" => self.expression.exec(&comp),
                            "source" => self.source.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ElementDefinitionConstraintElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElementDefinitionConstraintElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "key",
                    "requirements",
                    "severity",
                    "suppress",
                    "human",
                    "expression",
                    "source",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.key,
                    &self.requirements,
                    &self.severity,
                    &self.suppress,
                    &self.human,
                    &self.expression,
                    &&self.source,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ElementDefinitionConstraintElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ElementDefinitionConstraintElement {
            #[inline]
            fn clone(&self) -> ElementDefinitionConstraintElement {
                ElementDefinitionConstraintElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    key: ::core::clone::Clone::clone(&self.key),
                    requirements: ::core::clone::Clone::clone(&self.requirements),
                    severity: ::core::clone::Clone::clone(&self.severity),
                    suppress: ::core::clone::Clone::clone(&self.suppress),
                    human: ::core::clone::Clone::clone(&self.human),
                    expression: ::core::clone::Clone::clone(&self.expression),
                    source: ::core::clone::Clone::clone(&self.source),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ElementDefinitionConstraintElement {
            #[inline]
            fn default() -> ElementDefinitionConstraintElement {
                ElementDefinitionConstraintElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    key: ::core::default::Default::default(),
                    requirements: ::core::default::Default::default(),
                    severity: ::core::default::Default::default(),
                    suppress: ::core::default::Default::default(),
                    human: ::core::default::Default::default(),
                    expression: ::core::default::Default::default(),
                    source: ::core::default::Default::default(),
                }
            }
        }
        pub struct Expression {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Natural language description of the condition
            #[fhir(
                name = "description",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub description: Option<StringDt>,
            /// Short name assigned to expression for reuse
            #[fhir(
                name = "name",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub name: Option<CodeDt>,
            /// text/cql | text/fhirpath | application/x-fhir-query | etc.
            #[fhir(
                name = "language",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub language: Option<CodeDt>,
            /// Expression in specified language
            #[fhir(
                name = "expression",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub expression: Option<StringDt>,
            /// Where the expression is found
            #[fhir(
                name = "reference",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub reference: Option<UriDt>,
        }
        impl Element for Expression {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Expression {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.description.is_none()
                    & self.name.is_none() & self.language.is_none()
                    & self.expression.is_none() & self.reference.is_none()
            }
            fn type_name(&self) -> String {
                "Expression".to_string()
            }
        }
        impl Expression {
            pub fn set_description<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.description = Some(v.into());
                self
            }
            pub fn set_name<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.name = Some(v.into());
                self
            }
            pub fn set_language<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.language = Some(v.into());
                self
            }
            pub fn set_expression<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.expression = Some(v.into());
                self
            }
            pub fn set_reference<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.reference = Some(v.into());
                self
            }
        }
        impl Serialize for Expression {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("description", &self.description)?;
                serialize_struct.serialize_field("name", &self.name)?;
                serialize_struct.serialize_field("language", &self.language)?;
                serialize_struct.serialize_field("expression", &self.expression)?;
                serialize_struct.serialize_field("reference", &self.reference)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Expression {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ExpressionVisitor;
                impl<'de> Visitor<'de> for ExpressionVisitor {
                    type Value = Expression;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut description: Option<StringDt> = None;
                        let mut name: Option<CodeDt> = None;
                        let mut language: Option<CodeDt> = None;
                        let mut expression: Option<StringDt> = None;
                        let mut reference: Option<UriDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "description" => {
                                    description = Some(mapp.next_value()?);
                                }
                                "name" => {
                                    name = Some(mapp.next_value()?);
                                }
                                "language" => {
                                    language = Some(mapp.next_value()?);
                                }
                                "expression" => {
                                    expression = Some(mapp.next_value()?);
                                }
                                "reference" => {
                                    reference = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Expression {
                            id,
                            extension,
                            description,
                            name,
                            language,
                            expression,
                            reference,
                        })
                    }
                }
                deserializer.deserialize_struct("", ExpressionVisitor)
            }
        }
        impl Executor for Expression {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Expression"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "description" => self.description.exec(&comp),
                            "name" => self.name.exec(&comp),
                            "language" => self.language.exec(&comp),
                            "expression" => self.expression.exec(&comp),
                            "reference" => self.reference.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Expression",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Expression {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "description",
                    "name",
                    "language",
                    "expression",
                    "reference",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.description,
                    &self.name,
                    &self.language,
                    &self.expression,
                    &&self.reference,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Expression",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Expression {
            #[inline]
            fn clone(&self) -> Expression {
                Expression {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    description: ::core::clone::Clone::clone(&self.description),
                    name: ::core::clone::Clone::clone(&self.name),
                    language: ::core::clone::Clone::clone(&self.language),
                    expression: ::core::clone::Clone::clone(&self.expression),
                    reference: ::core::clone::Clone::clone(&self.reference),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Expression {
            #[inline]
            fn default() -> Expression {
                Expression {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    description: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    language: ::core::default::Default::default(),
                    expression: ::core::default::Default::default(),
                    reference: ::core::default::Default::default(),
                }
            }
        }
        pub struct ExtendedContactDetail {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// The type of contact
            #[fhir(
                name = "purpose",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub purpose: Option<CodeableConcept>,
            /// Name of an individual to contact
            #[fhir(
                name = "name",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub name: Option<Vec<HumanName>>,
            /// Contact details (e.g.phone/fax/url)
            #[fhir(
                name = "telecom",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub telecom: Option<Vec<ContactPoint>>,
            /// Address for the contact
            #[fhir(
                name = "address",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub address: Option<Address>,
            /// This contact detail is handled/monitored by a specific organization
            #[fhir(
                name = "organization",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub organization: Option<Reference>,
            /// Period that this contact was valid for usage
            #[fhir(
                name = "period",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period: Option<Period>,
        }
        impl Element for ExtendedContactDetail {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ExtendedContactDetail {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.purpose.is_none() & self.name.is_none()
                    & self.telecom.is_none() & self.address.is_none()
                    & self.organization.is_none() & self.period.is_none()
            }
            fn type_name(&self) -> String {
                "ExtendedContactDetail".to_string()
            }
        }
        impl ExtendedContactDetail {
            pub fn set_purpose(mut self, v: CodeableConcept) -> Self {
                self.purpose = Some(v);
                self
            }
            pub fn set_name(mut self, v: Vec<HumanName>) -> Self {
                self.name = Some(v);
                self
            }
            pub fn add_name(mut self, v: HumanName) -> Self {
                match self.name {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.name = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_telecom(mut self, v: Vec<ContactPoint>) -> Self {
                self.telecom = Some(v);
                self
            }
            pub fn add_telecom(mut self, v: ContactPoint) -> Self {
                match self.telecom {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.telecom = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_address(mut self, v: Address) -> Self {
                self.address = Some(v);
                self
            }
            pub fn set_organization(mut self, v: Reference) -> Self {
                self.organization = Some(v);
                self
            }
            pub fn set_period(mut self, v: Period) -> Self {
                self.period = Some(v);
                self
            }
        }
        impl Serialize for ExtendedContactDetail {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("purpose", &self.purpose)?;
                serialize_struct.serialize_field("name", &self.name)?;
                serialize_struct.serialize_field("telecom", &self.telecom)?;
                serialize_struct.serialize_field("address", &self.address)?;
                serialize_struct.serialize_field("organization", &self.organization)?;
                serialize_struct.serialize_field("period", &self.period)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ExtendedContactDetail {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ExtendedContactDetailVisitor;
                impl<'de> Visitor<'de> for ExtendedContactDetailVisitor {
                    type Value = ExtendedContactDetail;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut purpose: Option<CodeableConcept> = None;
                        let mut name: Option<Vec<HumanName>> = None;
                        let mut telecom: Option<Vec<ContactPoint>> = None;
                        let mut address: Option<Address> = None;
                        let mut organization: Option<Reference> = None;
                        let mut period: Option<Period> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "purpose" => {
                                    purpose = Some(mapp.next_value()?);
                                }
                                "name" => {
                                    name = Some(mapp.next_value()?);
                                }
                                "telecom" => {
                                    telecom = Some(mapp.next_value()?);
                                }
                                "address" => {
                                    address = Some(mapp.next_value()?);
                                }
                                "organization" => {
                                    organization = Some(mapp.next_value()?);
                                }
                                "period" => {
                                    period = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ExtendedContactDetail {
                            id,
                            extension,
                            purpose,
                            name,
                            telecom,
                            address,
                            organization,
                            period,
                        })
                    }
                }
                deserializer.deserialize_struct("", ExtendedContactDetailVisitor)
            }
        }
        impl Executor for ExtendedContactDetail {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "ExtendedContactDetail",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "purpose" => self.purpose.exec(&comp),
                            "name" => self.name.exec(&comp),
                            "telecom" => self.telecom.exec(&comp),
                            "address" => self.address.exec(&comp),
                            "organization" => self.organization.exec(&comp),
                            "period" => self.period.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ExtendedContactDetail",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ExtendedContactDetail {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "purpose",
                    "name",
                    "telecom",
                    "address",
                    "organization",
                    "period",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.purpose,
                    &self.name,
                    &self.telecom,
                    &self.address,
                    &self.organization,
                    &&self.period,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ExtendedContactDetail",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExtendedContactDetail {
            #[inline]
            fn clone(&self) -> ExtendedContactDetail {
                ExtendedContactDetail {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    purpose: ::core::clone::Clone::clone(&self.purpose),
                    name: ::core::clone::Clone::clone(&self.name),
                    telecom: ::core::clone::Clone::clone(&self.telecom),
                    address: ::core::clone::Clone::clone(&self.address),
                    organization: ::core::clone::Clone::clone(&self.organization),
                    period: ::core::clone::Clone::clone(&self.period),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ExtendedContactDetail {
            #[inline]
            fn default() -> ExtendedContactDetail {
                ExtendedContactDetail {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    purpose: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    telecom: ::core::default::Default::default(),
                    address: ::core::default::Default::default(),
                    organization: ::core::default::Default::default(),
                    period: ::core::default::Default::default(),
                }
            }
        }
        pub struct HumanName {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// usual | official | temp | nickname | anonymous | old | maiden
            #[fhir(name = "use", min = "0", max = "1", summary = true, modifier = true)]
            pub use_: Option<CodeDt>,
            /// Text representation of the full name
            #[fhir(
                name = "text",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub text: Option<StringDt>,
            /// Family name (often called 'Surname')
            #[fhir(
                name = "family",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub family: Option<StringDt>,
            /// Given names (not always 'first'). Includes middle names
            #[fhir(
                name = "given",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub given: Option<Vec<StringDt>>,
            /// Parts that come before the name
            #[fhir(
                name = "prefix",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub prefix: Option<Vec<StringDt>>,
            /// Parts that come after the name
            #[fhir(
                name = "suffix",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub suffix: Option<Vec<StringDt>>,
            /// Time period when name was/is in use
            #[fhir(
                name = "period",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period: Option<Period>,
        }
        impl Element for HumanName {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for HumanName {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.use_.is_none() & self.text.is_none()
                    & self.family.is_none() & self.given.is_none()
                    & self.prefix.is_none() & self.suffix.is_none()
                    & self.period.is_none()
            }
            fn type_name(&self) -> String {
                "HumanName".to_string()
            }
        }
        impl HumanName {
            pub fn set_use_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.use_ = Some(v.into());
                self
            }
            pub fn set_text<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.text = Some(v.into());
                self
            }
            pub fn set_family<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.family = Some(v.into());
                self
            }
            pub fn set_given(mut self, v: Vec<StringDt>) -> Self {
                self.given = Some(v);
                self
            }
            pub fn add_given<T: Into<StringDt>>(mut self, v: T) -> Self {
                match self.given {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.given = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_prefix(mut self, v: Vec<StringDt>) -> Self {
                self.prefix = Some(v);
                self
            }
            pub fn add_prefix<T: Into<StringDt>>(mut self, v: T) -> Self {
                match self.prefix {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.prefix = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_suffix(mut self, v: Vec<StringDt>) -> Self {
                self.suffix = Some(v);
                self
            }
            pub fn add_suffix<T: Into<StringDt>>(mut self, v: T) -> Self {
                match self.suffix {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.suffix = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_period(mut self, v: Period) -> Self {
                self.period = Some(v);
                self
            }
        }
        impl Serialize for HumanName {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("use", &self.use_)?;
                serialize_struct.serialize_field("text", &self.text)?;
                serialize_struct.serialize_field("family", &self.family)?;
                serialize_struct.serialize_field("given", &self.given)?;
                serialize_struct.serialize_field("prefix", &self.prefix)?;
                serialize_struct.serialize_field("suffix", &self.suffix)?;
                serialize_struct.serialize_field("period", &self.period)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for HumanName {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct HumanNameVisitor;
                impl<'de> Visitor<'de> for HumanNameVisitor {
                    type Value = HumanName;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut use_: Option<CodeDt> = None;
                        let mut text: Option<StringDt> = None;
                        let mut family: Option<StringDt> = None;
                        let mut given: Option<Vec<StringDt>> = None;
                        let mut prefix: Option<Vec<StringDt>> = None;
                        let mut suffix: Option<Vec<StringDt>> = None;
                        let mut period: Option<Period> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "use" => {
                                    use_ = Some(mapp.next_value()?);
                                }
                                "text" => {
                                    text = Some(mapp.next_value()?);
                                }
                                "family" => {
                                    family = Some(mapp.next_value()?);
                                }
                                "given" => {
                                    given = Some(mapp.next_value()?);
                                }
                                "prefix" => {
                                    prefix = Some(mapp.next_value()?);
                                }
                                "suffix" => {
                                    suffix = Some(mapp.next_value()?);
                                }
                                "period" => {
                                    period = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(HumanName {
                            id,
                            extension,
                            use_,
                            text,
                            family,
                            given,
                            prefix,
                            suffix,
                            period,
                        })
                    }
                }
                deserializer.deserialize_struct("", HumanNameVisitor)
            }
        }
        impl Executor for HumanName {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "HumanName"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "use" => self.use_.exec(&comp),
                            "text" => self.text.exec(&comp),
                            "family" => self.family.exec(&comp),
                            "given" => self.given.exec(&comp),
                            "prefix" => self.prefix.exec(&comp),
                            "suffix" => self.suffix.exec(&comp),
                            "period" => self.period.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "HumanName",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HumanName {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "use_",
                    "text",
                    "family",
                    "given",
                    "prefix",
                    "suffix",
                    "period",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.use_,
                    &self.text,
                    &self.family,
                    &self.given,
                    &self.prefix,
                    &self.suffix,
                    &&self.period,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "HumanName",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for HumanName {
            #[inline]
            fn clone(&self) -> HumanName {
                HumanName {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    use_: ::core::clone::Clone::clone(&self.use_),
                    text: ::core::clone::Clone::clone(&self.text),
                    family: ::core::clone::Clone::clone(&self.family),
                    given: ::core::clone::Clone::clone(&self.given),
                    prefix: ::core::clone::Clone::clone(&self.prefix),
                    suffix: ::core::clone::Clone::clone(&self.suffix),
                    period: ::core::clone::Clone::clone(&self.period),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for HumanName {
            #[inline]
            fn default() -> HumanName {
                HumanName {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    use_: ::core::default::Default::default(),
                    text: ::core::default::Default::default(),
                    family: ::core::default::Default::default(),
                    given: ::core::default::Default::default(),
                    prefix: ::core::default::Default::default(),
                    suffix: ::core::default::Default::default(),
                    period: ::core::default::Default::default(),
                }
            }
        }
        pub struct Identifier {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// usual | official | temp | secondary | old (If known)
            #[fhir(name = "use", min = "0", max = "1", summary = true, modifier = true)]
            pub use_: Option<CodeDt>,
            /// Description of identifier
            #[fhir(
                name = "type",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeableConcept>,
            /// The namespace for the identifier value
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// The value that is unique
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<StringDt>,
            /// Time period when id is/was valid for use
            #[fhir(
                name = "period",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period: Option<Period>,
            /// Organization that issued id (may be just text)
            #[fhir(
                name = "assigner",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub assigner: Option<Reference>,
        }
        impl Element for Identifier {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Identifier {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.use_.is_none() & self.type_.is_none()
                    & self.system.is_none() & self.value.is_none()
                    & self.period.is_none() & self.assigner.is_none()
            }
            fn type_name(&self) -> String {
                "Identifier".to_string()
            }
        }
        impl Identifier {
            pub fn set_use_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.use_ = Some(v.into());
                self
            }
            pub fn set_type_(mut self, v: CodeableConcept) -> Self {
                self.type_ = Some(v);
                self
            }
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_value<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_period(mut self, v: Period) -> Self {
                self.period = Some(v);
                self
            }
            pub fn set_assigner(mut self, v: Reference) -> Self {
                self.assigner = Some(v);
                self
            }
        }
        impl Serialize for Identifier {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("use", &self.use_)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("period", &self.period)?;
                serialize_struct.serialize_field("assigner", &self.assigner)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Identifier {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct IdentifierVisitor;
                impl<'de> Visitor<'de> for IdentifierVisitor {
                    type Value = Identifier;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut use_: Option<CodeDt> = None;
                        let mut type_: Option<CodeableConcept> = None;
                        let mut system: Option<UriDt> = None;
                        let mut value: Option<StringDt> = None;
                        let mut period: Option<Period> = None;
                        let mut assigner: Option<Reference> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "use" => {
                                    use_ = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "period" => {
                                    period = Some(mapp.next_value()?);
                                }
                                "assigner" => {
                                    assigner = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Identifier {
                            id,
                            extension,
                            use_,
                            type_,
                            system,
                            value,
                            period,
                            assigner,
                        })
                    }
                }
                deserializer.deserialize_struct("", IdentifierVisitor)
            }
        }
        impl Executor for Identifier {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Identifier"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "use" => self.use_.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "period" => self.period.exec(&comp),
                            "assigner" => self.assigner.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Identifier",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Identifier {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "use_",
                    "type_",
                    "system",
                    "value",
                    "period",
                    "assigner",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.use_,
                    &self.type_,
                    &self.system,
                    &self.value,
                    &self.period,
                    &&self.assigner,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Identifier",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Identifier {
            #[inline]
            fn clone(&self) -> Identifier {
                Identifier {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    use_: ::core::clone::Clone::clone(&self.use_),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    system: ::core::clone::Clone::clone(&self.system),
                    value: ::core::clone::Clone::clone(&self.value),
                    period: ::core::clone::Clone::clone(&self.period),
                    assigner: ::core::clone::Clone::clone(&self.assigner),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Identifier {
            #[inline]
            fn default() -> Identifier {
                Identifier {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    use_: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    period: ::core::default::Default::default(),
                    assigner: ::core::default::Default::default(),
                }
            }
        }
        pub struct MarketingStatus {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Extensions that cannot be ignored even if unrecognized
            #[fhir(
                name = "modifierExtension",
                min = "0",
                max = "*",
                summary = true,
                modifier = true
            )]
            pub modifier_extension: Option<Vec<Extension>>,
            /// The country in which the marketing authorization has been granted shall be specified It should be specified using the ISO 3166 ‑ 1 alpha-2 code elements
            #[fhir(
                name = "country",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub country: Option<CodeableConcept>,
            /// Where a Medicines Regulatory Agency has granted a marketing authorization for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified
            #[fhir(
                name = "jurisdiction",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub jurisdiction: Option<CodeableConcept>,
            /// This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples
            #[fhir(
                name = "status",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub status: Option<CodeableConcept>,
            /// The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE “Placed on the market” refers to the release of the Medicinal Product into the distribution chain
            #[fhir(
                name = "dateRange",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub date_range: Option<Period>,
            /// The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE “Placed on the market” refers to the release of the Medicinal Product into the distribution chain
            #[fhir(
                name = "restoreDate",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub restore_date: Option<DateTimeDt>,
        }
        impl Element for MarketingStatus {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for MarketingStatus {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.modifier_extension.is_none()
                    & self.country.is_none() & self.jurisdiction.is_none()
                    & self.status.is_none() & self.date_range.is_none()
                    & self.restore_date.is_none()
            }
            fn type_name(&self) -> String {
                "MarketingStatus".to_string()
            }
        }
        impl MarketingStatus {
            pub fn set_modifier_extension(mut self, v: Vec<Extension>) -> Self {
                self.modifier_extension = Some(v);
                self
            }
            pub fn add_modifier_extension(mut self, v: Extension) -> Self {
                match self.modifier_extension {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.modifier_extension = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_country(mut self, v: CodeableConcept) -> Self {
                self.country = Some(v);
                self
            }
            pub fn set_jurisdiction(mut self, v: CodeableConcept) -> Self {
                self.jurisdiction = Some(v);
                self
            }
            pub fn set_status(mut self, v: CodeableConcept) -> Self {
                self.status = Some(v);
                self
            }
            pub fn set_date_range(mut self, v: Period) -> Self {
                self.date_range = Some(v);
                self
            }
            pub fn set_restore_date<T: Into<DateTimeDt>>(mut self, v: T) -> Self {
                self.restore_date = Some(v.into());
                self
            }
        }
        impl Serialize for MarketingStatus {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct
                    .serialize_field("modifierExtension", &self.modifier_extension)?;
                serialize_struct.serialize_field("country", &self.country)?;
                serialize_struct.serialize_field("jurisdiction", &self.jurisdiction)?;
                serialize_struct.serialize_field("status", &self.status)?;
                serialize_struct.serialize_field("dateRange", &self.date_range)?;
                serialize_struct.serialize_field("restoreDate", &self.restore_date)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for MarketingStatus {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct MarketingStatusVisitor;
                impl<'de> Visitor<'de> for MarketingStatusVisitor {
                    type Value = MarketingStatus;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut modifier_extension: Option<Vec<Extension>> = None;
                        let mut country: Option<CodeableConcept> = None;
                        let mut jurisdiction: Option<CodeableConcept> = None;
                        let mut status: Option<CodeableConcept> = None;
                        let mut date_range: Option<Period> = None;
                        let mut restore_date: Option<DateTimeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "modifierExtension" => {
                                    modifier_extension = Some(mapp.next_value()?);
                                }
                                "country" => {
                                    country = Some(mapp.next_value()?);
                                }
                                "jurisdiction" => {
                                    jurisdiction = Some(mapp.next_value()?);
                                }
                                "status" => {
                                    status = Some(mapp.next_value()?);
                                }
                                "dateRange" => {
                                    date_range = Some(mapp.next_value()?);
                                }
                                "restoreDate" => {
                                    restore_date = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(MarketingStatus {
                            id,
                            extension,
                            modifier_extension,
                            country,
                            jurisdiction,
                            status,
                            date_range,
                            restore_date,
                        })
                    }
                }
                deserializer.deserialize_struct("", MarketingStatusVisitor)
            }
        }
        impl Executor for MarketingStatus {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "MarketingStatus"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "modifierExtension" => self.modifier_extension.exec(&comp),
                            "country" => self.country.exec(&comp),
                            "jurisdiction" => self.jurisdiction.exec(&comp),
                            "status" => self.status.exec(&comp),
                            "dateRange" => self.date_range.exec(&comp),
                            "restoreDate" => self.restore_date.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "MarketingStatus",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MarketingStatus {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "modifier_extension",
                    "country",
                    "jurisdiction",
                    "status",
                    "date_range",
                    "restore_date",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.modifier_extension,
                    &self.country,
                    &self.jurisdiction,
                    &self.status,
                    &self.date_range,
                    &&self.restore_date,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "MarketingStatus",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MarketingStatus {
            #[inline]
            fn clone(&self) -> MarketingStatus {
                MarketingStatus {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    modifier_extension: ::core::clone::Clone::clone(
                        &self.modifier_extension,
                    ),
                    country: ::core::clone::Clone::clone(&self.country),
                    jurisdiction: ::core::clone::Clone::clone(&self.jurisdiction),
                    status: ::core::clone::Clone::clone(&self.status),
                    date_range: ::core::clone::Clone::clone(&self.date_range),
                    restore_date: ::core::clone::Clone::clone(&self.restore_date),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MarketingStatus {
            #[inline]
            fn default() -> MarketingStatus {
                MarketingStatus {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    modifier_extension: ::core::default::Default::default(),
                    country: ::core::default::Default::default(),
                    jurisdiction: ::core::default::Default::default(),
                    status: ::core::default::Default::default(),
                    date_range: ::core::default::Default::default(),
                    restore_date: ::core::default::Default::default(),
                }
            }
        }
        pub struct Meta {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Version specific identifier
            #[fhir(
                name = "versionId",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub version_id: Option<IdDt>,
            /// When the resource version last changed
            #[fhir(
                name = "lastUpdated",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub last_updated: Option<InstantDt>,
            /// Identifies where the resource comes from
            #[fhir(
                name = "source",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub source: Option<UriDt>,
            /// Profiles this resource claims to conform to
            #[fhir(
                name = "profile",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub profile: Option<Vec<CanonicalDt>>,
            /// Security Labels applied to this resource
            #[fhir(
                name = "security",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub security: Option<Vec<Coding>>,
            /// Tags applied to this resource
            #[fhir(
                name = "tag",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub tag: Option<Vec<Coding>>,
        }
        impl Element for Meta {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Meta {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.version_id.is_none()
                    & self.last_updated.is_none() & self.source.is_none()
                    & self.profile.is_none() & self.security.is_none()
                    & self.tag.is_none()
            }
            fn type_name(&self) -> String {
                "Meta".to_string()
            }
        }
        impl Meta {
            pub fn set_version_id<T: Into<IdDt>>(mut self, v: T) -> Self {
                self.version_id = Some(v.into());
                self
            }
            pub fn set_last_updated<T: Into<InstantDt>>(mut self, v: T) -> Self {
                self.last_updated = Some(v.into());
                self
            }
            pub fn set_source<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.source = Some(v.into());
                self
            }
            pub fn set_profile(mut self, v: Vec<CanonicalDt>) -> Self {
                self.profile = Some(v);
                self
            }
            pub fn add_profile<T: Into<CanonicalDt>>(mut self, v: T) -> Self {
                match self.profile {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.profile = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_security(mut self, v: Vec<Coding>) -> Self {
                self.security = Some(v);
                self
            }
            pub fn add_security(mut self, v: Coding) -> Self {
                match self.security {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.security = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_tag(mut self, v: Vec<Coding>) -> Self {
                self.tag = Some(v);
                self
            }
            pub fn add_tag(mut self, v: Coding) -> Self {
                match self.tag {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.tag = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for Meta {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("versionId", &self.version_id)?;
                serialize_struct.serialize_field("lastUpdated", &self.last_updated)?;
                serialize_struct.serialize_field("source", &self.source)?;
                serialize_struct.serialize_field("profile", &self.profile)?;
                serialize_struct.serialize_field("security", &self.security)?;
                serialize_struct.serialize_field("tag", &self.tag)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Meta {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct MetaVisitor;
                impl<'de> Visitor<'de> for MetaVisitor {
                    type Value = Meta;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut version_id: Option<IdDt> = None;
                        let mut last_updated: Option<InstantDt> = None;
                        let mut source: Option<UriDt> = None;
                        let mut profile: Option<Vec<CanonicalDt>> = None;
                        let mut security: Option<Vec<Coding>> = None;
                        let mut tag: Option<Vec<Coding>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "versionId" => {
                                    version_id = Some(mapp.next_value()?);
                                }
                                "lastUpdated" => {
                                    last_updated = Some(mapp.next_value()?);
                                }
                                "source" => {
                                    source = Some(mapp.next_value()?);
                                }
                                "profile" => {
                                    profile = Some(mapp.next_value()?);
                                }
                                "security" => {
                                    security = Some(mapp.next_value()?);
                                }
                                "tag" => {
                                    tag = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Meta {
                            id,
                            extension,
                            version_id,
                            last_updated,
                            source,
                            profile,
                            security,
                            tag,
                        })
                    }
                }
                deserializer.deserialize_struct("", MetaVisitor)
            }
        }
        impl Executor for Meta {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Meta"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "versionId" => self.version_id.exec(&comp),
                            "lastUpdated" => self.last_updated.exec(&comp),
                            "source" => self.source.exec(&comp),
                            "profile" => self.profile.exec(&comp),
                            "security" => self.security.exec(&comp),
                            "tag" => self.tag.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!("{0}: 无效的路径名:[{1}]", "Meta", other),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Meta {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "version_id",
                    "last_updated",
                    "source",
                    "profile",
                    "security",
                    "tag",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.version_id,
                    &self.last_updated,
                    &self.source,
                    &self.profile,
                    &self.security,
                    &&self.tag,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Meta",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Meta {
            #[inline]
            fn clone(&self) -> Meta {
                Meta {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    version_id: ::core::clone::Clone::clone(&self.version_id),
                    last_updated: ::core::clone::Clone::clone(&self.last_updated),
                    source: ::core::clone::Clone::clone(&self.source),
                    profile: ::core::clone::Clone::clone(&self.profile),
                    security: ::core::clone::Clone::clone(&self.security),
                    tag: ::core::clone::Clone::clone(&self.tag),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Meta {
            #[inline]
            fn default() -> Meta {
                Meta {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    version_id: ::core::default::Default::default(),
                    last_updated: ::core::default::Default::default(),
                    source: ::core::default::Default::default(),
                    profile: ::core::default::Default::default(),
                    security: ::core::default::Default::default(),
                    tag: ::core::default::Default::default(),
                }
            }
        }
        pub struct MonetaryComponent {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// base | surcharge | deduction | discount | tax | informational
            #[fhir(
                name = "type",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeDt>,
            /// Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeableConcept>,
            /// Factor used for calculating this component
            #[fhir(
                name = "factor",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub factor: Option<DecimalDt>,
            /// Explicit value amount to be used
            #[fhir(
                name = "amount",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub amount: Option<Money>,
        }
        impl Element for MonetaryComponent {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for MonetaryComponent {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.type_.is_none() & self.code.is_none()
                    & self.factor.is_none() & self.amount.is_none()
            }
            fn type_name(&self) -> String {
                "MonetaryComponent".to_string()
            }
        }
        impl MonetaryComponent {
            pub fn set_type_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.type_ = Some(v.into());
                self
            }
            pub fn set_code(mut self, v: CodeableConcept) -> Self {
                self.code = Some(v);
                self
            }
            pub fn set_factor<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.factor = Some(v.into());
                self
            }
            pub fn set_amount(mut self, v: Money) -> Self {
                self.amount = Some(v);
                self
            }
        }
        impl Serialize for MonetaryComponent {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_field("factor", &self.factor)?;
                serialize_struct.serialize_field("amount", &self.amount)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for MonetaryComponent {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct MonetaryComponentVisitor;
                impl<'de> Visitor<'de> for MonetaryComponentVisitor {
                    type Value = MonetaryComponent;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<CodeDt> = None;
                        let mut code: Option<CodeableConcept> = None;
                        let mut factor: Option<DecimalDt> = None;
                        let mut amount: Option<Money> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                "factor" => {
                                    factor = Some(mapp.next_value()?);
                                }
                                "amount" => {
                                    amount = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(MonetaryComponent {
                            id,
                            extension,
                            type_,
                            code,
                            factor,
                            amount,
                        })
                    }
                }
                deserializer.deserialize_struct("", MonetaryComponentVisitor)
            }
        }
        impl Executor for MonetaryComponent {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "MonetaryComponent",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "code" => self.code.exec(&comp),
                            "factor" => self.factor.exec(&comp),
                            "amount" => self.amount.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "MonetaryComponent",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MonetaryComponent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "type_",
                    "code",
                    "factor",
                    "amount",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.type_,
                    &self.code,
                    &self.factor,
                    &&self.amount,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "MonetaryComponent",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MonetaryComponent {
            #[inline]
            fn clone(&self) -> MonetaryComponent {
                MonetaryComponent {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    code: ::core::clone::Clone::clone(&self.code),
                    factor: ::core::clone::Clone::clone(&self.factor),
                    amount: ::core::clone::Clone::clone(&self.amount),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MonetaryComponent {
            #[inline]
            fn default() -> MonetaryComponent {
                MonetaryComponent {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                    factor: ::core::default::Default::default(),
                    amount: ::core::default::Default::default(),
                }
            }
        }
        pub struct Money {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerical value (with implicit precision)
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DecimalDt>,
            /// ISO 4217 Currency Code
            #[fhir(
                name = "currency",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub currency: Option<CodeDt>,
        }
        impl Element for Money {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Money {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.value.is_none() & self.currency.is_none()
            }
            fn type_name(&self) -> String {
                "Money".to_string()
            }
        }
        impl Money {
            pub fn set_value<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_currency<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.currency = Some(v.into());
                self
            }
        }
        impl Serialize for Money {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("currency", &self.currency)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Money {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct MoneyVisitor;
                impl<'de> Visitor<'de> for MoneyVisitor {
                    type Value = Money;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DecimalDt> = None;
                        let mut currency: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "currency" => {
                                    currency = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Money {
                            id,
                            extension,
                            value,
                            currency,
                        })
                    }
                }
                deserializer.deserialize_struct("", MoneyVisitor)
            }
        }
        impl Executor for Money {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Money"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "currency" => self.currency.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Money",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Money {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Money",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "value",
                    &self.value,
                    "currency",
                    &&self.currency,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Money {
            #[inline]
            fn clone(&self) -> Money {
                Money {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                    currency: ::core::clone::Clone::clone(&self.currency),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Money {
            #[inline]
            fn default() -> Money {
                Money {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    currency: ::core::default::Default::default(),
                }
            }
        }
        pub struct Narrative {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// generated | extensions | additional | empty
            #[fhir(
                name = "status",
                min = "1",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub status: Option<CodeDt>,
            /// Limited xhtml content
            #[fhir(
                name = "div",
                min = "1",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub div: Option<XhtmlDt>,
        }
        impl Element for Narrative {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Narrative {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.status.is_none() & self.div.is_none()
            }
            fn type_name(&self) -> String {
                "Narrative".to_string()
            }
        }
        impl Narrative {
            pub fn set_status<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.status = Some(v.into());
                self
            }
            pub fn set_div<T: Into<XhtmlDt>>(mut self, v: T) -> Self {
                self.div = Some(v.into());
                self
            }
        }
        impl Serialize for Narrative {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("status", &self.status)?;
                serialize_struct.serialize_field("div", &self.div)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Narrative {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct NarrativeVisitor;
                impl<'de> Visitor<'de> for NarrativeVisitor {
                    type Value = Narrative;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut status: Option<CodeDt> = None;
                        let mut div: Option<XhtmlDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "status" => {
                                    status = Some(mapp.next_value()?);
                                }
                                "div" => {
                                    div = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Narrative {
                            id,
                            extension,
                            status,
                            div,
                        })
                    }
                }
                deserializer.deserialize_struct("", NarrativeVisitor)
            }
        }
        impl Executor for Narrative {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Narrative"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "status" => self.status.exec(&comp),
                            "div" => self.div.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Narrative",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Narrative {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Narrative",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "status",
                    &self.status,
                    "div",
                    &&self.div,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Narrative {
            #[inline]
            fn clone(&self) -> Narrative {
                Narrative {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    status: ::core::clone::Clone::clone(&self.status),
                    div: ::core::clone::Clone::clone(&self.div),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Narrative {
            #[inline]
            fn default() -> Narrative {
                Narrative {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    status: ::core::default::Default::default(),
                    div: ::core::default::Default::default(),
                }
            }
        }
        pub struct ParameterDefinition {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Name used to access the parameter value
            #[fhir(
                name = "name",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub name: Option<CodeDt>,
            /// in | out
            #[fhir(
                name = "use",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub use_: Option<CodeDt>,
            /// Minimum cardinality
            #[fhir(
                name = "min",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub min: Option<IntegerDt>,
            /// Maximum cardinality (a number of *)
            #[fhir(
                name = "max",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max: Option<StringDt>,
            /// A brief description of the parameter
            #[fhir(
                name = "documentation",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub documentation: Option<StringDt>,
            /// What type of value
            #[fhir(
                name = "type",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeDt>,
            /// What profile the value is expected to be
            #[fhir(
                name = "profile",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub profile: Option<CanonicalDt>,
        }
        impl Element for ParameterDefinition {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ParameterDefinition {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.name.is_none() & self.use_.is_none()
                    & self.min.is_none() & self.max.is_none()
                    & self.documentation.is_none() & self.type_.is_none()
                    & self.profile.is_none()
            }
            fn type_name(&self) -> String {
                "ParameterDefinition".to_string()
            }
        }
        impl ParameterDefinition {
            pub fn set_name<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.name = Some(v.into());
                self
            }
            pub fn set_use_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.use_ = Some(v.into());
                self
            }
            pub fn set_min<T: Into<IntegerDt>>(mut self, v: T) -> Self {
                self.min = Some(v.into());
                self
            }
            pub fn set_max<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.max = Some(v.into());
                self
            }
            pub fn set_documentation<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.documentation = Some(v.into());
                self
            }
            pub fn set_type_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.type_ = Some(v.into());
                self
            }
            pub fn set_profile<T: Into<CanonicalDt>>(mut self, v: T) -> Self {
                self.profile = Some(v.into());
                self
            }
        }
        impl Serialize for ParameterDefinition {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("name", &self.name)?;
                serialize_struct.serialize_field("use", &self.use_)?;
                serialize_struct.serialize_field("min", &self.min)?;
                serialize_struct.serialize_field("max", &self.max)?;
                serialize_struct.serialize_field("documentation", &self.documentation)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("profile", &self.profile)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ParameterDefinition {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ParameterDefinitionVisitor;
                impl<'de> Visitor<'de> for ParameterDefinitionVisitor {
                    type Value = ParameterDefinition;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut name: Option<CodeDt> = None;
                        let mut use_: Option<CodeDt> = None;
                        let mut min: Option<IntegerDt> = None;
                        let mut max: Option<StringDt> = None;
                        let mut documentation: Option<StringDt> = None;
                        let mut type_: Option<CodeDt> = None;
                        let mut profile: Option<CanonicalDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "name" => {
                                    name = Some(mapp.next_value()?);
                                }
                                "use" => {
                                    use_ = Some(mapp.next_value()?);
                                }
                                "min" => {
                                    min = Some(mapp.next_value()?);
                                }
                                "max" => {
                                    max = Some(mapp.next_value()?);
                                }
                                "documentation" => {
                                    documentation = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "profile" => {
                                    profile = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ParameterDefinition {
                            id,
                            extension,
                            name,
                            use_,
                            min,
                            max,
                            documentation,
                            type_,
                            profile,
                        })
                    }
                }
                deserializer.deserialize_struct("", ParameterDefinitionVisitor)
            }
        }
        impl Executor for ParameterDefinition {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "ParameterDefinition",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "name" => self.name.exec(&comp),
                            "use" => self.use_.exec(&comp),
                            "min" => self.min.exec(&comp),
                            "max" => self.max.exec(&comp),
                            "documentation" => self.documentation.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "profile" => self.profile.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ParameterDefinition",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ParameterDefinition {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "name",
                    "use_",
                    "min",
                    "max",
                    "documentation",
                    "type_",
                    "profile",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.name,
                    &self.use_,
                    &self.min,
                    &self.max,
                    &self.documentation,
                    &self.type_,
                    &&self.profile,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ParameterDefinition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ParameterDefinition {
            #[inline]
            fn clone(&self) -> ParameterDefinition {
                ParameterDefinition {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    name: ::core::clone::Clone::clone(&self.name),
                    use_: ::core::clone::Clone::clone(&self.use_),
                    min: ::core::clone::Clone::clone(&self.min),
                    max: ::core::clone::Clone::clone(&self.max),
                    documentation: ::core::clone::Clone::clone(&self.documentation),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    profile: ::core::clone::Clone::clone(&self.profile),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ParameterDefinition {
            #[inline]
            fn default() -> ParameterDefinition {
                ParameterDefinition {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    use_: ::core::default::Default::default(),
                    min: ::core::default::Default::default(),
                    max: ::core::default::Default::default(),
                    documentation: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    profile: ::core::default::Default::default(),
                }
            }
        }
        pub struct Period {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Starting time with inclusive boundary
            #[fhir(
                name = "start",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub start: Option<DateTimeDt>,
            /// End time with inclusive boundary, if not ongoing
            #[fhir(
                name = "end",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub end: Option<DateTimeDt>,
        }
        impl Element for Period {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Period {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.start.is_none() & self.end.is_none()
            }
            fn type_name(&self) -> String {
                "Period".to_string()
            }
        }
        impl Period {
            pub fn set_start<T: Into<DateTimeDt>>(mut self, v: T) -> Self {
                self.start = Some(v.into());
                self
            }
            pub fn set_end<T: Into<DateTimeDt>>(mut self, v: T) -> Self {
                self.end = Some(v.into());
                self
            }
        }
        impl Serialize for Period {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("start", &self.start)?;
                serialize_struct.serialize_field("end", &self.end)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Period {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct PeriodVisitor;
                impl<'de> Visitor<'de> for PeriodVisitor {
                    type Value = Period;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut start: Option<DateTimeDt> = None;
                        let mut end: Option<DateTimeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "start" => {
                                    start = Some(mapp.next_value()?);
                                }
                                "end" => {
                                    end = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Period {
                            id,
                            extension,
                            start,
                            end,
                        })
                    }
                }
                deserializer.deserialize_struct("", PeriodVisitor)
            }
        }
        impl Executor for Period {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Period"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "start" => self.start.exec(&comp),
                            "end" => self.end.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Period",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Period {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Period",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "start",
                    &self.start,
                    "end",
                    &&self.end,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Period {
            #[inline]
            fn clone(&self) -> Period {
                Period {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    start: ::core::clone::Clone::clone(&self.start),
                    end: ::core::clone::Clone::clone(&self.end),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Period {
            #[inline]
            fn default() -> Period {
                Period {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    start: ::core::default::Default::default(),
                    end: ::core::default::Default::default(),
                }
            }
        }
        pub struct PrimitiveType {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
        }
        impl Element for PrimitiveType {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for PrimitiveType {
            fn is_empty(&self) -> bool {
                self.extension.is_none()
            }
            fn type_name(&self) -> String {
                "PrimitiveType".to_string()
            }
        }
        impl PrimitiveType {}
        impl Serialize for PrimitiveType {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for PrimitiveType {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct PrimitiveTypeVisitor;
                impl<'de> Visitor<'de> for PrimitiveTypeVisitor {
                    type Value = PrimitiveType;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(PrimitiveType { id, extension })
                    }
                }
                deserializer.deserialize_struct("", PrimitiveTypeVisitor)
            }
        }
        impl Executor for PrimitiveType {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "PrimitiveType"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "PrimitiveType",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PrimitiveType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "PrimitiveType",
                    "id",
                    &self.id,
                    "extension",
                    &&self.extension,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PrimitiveType {
            #[inline]
            fn clone(&self) -> PrimitiveType {
                PrimitiveType {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for PrimitiveType {
            #[inline]
            fn default() -> PrimitiveType {
                PrimitiveType {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                }
            }
        }
        pub struct ProductShelfLife {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Extensions that cannot be ignored even if unrecognized
            #[fhir(
                name = "modifierExtension",
                min = "0",
                max = "*",
                summary = true,
                modifier = true
            )]
            pub modifier_extension: Option<Vec<Extension>>,
            /// This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
            #[fhir(
                name = "type",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeableConcept>,
            /// The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
            #[fhir(
                name = "period",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period: Option<StringDt>,
            /// Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
            #[fhir(
                name = "specialPrecautionsForStorage",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub special_precautions_for_storage: Option<Vec<CodeableConcept>>,
        }
        impl Element for ProductShelfLife {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for ProductShelfLife {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.modifier_extension.is_none()
                    & self.type_.is_none() & self.period.is_none()
                    & self.special_precautions_for_storage.is_none()
            }
            fn type_name(&self) -> String {
                "ProductShelfLife".to_string()
            }
        }
        impl ProductShelfLife {
            pub fn set_modifier_extension(mut self, v: Vec<Extension>) -> Self {
                self.modifier_extension = Some(v);
                self
            }
            pub fn add_modifier_extension(mut self, v: Extension) -> Self {
                match self.modifier_extension {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.modifier_extension = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_type_(mut self, v: CodeableConcept) -> Self {
                self.type_ = Some(v);
                self
            }
            pub fn set_period<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.period = Some(v.into());
                self
            }
            pub fn set_special_precautions_for_storage(
                mut self,
                v: Vec<CodeableConcept>,
            ) -> Self {
                self.special_precautions_for_storage = Some(v);
                self
            }
            pub fn add_special_precautions_for_storage(
                mut self,
                v: CodeableConcept,
            ) -> Self {
                match self.special_precautions_for_storage {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.special_precautions_for_storage = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
        }
        impl Serialize for ProductShelfLife {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct
                    .serialize_field("modifierExtension", &self.modifier_extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("period", &self.period)?;
                serialize_struct
                    .serialize_field(
                        "specialPrecautionsForStorage",
                        &self.special_precautions_for_storage,
                    )?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for ProductShelfLife {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ProductShelfLifeVisitor;
                impl<'de> Visitor<'de> for ProductShelfLifeVisitor {
                    type Value = ProductShelfLife;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut modifier_extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<CodeableConcept> = None;
                        let mut period: Option<StringDt> = None;
                        let mut special_precautions_for_storage: Option<
                            Vec<CodeableConcept>,
                        > = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "modifierExtension" => {
                                    modifier_extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "period" => {
                                    period = Some(mapp.next_value()?);
                                }
                                "specialPrecautionsForStorage" => {
                                    special_precautions_for_storage = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(ProductShelfLife {
                            id,
                            extension,
                            modifier_extension,
                            type_,
                            period,
                            special_precautions_for_storage,
                        })
                    }
                }
                deserializer.deserialize_struct("", ProductShelfLifeVisitor)
            }
        }
        impl Executor for ProductShelfLife {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "ProductShelfLife"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "modifierExtension" => self.modifier_extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "period" => self.period.exec(&comp),
                            "specialPrecautionsForStorage" => {
                                self.special_precautions_for_storage.exec(&comp)
                            }
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "ProductShelfLife",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ProductShelfLife {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "modifier_extension",
                    "type_",
                    "period",
                    "special_precautions_for_storage",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.modifier_extension,
                    &self.type_,
                    &self.period,
                    &&self.special_precautions_for_storage,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ProductShelfLife",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ProductShelfLife {
            #[inline]
            fn clone(&self) -> ProductShelfLife {
                ProductShelfLife {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    modifier_extension: ::core::clone::Clone::clone(
                        &self.modifier_extension,
                    ),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    period: ::core::clone::Clone::clone(&self.period),
                    special_precautions_for_storage: ::core::clone::Clone::clone(
                        &self.special_precautions_for_storage,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ProductShelfLife {
            #[inline]
            fn default() -> ProductShelfLife {
                ProductShelfLife {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    modifier_extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    period: ::core::default::Default::default(),
                    special_precautions_for_storage: ::core::default::Default::default(),
                }
            }
        }
        pub struct Quantity {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerical value (with implicit precision)
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DecimalDt>,
            /// < | <= | >= | > | ad - how to understand the value
            #[fhir(
                name = "comparator",
                min = "0",
                max = "1",
                summary = true,
                modifier = true
            )]
            pub comparator: Option<CodeDt>,
            /// Unit representation
            #[fhir(
                name = "unit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub unit: Option<StringDt>,
            /// System that defines coded unit form
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// Coded form of the unit
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeDt>,
        }
        impl Element for Quantity {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Quantity {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.value.is_none()
                    & self.comparator.is_none() & self.unit.is_none()
                    & self.system.is_none() & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "Quantity".to_string()
            }
        }
        impl Quantity {
            pub fn set_value<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_comparator<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.comparator = Some(v.into());
                self
            }
            pub fn set_unit<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.unit = Some(v.into());
                self
            }
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_code<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.code = Some(v.into());
                self
            }
        }
        impl Serialize for Quantity {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("comparator", &self.comparator)?;
                serialize_struct.serialize_field("unit", &self.unit)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Quantity {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct QuantityVisitor;
                impl<'de> Visitor<'de> for QuantityVisitor {
                    type Value = Quantity;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DecimalDt> = None;
                        let mut comparator: Option<CodeDt> = None;
                        let mut unit: Option<StringDt> = None;
                        let mut system: Option<UriDt> = None;
                        let mut code: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "comparator" => {
                                    comparator = Some(mapp.next_value()?);
                                }
                                "unit" => {
                                    unit = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Quantity {
                            id,
                            extension,
                            value,
                            comparator,
                            unit,
                            system,
                            code,
                        })
                    }
                }
                deserializer.deserialize_struct("", QuantityVisitor)
            }
        }
        impl Executor for Quantity {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Quantity"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "comparator" => self.comparator.exec(&comp),
                            "unit" => self.unit.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Quantity",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Quantity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "value",
                    "comparator",
                    "unit",
                    "system",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.value,
                    &self.comparator,
                    &self.unit,
                    &self.system,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Quantity",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Quantity {
            #[inline]
            fn clone(&self) -> Quantity {
                Quantity {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                    comparator: ::core::clone::Clone::clone(&self.comparator),
                    unit: ::core::clone::Clone::clone(&self.unit),
                    system: ::core::clone::Clone::clone(&self.system),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Quantity {
            #[inline]
            fn default() -> Quantity {
                Quantity {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    comparator: ::core::default::Default::default(),
                    unit: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
        pub struct Range {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Low limit
            #[fhir(
                name = "low",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub low: Option<Quantity>,
            /// High limit
            #[fhir(
                name = "high",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub high: Option<Quantity>,
        }
        impl Element for Range {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Range {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.low.is_none() & self.high.is_none()
            }
            fn type_name(&self) -> String {
                "Range".to_string()
            }
        }
        impl Range {
            pub fn set_low(mut self, v: Quantity) -> Self {
                self.low = Some(v);
                self
            }
            pub fn set_high(mut self, v: Quantity) -> Self {
                self.high = Some(v);
                self
            }
        }
        impl Serialize for Range {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("low", &self.low)?;
                serialize_struct.serialize_field("high", &self.high)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Range {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct RangeVisitor;
                impl<'de> Visitor<'de> for RangeVisitor {
                    type Value = Range;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut low: Option<Quantity> = None;
                        let mut high: Option<Quantity> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "low" => {
                                    low = Some(mapp.next_value()?);
                                }
                                "high" => {
                                    high = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Range { id, extension, low, high })
                    }
                }
                deserializer.deserialize_struct("", RangeVisitor)
            }
        }
        impl Executor for Range {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Range"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "low" => self.low.exec(&comp),
                            "high" => self.high.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Range",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Range {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Range",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "low",
                    &self.low,
                    "high",
                    &&self.high,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Range {
            #[inline]
            fn clone(&self) -> Range {
                Range {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    low: ::core::clone::Clone::clone(&self.low),
                    high: ::core::clone::Clone::clone(&self.high),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Range {
            #[inline]
            fn default() -> Range {
                Range {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    low: ::core::default::Default::default(),
                    high: ::core::default::Default::default(),
                }
            }
        }
        pub struct Ratio {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerator value
            #[fhir(
                name = "numerator",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub numerator: Option<Quantity>,
            /// Denominator value
            #[fhir(
                name = "denominator",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub denominator: Option<Quantity>,
        }
        impl Element for Ratio {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Ratio {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.numerator.is_none()
                    & self.denominator.is_none()
            }
            fn type_name(&self) -> String {
                "Ratio".to_string()
            }
        }
        impl Ratio {
            pub fn set_numerator(mut self, v: Quantity) -> Self {
                self.numerator = Some(v);
                self
            }
            pub fn set_denominator(mut self, v: Quantity) -> Self {
                self.denominator = Some(v);
                self
            }
        }
        impl Serialize for Ratio {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("numerator", &self.numerator)?;
                serialize_struct.serialize_field("denominator", &self.denominator)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Ratio {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct RatioVisitor;
                impl<'de> Visitor<'de> for RatioVisitor {
                    type Value = Ratio;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut numerator: Option<Quantity> = None;
                        let mut denominator: Option<Quantity> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "numerator" => {
                                    numerator = Some(mapp.next_value()?);
                                }
                                "denominator" => {
                                    denominator = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Ratio {
                            id,
                            extension,
                            numerator,
                            denominator,
                        })
                    }
                }
                deserializer.deserialize_struct("", RatioVisitor)
            }
        }
        impl Executor for Ratio {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Ratio"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "numerator" => self.numerator.exec(&comp),
                            "denominator" => self.denominator.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Ratio",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Ratio {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Ratio",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "numerator",
                    &self.numerator,
                    "denominator",
                    &&self.denominator,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Ratio {
            #[inline]
            fn clone(&self) -> Ratio {
                Ratio {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    numerator: ::core::clone::Clone::clone(&self.numerator),
                    denominator: ::core::clone::Clone::clone(&self.denominator),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Ratio {
            #[inline]
            fn default() -> Ratio {
                Ratio {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    numerator: ::core::default::Default::default(),
                    denominator: ::core::default::Default::default(),
                }
            }
        }
        pub struct RatioRange {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Low Numerator limit
            #[fhir(
                name = "lowNumerator",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub low_numerator: Option<Quantity>,
            /// High Numerator limit
            #[fhir(
                name = "highNumerator",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub high_numerator: Option<Quantity>,
            /// Denominator value
            #[fhir(
                name = "denominator",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub denominator: Option<Quantity>,
        }
        impl Element for RatioRange {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for RatioRange {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.low_numerator.is_none()
                    & self.high_numerator.is_none() & self.denominator.is_none()
            }
            fn type_name(&self) -> String {
                "RatioRange".to_string()
            }
        }
        impl RatioRange {
            pub fn set_low_numerator(mut self, v: Quantity) -> Self {
                self.low_numerator = Some(v);
                self
            }
            pub fn set_high_numerator(mut self, v: Quantity) -> Self {
                self.high_numerator = Some(v);
                self
            }
            pub fn set_denominator(mut self, v: Quantity) -> Self {
                self.denominator = Some(v);
                self
            }
        }
        impl Serialize for RatioRange {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("lowNumerator", &self.low_numerator)?;
                serialize_struct.serialize_field("highNumerator", &self.high_numerator)?;
                serialize_struct.serialize_field("denominator", &self.denominator)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for RatioRange {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct RatioRangeVisitor;
                impl<'de> Visitor<'de> for RatioRangeVisitor {
                    type Value = RatioRange;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut low_numerator: Option<Quantity> = None;
                        let mut high_numerator: Option<Quantity> = None;
                        let mut denominator: Option<Quantity> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "lowNumerator" => {
                                    low_numerator = Some(mapp.next_value()?);
                                }
                                "highNumerator" => {
                                    high_numerator = Some(mapp.next_value()?);
                                }
                                "denominator" => {
                                    denominator = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(RatioRange {
                            id,
                            extension,
                            low_numerator,
                            high_numerator,
                            denominator,
                        })
                    }
                }
                deserializer.deserialize_struct("", RatioRangeVisitor)
            }
        }
        impl Executor for RatioRange {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "RatioRange"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "lowNumerator" => self.low_numerator.exec(&comp),
                            "highNumerator" => self.high_numerator.exec(&comp),
                            "denominator" => self.denominator.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "RatioRange",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RatioRange {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "RatioRange",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "low_numerator",
                    &self.low_numerator,
                    "high_numerator",
                    &self.high_numerator,
                    "denominator",
                    &&self.denominator,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RatioRange {
            #[inline]
            fn clone(&self) -> RatioRange {
                RatioRange {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    low_numerator: ::core::clone::Clone::clone(&self.low_numerator),
                    high_numerator: ::core::clone::Clone::clone(&self.high_numerator),
                    denominator: ::core::clone::Clone::clone(&self.denominator),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RatioRange {
            #[inline]
            fn default() -> RatioRange {
                RatioRange {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    low_numerator: ::core::default::Default::default(),
                    high_numerator: ::core::default::Default::default(),
                    denominator: ::core::default::Default::default(),
                }
            }
        }
        pub struct Reference {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Literal reference, Relative, internal or absolute URL
            #[fhir(
                name = "reference",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub reference: Option<StringDt>,
            /// Type the reference refers to (e.g. "Patient") - must be a resource in resources
            #[fhir(
                name = "type",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<UriDt>,
            /// Logical reference, when literal reference is not known
            #[fhir(
                name = "identifier",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub identifier: Option<Box<Identifier>>,
            /// Text alternative for the resource
            #[fhir(
                name = "display",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub display: Option<StringDt>,
        }
        impl Element for Reference {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Reference {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.reference.is_none()
                    & self.type_.is_none() & self.identifier.is_none()
                    & self.display.is_none()
            }
            fn type_name(&self) -> String {
                "Reference".to_string()
            }
        }
        impl Reference {
            pub fn set_reference<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.reference = Some(v.into());
                self
            }
            pub fn set_type_<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.type_ = Some(v.into());
                self
            }
            pub fn set_identifier(mut self, v: Box<Identifier>) -> Self {
                self.identifier = Some(v);
                self
            }
            pub fn set_display<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.display = Some(v.into());
                self
            }
        }
        impl Serialize for Reference {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("reference", &self.reference)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("identifier", &self.identifier)?;
                serialize_struct.serialize_field("display", &self.display)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Reference {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct ReferenceVisitor;
                impl<'de> Visitor<'de> for ReferenceVisitor {
                    type Value = Reference;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut reference: Option<StringDt> = None;
                        let mut type_: Option<UriDt> = None;
                        let mut identifier: Option<Box<Identifier>> = None;
                        let mut display: Option<StringDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "reference" => {
                                    reference = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "identifier" => {
                                    identifier = Some(mapp.next_value()?);
                                }
                                "display" => {
                                    display = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Reference {
                            id,
                            extension,
                            reference,
                            type_,
                            identifier,
                            display,
                        })
                    }
                }
                deserializer.deserialize_struct("", ReferenceVisitor)
            }
        }
        impl Executor for Reference {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Reference"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "reference" => self.reference.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "identifier" => self.identifier.exec(&comp),
                            "display" => self.display.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Reference",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Reference {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "reference",
                    "type_",
                    "identifier",
                    "display",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.reference,
                    &self.type_,
                    &self.identifier,
                    &&self.display,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Reference",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Reference {
            #[inline]
            fn clone(&self) -> Reference {
                Reference {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    reference: ::core::clone::Clone::clone(&self.reference),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    identifier: ::core::clone::Clone::clone(&self.identifier),
                    display: ::core::clone::Clone::clone(&self.display),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Reference {
            #[inline]
            fn default() -> Reference {
                Reference {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    reference: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    identifier: ::core::default::Default::default(),
                    display: ::core::default::Default::default(),
                }
            }
        }
        pub struct RelatedArtifact {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of | part-of | amends | amended-with | appends | appended-with | cites | cited-by | comments-on | comment-in | contains | contained-in | corrects | correction-in | replaces | replaced-with | retracts | retracted-by | signs | similar-to | supports | supported-with | transforms | transformed-into | transformed-with | documents | specification-of | created-with | cite-as
            #[fhir(
                name = "type",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeDt>,
            /// Additional classifiers
            #[fhir(
                name = "classifier",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub classifier: Option<Vec<CodeableConcept>>,
            /// Short label
            #[fhir(
                name = "label",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub label: Option<StringDt>,
            /// Brief description of the related artifact
            #[fhir(
                name = "display",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub display: Option<StringDt>,
            /// Bibliographic citation for the artifact
            #[fhir(
                name = "citation",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub citation: Option<MarkdownDt>,
            /// What document is being referenced
            #[fhir(
                name = "document",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub document: Option<Attachment>,
            /// What artifact is being referenced
            #[fhir(
                name = "resource",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub resource: Option<CanonicalDt>,
            /// What artifact, if not a conformance resource
            #[fhir(
                name = "resourceReference",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub resource_reference: Option<Reference>,
            /// draft | active | retired | unknown
            #[fhir(
                name = "publicationStatus",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub publication_status: Option<CodeDt>,
            /// Date of publication of the artifact being referred to
            #[fhir(
                name = "publicationDate",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub publication_date: Option<DateDt>,
        }
        impl Element for RelatedArtifact {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for RelatedArtifact {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.type_.is_none()
                    & self.classifier.is_none() & self.label.is_none()
                    & self.display.is_none() & self.citation.is_none()
                    & self.document.is_none() & self.resource.is_none()
                    & self.resource_reference.is_none()
                    & self.publication_status.is_none() & self.publication_date.is_none()
            }
            fn type_name(&self) -> String {
                "RelatedArtifact".to_string()
            }
        }
        impl RelatedArtifact {
            pub fn set_type_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.type_ = Some(v.into());
                self
            }
            pub fn set_classifier(mut self, v: Vec<CodeableConcept>) -> Self {
                self.classifier = Some(v);
                self
            }
            pub fn add_classifier(mut self, v: CodeableConcept) -> Self {
                match self.classifier {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.classifier = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_label<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.label = Some(v.into());
                self
            }
            pub fn set_display<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.display = Some(v.into());
                self
            }
            pub fn set_citation<T: Into<MarkdownDt>>(mut self, v: T) -> Self {
                self.citation = Some(v.into());
                self
            }
            pub fn set_document(mut self, v: Attachment) -> Self {
                self.document = Some(v);
                self
            }
            pub fn set_resource<T: Into<CanonicalDt>>(mut self, v: T) -> Self {
                self.resource = Some(v.into());
                self
            }
            pub fn set_resource_reference(mut self, v: Reference) -> Self {
                self.resource_reference = Some(v);
                self
            }
            pub fn set_publication_status<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.publication_status = Some(v.into());
                self
            }
            pub fn set_publication_date<T: Into<DateDt>>(mut self, v: T) -> Self {
                self.publication_date = Some(v.into());
                self
            }
        }
        impl Serialize for RelatedArtifact {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("classifier", &self.classifier)?;
                serialize_struct.serialize_field("label", &self.label)?;
                serialize_struct.serialize_field("display", &self.display)?;
                serialize_struct.serialize_field("citation", &self.citation)?;
                serialize_struct.serialize_field("document", &self.document)?;
                serialize_struct.serialize_field("resource", &self.resource)?;
                serialize_struct
                    .serialize_field("resourceReference", &self.resource_reference)?;
                serialize_struct
                    .serialize_field("publicationStatus", &self.publication_status)?;
                serialize_struct
                    .serialize_field("publicationDate", &self.publication_date)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for RelatedArtifact {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct RelatedArtifactVisitor;
                impl<'de> Visitor<'de> for RelatedArtifactVisitor {
                    type Value = RelatedArtifact;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<CodeDt> = None;
                        let mut classifier: Option<Vec<CodeableConcept>> = None;
                        let mut label: Option<StringDt> = None;
                        let mut display: Option<StringDt> = None;
                        let mut citation: Option<MarkdownDt> = None;
                        let mut document: Option<Attachment> = None;
                        let mut resource: Option<CanonicalDt> = None;
                        let mut resource_reference: Option<Reference> = None;
                        let mut publication_status: Option<CodeDt> = None;
                        let mut publication_date: Option<DateDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "classifier" => {
                                    classifier = Some(mapp.next_value()?);
                                }
                                "label" => {
                                    label = Some(mapp.next_value()?);
                                }
                                "display" => {
                                    display = Some(mapp.next_value()?);
                                }
                                "citation" => {
                                    citation = Some(mapp.next_value()?);
                                }
                                "document" => {
                                    document = Some(mapp.next_value()?);
                                }
                                "resource" => {
                                    resource = Some(mapp.next_value()?);
                                }
                                "resourceReference" => {
                                    resource_reference = Some(mapp.next_value()?);
                                }
                                "publicationStatus" => {
                                    publication_status = Some(mapp.next_value()?);
                                }
                                "publicationDate" => {
                                    publication_date = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(RelatedArtifact {
                            id,
                            extension,
                            type_,
                            classifier,
                            label,
                            display,
                            citation,
                            document,
                            resource,
                            resource_reference,
                            publication_status,
                            publication_date,
                        })
                    }
                }
                deserializer.deserialize_struct("", RelatedArtifactVisitor)
            }
        }
        impl Executor for RelatedArtifact {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "RelatedArtifact"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "classifier" => self.classifier.exec(&comp),
                            "label" => self.label.exec(&comp),
                            "display" => self.display.exec(&comp),
                            "citation" => self.citation.exec(&comp),
                            "document" => self.document.exec(&comp),
                            "resource" => self.resource.exec(&comp),
                            "resourceReference" => self.resource_reference.exec(&comp),
                            "publicationStatus" => self.publication_status.exec(&comp),
                            "publicationDate" => self.publication_date.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "RelatedArtifact",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RelatedArtifact {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "type_",
                    "classifier",
                    "label",
                    "display",
                    "citation",
                    "document",
                    "resource",
                    "resource_reference",
                    "publication_status",
                    "publication_date",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.type_,
                    &self.classifier,
                    &self.label,
                    &self.display,
                    &self.citation,
                    &self.document,
                    &self.resource,
                    &self.resource_reference,
                    &self.publication_status,
                    &&self.publication_date,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "RelatedArtifact",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RelatedArtifact {
            #[inline]
            fn clone(&self) -> RelatedArtifact {
                RelatedArtifact {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    classifier: ::core::clone::Clone::clone(&self.classifier),
                    label: ::core::clone::Clone::clone(&self.label),
                    display: ::core::clone::Clone::clone(&self.display),
                    citation: ::core::clone::Clone::clone(&self.citation),
                    document: ::core::clone::Clone::clone(&self.document),
                    resource: ::core::clone::Clone::clone(&self.resource),
                    resource_reference: ::core::clone::Clone::clone(
                        &self.resource_reference,
                    ),
                    publication_status: ::core::clone::Clone::clone(
                        &self.publication_status,
                    ),
                    publication_date: ::core::clone::Clone::clone(&self.publication_date),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RelatedArtifact {
            #[inline]
            fn default() -> RelatedArtifact {
                RelatedArtifact {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    classifier: ::core::default::Default::default(),
                    label: ::core::default::Default::default(),
                    display: ::core::default::Default::default(),
                    citation: ::core::default::Default::default(),
                    document: ::core::default::Default::default(),
                    resource: ::core::default::Default::default(),
                    resource_reference: ::core::default::Default::default(),
                    publication_status: ::core::default::Default::default(),
                    publication_date: ::core::default::Default::default(),
                }
            }
        }
        pub struct SampledData {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Zero value and units
            #[fhir(
                name = "origin",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub origin: Option<Quantity>,
            /// Number of intervalUnits between samples
            #[fhir(
                name = "interval",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub interval: Option<DecimalDt>,
            /// The measurement unit of the interval between samples
            #[fhir(
                name = "intervalUnit",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub interval_unit: Option<CodeDt>,
            /// Multiply data by this before adding to origin
            #[fhir(
                name = "factor",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub factor: Option<DecimalDt>,
            /// Lower limit of detection
            #[fhir(
                name = "lowerLimit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub lower_limit: Option<DecimalDt>,
            /// Upper limit of detection
            #[fhir(
                name = "upperLimit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub upper_limit: Option<DecimalDt>,
            /// Number of sample points at each time point
            #[fhir(
                name = "dimensions",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub dimensions: Option<PositiveIntDt>,
            /// Defines the codes used in the data
            #[fhir(
                name = "codeMap",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub code_map: Option<CanonicalDt>,
            /// Offsets, typically in time, at which data values were taken
            #[fhir(
                name = "offsets",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub offsets: Option<StringDt>,
            /// Decimal values with spaces, or "E" | "U" | "L", or another code
            #[fhir(
                name = "data",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub data: Option<StringDt>,
        }
        impl Element for SampledData {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for SampledData {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.origin.is_none()
                    & self.interval.is_none() & self.interval_unit.is_none()
                    & self.factor.is_none() & self.lower_limit.is_none()
                    & self.upper_limit.is_none() & self.dimensions.is_none()
                    & self.code_map.is_none() & self.offsets.is_none()
                    & self.data.is_none()
            }
            fn type_name(&self) -> String {
                "SampledData".to_string()
            }
        }
        impl SampledData {
            pub fn set_origin(mut self, v: Quantity) -> Self {
                self.origin = Some(v);
                self
            }
            pub fn set_interval<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.interval = Some(v.into());
                self
            }
            pub fn set_interval_unit<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.interval_unit = Some(v.into());
                self
            }
            pub fn set_factor<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.factor = Some(v.into());
                self
            }
            pub fn set_lower_limit<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.lower_limit = Some(v.into());
                self
            }
            pub fn set_upper_limit<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.upper_limit = Some(v.into());
                self
            }
            pub fn set_dimensions<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.dimensions = Some(v.into());
                self
            }
            pub fn set_code_map<T: Into<CanonicalDt>>(mut self, v: T) -> Self {
                self.code_map = Some(v.into());
                self
            }
            pub fn set_offsets<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.offsets = Some(v.into());
                self
            }
            pub fn set_data<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.data = Some(v.into());
                self
            }
        }
        impl Serialize for SampledData {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("origin", &self.origin)?;
                serialize_struct.serialize_field("interval", &self.interval)?;
                serialize_struct.serialize_field("intervalUnit", &self.interval_unit)?;
                serialize_struct.serialize_field("factor", &self.factor)?;
                serialize_struct.serialize_field("lowerLimit", &self.lower_limit)?;
                serialize_struct.serialize_field("upperLimit", &self.upper_limit)?;
                serialize_struct.serialize_field("dimensions", &self.dimensions)?;
                serialize_struct.serialize_field("codeMap", &self.code_map)?;
                serialize_struct.serialize_field("offsets", &self.offsets)?;
                serialize_struct.serialize_field("data", &self.data)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for SampledData {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct SampledDataVisitor;
                impl<'de> Visitor<'de> for SampledDataVisitor {
                    type Value = SampledData;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut origin: Option<Quantity> = None;
                        let mut interval: Option<DecimalDt> = None;
                        let mut interval_unit: Option<CodeDt> = None;
                        let mut factor: Option<DecimalDt> = None;
                        let mut lower_limit: Option<DecimalDt> = None;
                        let mut upper_limit: Option<DecimalDt> = None;
                        let mut dimensions: Option<PositiveIntDt> = None;
                        let mut code_map: Option<CanonicalDt> = None;
                        let mut offsets: Option<StringDt> = None;
                        let mut data: Option<StringDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "origin" => {
                                    origin = Some(mapp.next_value()?);
                                }
                                "interval" => {
                                    interval = Some(mapp.next_value()?);
                                }
                                "intervalUnit" => {
                                    interval_unit = Some(mapp.next_value()?);
                                }
                                "factor" => {
                                    factor = Some(mapp.next_value()?);
                                }
                                "lowerLimit" => {
                                    lower_limit = Some(mapp.next_value()?);
                                }
                                "upperLimit" => {
                                    upper_limit = Some(mapp.next_value()?);
                                }
                                "dimensions" => {
                                    dimensions = Some(mapp.next_value()?);
                                }
                                "codeMap" => {
                                    code_map = Some(mapp.next_value()?);
                                }
                                "offsets" => {
                                    offsets = Some(mapp.next_value()?);
                                }
                                "data" => {
                                    data = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(SampledData {
                            id,
                            extension,
                            origin,
                            interval,
                            interval_unit,
                            factor,
                            lower_limit,
                            upper_limit,
                            dimensions,
                            code_map,
                            offsets,
                            data,
                        })
                    }
                }
                deserializer.deserialize_struct("", SampledDataVisitor)
            }
        }
        impl Executor for SampledData {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "SampledData"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "origin" => self.origin.exec(&comp),
                            "interval" => self.interval.exec(&comp),
                            "intervalUnit" => self.interval_unit.exec(&comp),
                            "factor" => self.factor.exec(&comp),
                            "lowerLimit" => self.lower_limit.exec(&comp),
                            "upperLimit" => self.upper_limit.exec(&comp),
                            "dimensions" => self.dimensions.exec(&comp),
                            "codeMap" => self.code_map.exec(&comp),
                            "offsets" => self.offsets.exec(&comp),
                            "data" => self.data.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "SampledData",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SampledData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "origin",
                    "interval",
                    "interval_unit",
                    "factor",
                    "lower_limit",
                    "upper_limit",
                    "dimensions",
                    "code_map",
                    "offsets",
                    "data",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.origin,
                    &self.interval,
                    &self.interval_unit,
                    &self.factor,
                    &self.lower_limit,
                    &self.upper_limit,
                    &self.dimensions,
                    &self.code_map,
                    &self.offsets,
                    &&self.data,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "SampledData",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SampledData {
            #[inline]
            fn clone(&self) -> SampledData {
                SampledData {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    origin: ::core::clone::Clone::clone(&self.origin),
                    interval: ::core::clone::Clone::clone(&self.interval),
                    interval_unit: ::core::clone::Clone::clone(&self.interval_unit),
                    factor: ::core::clone::Clone::clone(&self.factor),
                    lower_limit: ::core::clone::Clone::clone(&self.lower_limit),
                    upper_limit: ::core::clone::Clone::clone(&self.upper_limit),
                    dimensions: ::core::clone::Clone::clone(&self.dimensions),
                    code_map: ::core::clone::Clone::clone(&self.code_map),
                    offsets: ::core::clone::Clone::clone(&self.offsets),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SampledData {
            #[inline]
            fn default() -> SampledData {
                SampledData {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    origin: ::core::default::Default::default(),
                    interval: ::core::default::Default::default(),
                    interval_unit: ::core::default::Default::default(),
                    factor: ::core::default::Default::default(),
                    lower_limit: ::core::default::Default::default(),
                    upper_limit: ::core::default::Default::default(),
                    dimensions: ::core::default::Default::default(),
                    code_map: ::core::default::Default::default(),
                    offsets: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        pub struct Signature {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Indication of the reason the entity signed the object(s)
            #[fhir(
                name = "type",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<Vec<Coding>>,
            /// When the signature was created
            #[fhir(
                name = "when",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub when: Option<InstantDt>,
            /// Who signed
            #[fhir(
                name = "who",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub who: Option<Reference>,
            /// The party represented
            #[fhir(
                name = "onBehalfOf",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub on_behalf_of: Option<Reference>,
            /// The technical format of the signed resources
            #[fhir(
                name = "targetFormat",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub target_format: Option<CodeDt>,
            /// The technical format of the signature
            #[fhir(
                name = "sigFormat",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub sig_format: Option<CodeDt>,
            /// The actual signature content (XML DigSig. JWS, picture, etc.)
            #[fhir(
                name = "data",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub data: Option<Base64BinaryDt>,
        }
        impl Element for Signature {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Signature {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.type_.is_none() & self.when.is_none()
                    & self.who.is_none() & self.on_behalf_of.is_none()
                    & self.target_format.is_none() & self.sig_format.is_none()
                    & self.data.is_none()
            }
            fn type_name(&self) -> String {
                "Signature".to_string()
            }
        }
        impl Signature {
            pub fn set_type_(mut self, v: Vec<Coding>) -> Self {
                self.type_ = Some(v);
                self
            }
            pub fn add_type_(mut self, v: Coding) -> Self {
                match self.type_ {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.type_ = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_when<T: Into<InstantDt>>(mut self, v: T) -> Self {
                self.when = Some(v.into());
                self
            }
            pub fn set_who(mut self, v: Reference) -> Self {
                self.who = Some(v);
                self
            }
            pub fn set_on_behalf_of(mut self, v: Reference) -> Self {
                self.on_behalf_of = Some(v);
                self
            }
            pub fn set_target_format<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.target_format = Some(v.into());
                self
            }
            pub fn set_sig_format<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.sig_format = Some(v.into());
                self
            }
            pub fn set_data<T: Into<Base64BinaryDt>>(mut self, v: T) -> Self {
                self.data = Some(v.into());
                self
            }
        }
        impl Serialize for Signature {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("when", &self.when)?;
                serialize_struct.serialize_field("who", &self.who)?;
                serialize_struct.serialize_field("onBehalfOf", &self.on_behalf_of)?;
                serialize_struct.serialize_field("targetFormat", &self.target_format)?;
                serialize_struct.serialize_field("sigFormat", &self.sig_format)?;
                serialize_struct.serialize_field("data", &self.data)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Signature {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct SignatureVisitor;
                impl<'de> Visitor<'de> for SignatureVisitor {
                    type Value = Signature;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<Vec<Coding>> = None;
                        let mut when: Option<InstantDt> = None;
                        let mut who: Option<Reference> = None;
                        let mut on_behalf_of: Option<Reference> = None;
                        let mut target_format: Option<CodeDt> = None;
                        let mut sig_format: Option<CodeDt> = None;
                        let mut data: Option<Base64BinaryDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "when" => {
                                    when = Some(mapp.next_value()?);
                                }
                                "who" => {
                                    who = Some(mapp.next_value()?);
                                }
                                "onBehalfOf" => {
                                    on_behalf_of = Some(mapp.next_value()?);
                                }
                                "targetFormat" => {
                                    target_format = Some(mapp.next_value()?);
                                }
                                "sigFormat" => {
                                    sig_format = Some(mapp.next_value()?);
                                }
                                "data" => {
                                    data = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Signature {
                            id,
                            extension,
                            type_,
                            when,
                            who,
                            on_behalf_of,
                            target_format,
                            sig_format,
                            data,
                        })
                    }
                }
                deserializer.deserialize_struct("", SignatureVisitor)
            }
        }
        impl Executor for Signature {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Signature"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "when" => self.when.exec(&comp),
                            "who" => self.who.exec(&comp),
                            "onBehalfOf" => self.on_behalf_of.exec(&comp),
                            "targetFormat" => self.target_format.exec(&comp),
                            "sigFormat" => self.sig_format.exec(&comp),
                            "data" => self.data.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Signature",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Signature {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "type_",
                    "when",
                    "who",
                    "on_behalf_of",
                    "target_format",
                    "sig_format",
                    "data",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.type_,
                    &self.when,
                    &self.who,
                    &self.on_behalf_of,
                    &self.target_format,
                    &self.sig_format,
                    &&self.data,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Signature",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Signature {
            #[inline]
            fn clone(&self) -> Signature {
                Signature {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    when: ::core::clone::Clone::clone(&self.when),
                    who: ::core::clone::Clone::clone(&self.who),
                    on_behalf_of: ::core::clone::Clone::clone(&self.on_behalf_of),
                    target_format: ::core::clone::Clone::clone(&self.target_format),
                    sig_format: ::core::clone::Clone::clone(&self.sig_format),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Signature {
            #[inline]
            fn default() -> Signature {
                Signature {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    when: ::core::default::Default::default(),
                    who: ::core::default::Default::default(),
                    on_behalf_of: ::core::default::Default::default(),
                    target_format: ::core::default::Default::default(),
                    sig_format: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        pub struct Timing {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Extensions that cannot be ignored even if unrecognized
            #[fhir(
                name = "modifierExtension",
                min = "0",
                max = "*",
                summary = true,
                modifier = true
            )]
            pub modifier_extension: Option<Vec<Extension>>,
            /// When the event occurs
            #[fhir(
                name = "event",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub event: Option<Vec<DateTimeDt>>,
            /// When the event is to occur
            #[fhir(
                name = "repeat",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub repeat: Option<TimingRepeatElement>,
            /// C | BID | TID | QID | AM | PM | QD | QOD | +
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeableConcept>,
        }
        impl Element for Timing {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for Timing {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.modifier_extension.is_none()
                    & self.event.is_none() & self.repeat.is_none() & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "Timing".to_string()
            }
        }
        impl Timing {
            pub fn set_modifier_extension(mut self, v: Vec<Extension>) -> Self {
                self.modifier_extension = Some(v);
                self
            }
            pub fn add_modifier_extension(mut self, v: Extension) -> Self {
                match self.modifier_extension {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.modifier_extension = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_event(mut self, v: Vec<DateTimeDt>) -> Self {
                self.event = Some(v);
                self
            }
            pub fn add_event<T: Into<DateTimeDt>>(mut self, v: T) -> Self {
                match self.event {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.event = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_repeat(mut self, v: TimingRepeatElement) -> Self {
                self.repeat = Some(v);
                self
            }
            pub fn set_code(mut self, v: CodeableConcept) -> Self {
                self.code = Some(v);
                self
            }
        }
        impl Serialize for Timing {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct
                    .serialize_field("modifierExtension", &self.modifier_extension)?;
                serialize_struct.serialize_field("event", &self.event)?;
                serialize_struct.serialize_field("repeat", &self.repeat)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for Timing {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct TimingVisitor;
                impl<'de> Visitor<'de> for TimingVisitor {
                    type Value = Timing;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut modifier_extension: Option<Vec<Extension>> = None;
                        let mut event: Option<Vec<DateTimeDt>> = None;
                        let mut repeat: Option<TimingRepeatElement> = None;
                        let mut code: Option<CodeableConcept> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "modifierExtension" => {
                                    modifier_extension = Some(mapp.next_value()?);
                                }
                                "event" => {
                                    event = Some(mapp.next_value()?);
                                }
                                "repeat" => {
                                    repeat = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(Timing {
                            id,
                            extension,
                            modifier_extension,
                            event,
                            repeat,
                            code,
                        })
                    }
                }
                deserializer.deserialize_struct("", TimingVisitor)
            }
        }
        impl Executor for Timing {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "Timing"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "modifierExtension" => self.modifier_extension.exec(&comp),
                            "event" => self.event.exec(&comp),
                            "repeat" => self.repeat.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "Timing",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Timing {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "modifier_extension",
                    "event",
                    "repeat",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.modifier_extension,
                    &self.event,
                    &self.repeat,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Timing",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Timing {
            #[inline]
            fn clone(&self) -> Timing {
                Timing {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    modifier_extension: ::core::clone::Clone::clone(
                        &self.modifier_extension,
                    ),
                    event: ::core::clone::Clone::clone(&self.event),
                    repeat: ::core::clone::Clone::clone(&self.repeat),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Timing {
            #[inline]
            fn default() -> Timing {
                Timing {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    modifier_extension: ::core::default::Default::default(),
                    event: ::core::default::Default::default(),
                    repeat: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
        pub struct TimingRepeatElement {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<String>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Length/Range of lengths, or (Start and/or end) limits
            #[fhir(
                name = "bounds",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub bounds: Option<Period>,
            /// Number of times to repeat
            #[fhir(
                name = "count",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub count: Option<PositiveIntDt>,
            /// Maximum number of times to repeat
            #[fhir(
                name = "countMax",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub count_max: Option<PositiveIntDt>,
            /// How long when it happens
            #[fhir(
                name = "duration",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub duration: Option<DecimalDt>,
            /// How long when it happens (Max)
            #[fhir(
                name = "durationMax",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub duration_max: Option<DecimalDt>,
            /// s | min | h | d | wk | mo | a - unit of time (UCUM)
            #[fhir(
                name = "durationUnit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub duration_unit: Option<CodeDt>,
            /// Indicates the number of repetitions that should occur within a period. I.e. Event occurs frequency times per period
            #[fhir(
                name = "frequency",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub frequency: Option<PositiveIntDt>,
            /// Event occurs up to frequencyMax times per period
            #[fhir(
                name = "frequencyMax",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub frequency_max: Option<PositiveIntDt>,
            /// The duration to which the frequency applies. I.e. Event occurs frequency times per period
            #[fhir(
                name = "period",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period: Option<DecimalDt>,
            /// Upper limit of period (3-4 hours)
            #[fhir(
                name = "periodMax",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period_max: Option<DecimalDt>,
            /// s | min | h | d | wk | mo | a - unit of time (UCUM)
            #[fhir(
                name = "periodUnit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub period_unit: Option<CodeDt>,
            /// mon | tue | wed | thu | fri | sat | sun
            #[fhir(
                name = "dayOfWeek",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub day_of_week: Option<Vec<CodeDt>>,
            /// Time of day for action
            #[fhir(
                name = "timeOfDay",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub time_of_day: Option<Vec<TimeDt>>,
            /// Code for time period of occurrence
            #[fhir(
                name = "when",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub when: Option<Vec<CodeDt>>,
            /// Minutes from event (before or after)
            #[fhir(
                name = "offset",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub offset: Option<UnsignedIntDt>,
        }
        impl Element for TimingRepeatElement {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for TimingRepeatElement {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.bounds.is_none() & self.count.is_none()
                    & self.count_max.is_none() & self.duration.is_none()
                    & self.duration_max.is_none() & self.duration_unit.is_none()
                    & self.frequency.is_none() & self.frequency_max.is_none()
                    & self.period.is_none() & self.period_max.is_none()
                    & self.period_unit.is_none() & self.day_of_week.is_none()
                    & self.time_of_day.is_none() & self.when.is_none()
                    & self.offset.is_none()
            }
            fn type_name(&self) -> String {
                "TimingRepeatElement".to_string()
            }
        }
        impl TimingRepeatElement {
            pub fn set_bounds(mut self, v: Period) -> Self {
                self.bounds = Some(v);
                self
            }
            pub fn set_count<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.count = Some(v.into());
                self
            }
            pub fn set_count_max<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.count_max = Some(v.into());
                self
            }
            pub fn set_duration<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.duration = Some(v.into());
                self
            }
            pub fn set_duration_max<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.duration_max = Some(v.into());
                self
            }
            pub fn set_duration_unit<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.duration_unit = Some(v.into());
                self
            }
            pub fn set_frequency<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.frequency = Some(v.into());
                self
            }
            pub fn set_frequency_max<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.frequency_max = Some(v.into());
                self
            }
            pub fn set_period<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.period = Some(v.into());
                self
            }
            pub fn set_period_max<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.period_max = Some(v.into());
                self
            }
            pub fn set_period_unit<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.period_unit = Some(v.into());
                self
            }
            pub fn set_day_of_week(mut self, v: Vec<CodeDt>) -> Self {
                self.day_of_week = Some(v);
                self
            }
            pub fn add_day_of_week<T: Into<CodeDt>>(mut self, v: T) -> Self {
                match self.day_of_week {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.day_of_week = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_time_of_day(mut self, v: Vec<TimeDt>) -> Self {
                self.time_of_day = Some(v);
                self
            }
            pub fn add_time_of_day<T: Into<TimeDt>>(mut self, v: T) -> Self {
                match self.time_of_day {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.time_of_day = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_when(mut self, v: Vec<CodeDt>) -> Self {
                self.when = Some(v);
                self
            }
            pub fn add_when<T: Into<CodeDt>>(mut self, v: T) -> Self {
                match self.when {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.when = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_offset<T: Into<UnsignedIntDt>>(mut self, v: T) -> Self {
                self.offset = Some(v.into());
                self
            }
        }
        impl Serialize for TimingRepeatElement {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("bounds", &self.bounds)?;
                serialize_struct.serialize_field("count", &self.count)?;
                serialize_struct.serialize_field("countMax", &self.count_max)?;
                serialize_struct.serialize_field("duration", &self.duration)?;
                serialize_struct.serialize_field("durationMax", &self.duration_max)?;
                serialize_struct.serialize_field("durationUnit", &self.duration_unit)?;
                serialize_struct.serialize_field("frequency", &self.frequency)?;
                serialize_struct.serialize_field("frequencyMax", &self.frequency_max)?;
                serialize_struct.serialize_field("period", &self.period)?;
                serialize_struct.serialize_field("periodMax", &self.period_max)?;
                serialize_struct.serialize_field("periodUnit", &self.period_unit)?;
                serialize_struct.serialize_field("dayOfWeek", &self.day_of_week)?;
                serialize_struct.serialize_field("timeOfDay", &self.time_of_day)?;
                serialize_struct.serialize_field("when", &self.when)?;
                serialize_struct.serialize_field("offset", &self.offset)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for TimingRepeatElement {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct TimingRepeatElementVisitor;
                impl<'de> Visitor<'de> for TimingRepeatElementVisitor {
                    type Value = TimingRepeatElement;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<String> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut bounds: Option<Period> = None;
                        let mut count: Option<PositiveIntDt> = None;
                        let mut count_max: Option<PositiveIntDt> = None;
                        let mut duration: Option<DecimalDt> = None;
                        let mut duration_max: Option<DecimalDt> = None;
                        let mut duration_unit: Option<CodeDt> = None;
                        let mut frequency: Option<PositiveIntDt> = None;
                        let mut frequency_max: Option<PositiveIntDt> = None;
                        let mut period: Option<DecimalDt> = None;
                        let mut period_max: Option<DecimalDt> = None;
                        let mut period_unit: Option<CodeDt> = None;
                        let mut day_of_week: Option<Vec<CodeDt>> = None;
                        let mut time_of_day: Option<Vec<TimeDt>> = None;
                        let mut when: Option<Vec<CodeDt>> = None;
                        let mut offset: Option<UnsignedIntDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "bounds" => {
                                    bounds = Some(mapp.next_value()?);
                                }
                                "count" => {
                                    count = Some(mapp.next_value()?);
                                }
                                "countMax" => {
                                    count_max = Some(mapp.next_value()?);
                                }
                                "duration" => {
                                    duration = Some(mapp.next_value()?);
                                }
                                "durationMax" => {
                                    duration_max = Some(mapp.next_value()?);
                                }
                                "durationUnit" => {
                                    duration_unit = Some(mapp.next_value()?);
                                }
                                "frequency" => {
                                    frequency = Some(mapp.next_value()?);
                                }
                                "frequencyMax" => {
                                    frequency_max = Some(mapp.next_value()?);
                                }
                                "period" => {
                                    period = Some(mapp.next_value()?);
                                }
                                "periodMax" => {
                                    period_max = Some(mapp.next_value()?);
                                }
                                "periodUnit" => {
                                    period_unit = Some(mapp.next_value()?);
                                }
                                "dayOfWeek" => {
                                    day_of_week = Some(mapp.next_value()?);
                                }
                                "timeOfDay" => {
                                    time_of_day = Some(mapp.next_value()?);
                                }
                                "when" => {
                                    when = Some(mapp.next_value()?);
                                }
                                "offset" => {
                                    offset = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(TimingRepeatElement {
                            id,
                            extension,
                            bounds,
                            count,
                            count_max,
                            duration,
                            duration_max,
                            duration_unit,
                            frequency,
                            frequency_max,
                            period,
                            period_max,
                            period_unit,
                            day_of_week,
                            time_of_day,
                            when,
                            offset,
                        })
                    }
                }
                deserializer.deserialize_struct("", TimingRepeatElementVisitor)
            }
        }
        impl Executor for TimingRepeatElement {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "TimingRepeatElement",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "bounds" => self.bounds.exec(&comp),
                            "count" => self.count.exec(&comp),
                            "countMax" => self.count_max.exec(&comp),
                            "duration" => self.duration.exec(&comp),
                            "durationMax" => self.duration_max.exec(&comp),
                            "durationUnit" => self.duration_unit.exec(&comp),
                            "frequency" => self.frequency.exec(&comp),
                            "frequencyMax" => self.frequency_max.exec(&comp),
                            "period" => self.period.exec(&comp),
                            "periodMax" => self.period_max.exec(&comp),
                            "periodUnit" => self.period_unit.exec(&comp),
                            "dayOfWeek" => self.day_of_week.exec(&comp),
                            "timeOfDay" => self.time_of_day.exec(&comp),
                            "when" => self.when.exec(&comp),
                            "offset" => self.offset.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "TimingRepeatElement",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TimingRepeatElement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "bounds",
                    "count",
                    "count_max",
                    "duration",
                    "duration_max",
                    "duration_unit",
                    "frequency",
                    "frequency_max",
                    "period",
                    "period_max",
                    "period_unit",
                    "day_of_week",
                    "time_of_day",
                    "when",
                    "offset",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.bounds,
                    &self.count,
                    &self.count_max,
                    &self.duration,
                    &self.duration_max,
                    &self.duration_unit,
                    &self.frequency,
                    &self.frequency_max,
                    &self.period,
                    &self.period_max,
                    &self.period_unit,
                    &self.day_of_week,
                    &self.time_of_day,
                    &self.when,
                    &&self.offset,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "TimingRepeatElement",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TimingRepeatElement {
            #[inline]
            fn clone(&self) -> TimingRepeatElement {
                TimingRepeatElement {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    bounds: ::core::clone::Clone::clone(&self.bounds),
                    count: ::core::clone::Clone::clone(&self.count),
                    count_max: ::core::clone::Clone::clone(&self.count_max),
                    duration: ::core::clone::Clone::clone(&self.duration),
                    duration_max: ::core::clone::Clone::clone(&self.duration_max),
                    duration_unit: ::core::clone::Clone::clone(&self.duration_unit),
                    frequency: ::core::clone::Clone::clone(&self.frequency),
                    frequency_max: ::core::clone::Clone::clone(&self.frequency_max),
                    period: ::core::clone::Clone::clone(&self.period),
                    period_max: ::core::clone::Clone::clone(&self.period_max),
                    period_unit: ::core::clone::Clone::clone(&self.period_unit),
                    day_of_week: ::core::clone::Clone::clone(&self.day_of_week),
                    time_of_day: ::core::clone::Clone::clone(&self.time_of_day),
                    when: ::core::clone::Clone::clone(&self.when),
                    offset: ::core::clone::Clone::clone(&self.offset),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for TimingRepeatElement {
            #[inline]
            fn default() -> TimingRepeatElement {
                TimingRepeatElement {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    bounds: ::core::default::Default::default(),
                    count: ::core::default::Default::default(),
                    count_max: ::core::default::Default::default(),
                    duration: ::core::default::Default::default(),
                    duration_max: ::core::default::Default::default(),
                    duration_unit: ::core::default::Default::default(),
                    frequency: ::core::default::Default::default(),
                    frequency_max: ::core::default::Default::default(),
                    period: ::core::default::Default::default(),
                    period_max: ::core::default::Default::default(),
                    period_unit: ::core::default::Default::default(),
                    day_of_week: ::core::default::Default::default(),
                    time_of_day: ::core::default::Default::default(),
                    when: ::core::default::Default::default(),
                    offset: ::core::default::Default::default(),
                }
            }
        }
        pub struct TriggerDefinition {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended
            #[fhir(
                name = "type",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub type_: Option<CodeDt>,
            /// Name or URI that identifies the event
            #[fhir(
                name = "name",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub name: Option<StringDt>,
            /// Coded definition of the event
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeableConcept>,
            /// What event
            #[fhir(
                name = "subscriptionTopic",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub subscription_topic: Option<CanonicalDt>,
            /// Timing of the event
            #[fhir(
                name = "timing",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub timing: Option<DateTimeDt>,
            /// Triggering data of the event (multiple = 'and')
            #[fhir(
                name = "data",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub data: Option<Vec<DataRequirement>>,
            /// Whether the event triggers (boolean expression)
            #[fhir(
                name = "condition",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub condition: Option<Expression>,
        }
        impl Element for TriggerDefinition {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for TriggerDefinition {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.type_.is_none() & self.name.is_none()
                    & self.code.is_none() & self.subscription_topic.is_none()
                    & self.timing.is_none() & self.data.is_none()
                    & self.condition.is_none()
            }
            fn type_name(&self) -> String {
                "TriggerDefinition".to_string()
            }
        }
        impl TriggerDefinition {
            pub fn set_type_<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.type_ = Some(v.into());
                self
            }
            pub fn set_name<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.name = Some(v.into());
                self
            }
            pub fn set_code(mut self, v: CodeableConcept) -> Self {
                self.code = Some(v);
                self
            }
            pub fn set_subscription_topic<T: Into<CanonicalDt>>(mut self, v: T) -> Self {
                self.subscription_topic = Some(v.into());
                self
            }
            pub fn set_timing<T: Into<DateTimeDt>>(mut self, v: T) -> Self {
                self.timing = Some(v.into());
                self
            }
            pub fn set_data(mut self, v: Vec<DataRequirement>) -> Self {
                self.data = Some(v);
                self
            }
            pub fn add_data(mut self, v: DataRequirement) -> Self {
                match self.data {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v);
                        self.data = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v);
                    }
                }
                self
            }
            pub fn set_condition(mut self, v: Expression) -> Self {
                self.condition = Some(v);
                self
            }
        }
        impl Serialize for TriggerDefinition {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("type", &self.type_)?;
                serialize_struct.serialize_field("name", &self.name)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct
                    .serialize_field("subscriptionTopic", &self.subscription_topic)?;
                serialize_struct.serialize_field("timing", &self.timing)?;
                serialize_struct.serialize_field("data", &self.data)?;
                serialize_struct.serialize_field("condition", &self.condition)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for TriggerDefinition {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct TriggerDefinitionVisitor;
                impl<'de> Visitor<'de> for TriggerDefinitionVisitor {
                    type Value = TriggerDefinition;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut type_: Option<CodeDt> = None;
                        let mut name: Option<StringDt> = None;
                        let mut code: Option<CodeableConcept> = None;
                        let mut subscription_topic: Option<CanonicalDt> = None;
                        let mut timing: Option<DateTimeDt> = None;
                        let mut data: Option<Vec<DataRequirement>> = None;
                        let mut condition: Option<Expression> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "type" => {
                                    type_ = Some(mapp.next_value()?);
                                }
                                "name" => {
                                    name = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                "subscriptionTopic" => {
                                    subscription_topic = Some(mapp.next_value()?);
                                }
                                "timing" => {
                                    timing = Some(mapp.next_value()?);
                                }
                                "data" => {
                                    data = Some(mapp.next_value()?);
                                }
                                "condition" => {
                                    condition = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(TriggerDefinition {
                            id,
                            extension,
                            type_,
                            name,
                            code,
                            subscription_topic,
                            timing,
                            data,
                            condition,
                        })
                    }
                }
                deserializer.deserialize_struct("", TriggerDefinitionVisitor)
            }
        }
        impl Executor for TriggerDefinition {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "TriggerDefinition",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "type" => self.type_.exec(&comp),
                            "name" => self.name.exec(&comp),
                            "code" => self.code.exec(&comp),
                            "subscriptionTopic" => self.subscription_topic.exec(&comp),
                            "timing" => self.timing.exec(&comp),
                            "data" => self.data.exec(&comp),
                            "condition" => self.condition.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "TriggerDefinition",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TriggerDefinition {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "type_",
                    "name",
                    "code",
                    "subscription_topic",
                    "timing",
                    "data",
                    "condition",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.type_,
                    &self.name,
                    &self.code,
                    &self.subscription_topic,
                    &self.timing,
                    &self.data,
                    &&self.condition,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "TriggerDefinition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TriggerDefinition {
            #[inline]
            fn clone(&self) -> TriggerDefinition {
                TriggerDefinition {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    type_: ::core::clone::Clone::clone(&self.type_),
                    name: ::core::clone::Clone::clone(&self.name),
                    code: ::core::clone::Clone::clone(&self.code),
                    subscription_topic: ::core::clone::Clone::clone(
                        &self.subscription_topic,
                    ),
                    timing: ::core::clone::Clone::clone(&self.timing),
                    data: ::core::clone::Clone::clone(&self.data),
                    condition: ::core::clone::Clone::clone(&self.condition),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for TriggerDefinition {
            #[inline]
            fn default() -> TriggerDefinition {
                TriggerDefinition {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    type_: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                    subscription_topic: ::core::default::Default::default(),
                    timing: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                    condition: ::core::default::Default::default(),
                }
            }
        }
        pub struct UsageContext {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Type of context being specified
            #[fhir(
                name = "code",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<Coding>,
            /// Value that defines the context
            #[fhir(
                name = "value",
                min = "1",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<Reference>,
        }
        impl Element for UsageContext {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for UsageContext {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.code.is_none() & self.value.is_none()
            }
            fn type_name(&self) -> String {
                "UsageContext".to_string()
            }
        }
        impl UsageContext {
            pub fn set_code(mut self, v: Coding) -> Self {
                self.code = Some(v);
                self
            }
            pub fn set_value(mut self, v: Reference) -> Self {
                self.value = Some(v);
                self
            }
        }
        impl Serialize for UsageContext {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for UsageContext {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct UsageContextVisitor;
                impl<'de> Visitor<'de> for UsageContextVisitor {
                    type Value = UsageContext;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut code: Option<Coding> = None;
                        let mut value: Option<Reference> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(UsageContext {
                            id,
                            extension,
                            code,
                            value,
                        })
                    }
                }
                deserializer.deserialize_struct("", UsageContextVisitor)
            }
        }
        impl Executor for UsageContext {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "UsageContext"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "code" => self.code.exec(&comp),
                            "value" => self.value.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "UsageContext",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UsageContext {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "UsageContext",
                    "id",
                    &self.id,
                    "extension",
                    &self.extension,
                    "code",
                    &self.code,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UsageContext {
            #[inline]
            fn clone(&self) -> UsageContext {
                UsageContext {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    code: ::core::clone::Clone::clone(&self.code),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for UsageContext {
            #[inline]
            fn default() -> UsageContext {
                UsageContext {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        pub struct VirtualServiceDetail {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Channel Type
            #[fhir(
                name = "channelType",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub channel_type: Option<Coding>,
            /// Contact address/number
            #[fhir(
                name = "address",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub address: Option<ExtendedContactDetail>,
            /// Address to see alternative connection details
            #[fhir(
                name = "additionalInfo",
                min = "0",
                max = "*",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub additional_info: Option<Vec<UrlDt>>,
            /// Maximum number of participants supported by the virtual service
            #[fhir(
                name = "maxParticipants",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub max_participants: Option<PositiveIntDt>,
            /// Session Key required by the virtual service
            #[fhir(
                name = "sessionKey",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub session_key: Option<StringDt>,
        }
        impl Element for VirtualServiceDetail {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for VirtualServiceDetail {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.channel_type.is_none()
                    & self.address.is_none() & self.additional_info.is_none()
                    & self.max_participants.is_none() & self.session_key.is_none()
            }
            fn type_name(&self) -> String {
                "VirtualServiceDetail".to_string()
            }
        }
        impl VirtualServiceDetail {
            pub fn set_channel_type(mut self, v: Coding) -> Self {
                self.channel_type = Some(v);
                self
            }
            pub fn set_address(mut self, v: ExtendedContactDetail) -> Self {
                self.address = Some(v);
                self
            }
            pub fn set_additional_info(mut self, v: Vec<UrlDt>) -> Self {
                self.additional_info = Some(v);
                self
            }
            pub fn add_additional_info<T: Into<UrlDt>>(mut self, v: T) -> Self {
                match self.additional_info {
                    None => {
                        let mut vec = Vec::new();
                        vec.push(v.into());
                        self.additional_info = Some(vec);
                    }
                    Some(ref mut vec) => {
                        vec.push(v.into());
                    }
                }
                self
            }
            pub fn set_max_participants<T: Into<PositiveIntDt>>(mut self, v: T) -> Self {
                self.max_participants = Some(v.into());
                self
            }
            pub fn set_session_key<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.session_key = Some(v.into());
                self
            }
        }
        impl Serialize for VirtualServiceDetail {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("channelType", &self.channel_type)?;
                serialize_struct.serialize_field("address", &self.address)?;
                serialize_struct
                    .serialize_field("additionalInfo", &self.additional_info)?;
                serialize_struct
                    .serialize_field("maxParticipants", &self.max_participants)?;
                serialize_struct.serialize_field("sessionKey", &self.session_key)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for VirtualServiceDetail {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct VirtualServiceDetailVisitor;
                impl<'de> Visitor<'de> for VirtualServiceDetailVisitor {
                    type Value = VirtualServiceDetail;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut channel_type: Option<Coding> = None;
                        let mut address: Option<ExtendedContactDetail> = None;
                        let mut additional_info: Option<Vec<UrlDt>> = None;
                        let mut max_participants: Option<PositiveIntDt> = None;
                        let mut session_key: Option<StringDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "channelType" => {
                                    channel_type = Some(mapp.next_value()?);
                                }
                                "address" => {
                                    address = Some(mapp.next_value()?);
                                }
                                "additionalInfo" => {
                                    additional_info = Some(mapp.next_value()?);
                                }
                                "maxParticipants" => {
                                    max_participants = Some(mapp.next_value()?);
                                }
                                "sessionKey" => {
                                    session_key = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(VirtualServiceDetail {
                            id,
                            extension,
                            channel_type,
                            address,
                            additional_info,
                            max_participants,
                            session_key,
                        })
                    }
                }
                deserializer.deserialize_struct("", VirtualServiceDetailVisitor)
            }
        }
        impl Executor for VirtualServiceDetail {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}: Start Exec Fhirpath...\n",
                            "VirtualServiceDetail",
                        ),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "channelType" => self.channel_type.exec(&comp),
                            "address" => self.address.exec(&comp),
                            "additionalInfo" => self.additional_info.exec(&comp),
                            "maxParticipants" => self.max_participants.exec(&comp),
                            "sessionKey" => self.session_key.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "VirtualServiceDetail",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for VirtualServiceDetail {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "channel_type",
                    "address",
                    "additional_info",
                    "max_participants",
                    "session_key",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.channel_type,
                    &self.address,
                    &self.additional_info,
                    &self.max_participants,
                    &&self.session_key,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "VirtualServiceDetail",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for VirtualServiceDetail {
            #[inline]
            fn clone(&self) -> VirtualServiceDetail {
                VirtualServiceDetail {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    channel_type: ::core::clone::Clone::clone(&self.channel_type),
                    address: ::core::clone::Clone::clone(&self.address),
                    additional_info: ::core::clone::Clone::clone(&self.additional_info),
                    max_participants: ::core::clone::Clone::clone(
                        &self.max_participants,
                    ),
                    session_key: ::core::clone::Clone::clone(&self.session_key),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for VirtualServiceDetail {
            #[inline]
            fn default() -> VirtualServiceDetail {
                VirtualServiceDetail {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    channel_type: ::core::default::Default::default(),
                    address: ::core::default::Default::default(),
                    additional_info: ::core::default::Default::default(),
                    max_participants: ::core::default::Default::default(),
                    session_key: ::core::default::Default::default(),
                }
            }
        }
        pub struct MoneyQuantity {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerical value (with implicit precision)
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DecimalDt>,
            /// < | <= | >= | > | ad - how to understand the value
            #[fhir(
                name = "comparator",
                min = "0",
                max = "1",
                summary = true,
                modifier = true
            )]
            pub comparator: Option<CodeDt>,
            /// Unit representation
            #[fhir(
                name = "unit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub unit: Option<StringDt>,
            /// System that defines coded unit form
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// Coded form of the unit
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeDt>,
        }
        impl Element for MoneyQuantity {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for MoneyQuantity {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.value.is_none()
                    & self.comparator.is_none() & self.unit.is_none()
                    & self.system.is_none() & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "MoneyQuantity".to_string()
            }
        }
        impl MoneyQuantity {
            pub fn set_value<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_comparator<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.comparator = Some(v.into());
                self
            }
            pub fn set_unit<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.unit = Some(v.into());
                self
            }
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_code<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.code = Some(v.into());
                self
            }
        }
        impl Serialize for MoneyQuantity {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("comparator", &self.comparator)?;
                serialize_struct.serialize_field("unit", &self.unit)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for MoneyQuantity {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct MoneyQuantityVisitor;
                impl<'de> Visitor<'de> for MoneyQuantityVisitor {
                    type Value = MoneyQuantity;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DecimalDt> = None;
                        let mut comparator: Option<CodeDt> = None;
                        let mut unit: Option<StringDt> = None;
                        let mut system: Option<UriDt> = None;
                        let mut code: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "comparator" => {
                                    comparator = Some(mapp.next_value()?);
                                }
                                "unit" => {
                                    unit = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(MoneyQuantity {
                            id,
                            extension,
                            value,
                            comparator,
                            unit,
                            system,
                            code,
                        })
                    }
                }
                deserializer.deserialize_struct("", MoneyQuantityVisitor)
            }
        }
        impl Executor for MoneyQuantity {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "MoneyQuantity"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "comparator" => self.comparator.exec(&comp),
                            "unit" => self.unit.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "MoneyQuantity",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MoneyQuantity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "value",
                    "comparator",
                    "unit",
                    "system",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.value,
                    &self.comparator,
                    &self.unit,
                    &self.system,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "MoneyQuantity",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MoneyQuantity {
            #[inline]
            fn clone(&self) -> MoneyQuantity {
                MoneyQuantity {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                    comparator: ::core::clone::Clone::clone(&self.comparator),
                    unit: ::core::clone::Clone::clone(&self.unit),
                    system: ::core::clone::Clone::clone(&self.system),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MoneyQuantity {
            #[inline]
            fn default() -> MoneyQuantity {
                MoneyQuantity {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    comparator: ::core::default::Default::default(),
                    unit: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
        pub struct SimpleQuantity {
            /// Unique id for inter-element referencing
            #[fhir(
                name = "id",
                min = "0",
                max = "1",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub id: Option<Id>,
            /// Additional content defined by implementations
            #[fhir(
                name = "extension",
                min = "0",
                max = "*",
                summary = false,
                modifier = false,
                choice = ""
            )]
            pub extension: Option<Vec<Extension>>,
            /// Numerical value (with implicit precision)
            #[fhir(
                name = "value",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub value: Option<DecimalDt>,
            /// < | <= | >= | > | ad - how to understand the value
            #[fhir(
                name = "comparator",
                min = "0",
                max = "0",
                summary = true,
                modifier = true
            )]
            pub comparator: Option<CodeDt>,
            /// Unit representation
            #[fhir(
                name = "unit",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub unit: Option<StringDt>,
            /// System that defines coded unit form
            #[fhir(
                name = "system",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub system: Option<UriDt>,
            /// Coded form of the unit
            #[fhir(
                name = "code",
                min = "0",
                max = "1",
                summary = true,
                modifier = false,
                choice = ""
            )]
            pub code: Option<CodeDt>,
        }
        impl Element for SimpleQuantity {
            fn has_id(&self) -> bool {
                self.id.is_some()
            }
            fn id(&self) -> &Option<String> {
                &self.id
            }
            fn set_id<T: Into<String>>(mut self, id: T) -> Self {
                self.id = Some(id.into());
                self
            }
            fn has_extension(&self) -> bool {
                self.extension.is_some()
            }
            fn extension(&self) -> &Option<Vec<Extension>> {
                &self.extension
            }
            fn set_extension(mut self, ext: Vec<Extension>) -> Self {
                self.extension = Some(ext);
                self
            }
            fn add_extension(mut self, ext: Extension) -> Self {
                match self.extension {
                    Some(ref mut exts) => {
                        exts.push(ext);
                    }
                    None => {
                        self
                            .extension = Some(
                            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                        );
                    }
                }
                self
            }
        }
        impl Base for SimpleQuantity {
            fn is_empty(&self) -> bool {
                self.extension.is_none() & self.value.is_none()
                    & self.comparator.is_none() & self.unit.is_none()
                    & self.system.is_none() & self.code.is_none()
            }
            fn type_name(&self) -> String {
                "SimpleQuantity".to_string()
            }
        }
        impl SimpleQuantity {
            pub fn set_value<T: Into<DecimalDt>>(mut self, v: T) -> Self {
                self.value = Some(v.into());
                self
            }
            pub fn set_comparator<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.comparator = Some(v.into());
                self
            }
            pub fn set_unit<T: Into<StringDt>>(mut self, v: T) -> Self {
                self.unit = Some(v.into());
                self
            }
            pub fn set_system<T: Into<UriDt>>(mut self, v: T) -> Self {
                self.system = Some(v.into());
                self
            }
            pub fn set_code<T: Into<CodeDt>>(mut self, v: T) -> Self {
                self.code = Some(v.into());
                self
            }
        }
        impl Serialize for SimpleQuantity {
            fn serialize<Ser: Serializer>(&self, serializer: Ser) -> Result<()> {
                let mut serialize_struct = serializer.serialize_struct("")?;
                serialize_struct.serialize_id(&self.id)?;
                serialize_struct.serialize_extension(&self.extension)?;
                serialize_struct.serialize_field("value", &self.value)?;
                serialize_struct.serialize_field("comparator", &self.comparator)?;
                serialize_struct.serialize_field("unit", &self.unit)?;
                serialize_struct.serialize_field("system", &self.system)?;
                serialize_struct.serialize_field("code", &self.code)?;
                serialize_struct.serialize_end()
            }
        }
        impl<'de> Deserialize<'de> for SimpleQuantity {
            fn deserialize<De>(deserializer: De) -> Result<Self>
            where
                De: Deserializer<'de>,
            {
                pub struct SimpleQuantityVisitor;
                impl<'de> Visitor<'de> for SimpleQuantityVisitor {
                    type Value = SimpleQuantity;
                    fn visit_map<M>(self, mut mapp: M) -> Result<Self::Value>
                    where
                        M: MapAccess<'de>,
                    {
                        let mut id: Option<Id> = None;
                        let mut extension: Option<Vec<Extension>> = None;
                        let mut value: Option<DecimalDt> = None;
                        let mut comparator: Option<CodeDt> = None;
                        let mut unit: Option<StringDt> = None;
                        let mut system: Option<UriDt> = None;
                        let mut code: Option<CodeDt> = None;
                        while let Some(key) = mapp.next_key()? {
                            match key.as_str() {
                                "id" => {
                                    id = Some(mapp.next_value()?);
                                }
                                "extension" => {
                                    extension = Some(mapp.next_value()?);
                                }
                                "value" => {
                                    value = Some(mapp.next_value()?);
                                }
                                "comparator" => {
                                    comparator = Some(mapp.next_value()?);
                                }
                                "unit" => {
                                    unit = Some(mapp.next_value()?);
                                }
                                "system" => {
                                    system = Some(mapp.next_value()?);
                                }
                                "code" => {
                                    code = Some(mapp.next_value()?);
                                }
                                _ => {
                                    return Err(
                                        FhirError::error_string({
                                            let res = ::alloc::fmt::format(
                                                format_args!("读到不存在的键:{0}", key),
                                            );
                                            res
                                        }),
                                    );
                                }
                            }
                        }
                        Ok(SimpleQuantity {
                            id,
                            extension,
                            value,
                            comparator,
                            unit,
                            system,
                            code,
                        })
                    }
                }
                deserializer.deserialize_struct("", SimpleQuantityVisitor)
            }
        }
        impl Executor for SimpleQuantity {
            fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
                {
                    ::std::io::_print(
                        format_args!("{0}: Start Exec Fhirpath...\n", "SimpleQuantity"),
                    );
                };
                match comp {
                    PathComponent::Path(path) => {
                        match path.symbol.as_str() {
                            "id" => self.id.exec(&comp),
                            "extension" => self.extension.exec(&comp),
                            "value" => self.value.exec(&comp),
                            "comparator" => self.comparator.exec(&comp),
                            "unit" => self.unit.exec(&comp),
                            "system" => self.system.exec(&comp),
                            "code" => self.code.exec(&comp),
                            other => {
                                Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: 无效的路径名:[{1}]",
                                                "SimpleQuantity",
                                                other,
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    _ => {
                        Err(
                            FhirError::Message({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "#struct_name_ident: 无效的函数名:{0:?}",
                                        &comp,
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn as_collection(&self) -> Collection {
                Collection(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([Box::new(self.clone())]),
                    ),
                )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SimpleQuantity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "extension",
                    "value",
                    "comparator",
                    "unit",
                    "system",
                    "code",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.extension,
                    &self.value,
                    &self.comparator,
                    &self.unit,
                    &self.system,
                    &&self.code,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "SimpleQuantity",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SimpleQuantity {
            #[inline]
            fn clone(&self) -> SimpleQuantity {
                SimpleQuantity {
                    id: ::core::clone::Clone::clone(&self.id),
                    extension: ::core::clone::Clone::clone(&self.extension),
                    value: ::core::clone::Clone::clone(&self.value),
                    comparator: ::core::clone::Clone::clone(&self.comparator),
                    unit: ::core::clone::Clone::clone(&self.unit),
                    system: ::core::clone::Clone::clone(&self.system),
                    code: ::core::clone::Clone::clone(&self.code),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SimpleQuantity {
            #[inline]
            fn default() -> SimpleQuantity {
                SimpleQuantity {
                    id: ::core::default::Default::default(),
                    extension: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    comparator: ::core::default::Default::default(),
                    unit: ::core::default::Default::default(),
                    system: ::core::default::Default::default(),
                    code: ::core::default::Default::default(),
                }
            }
        }
    }
    pub use primitive::*;
    pub use complex::*;
    use crate::prelude::*;
    use std::fmt::{Display, Debug, Formatter};
    use std::str::FromStr;
    pub type Id = String;
    pub type Code = String;
    pub type Markdown = String;
    pub type Base64Binary = String;
    pub type Xhtml = String;
    pub type Boolean = bool;
    pub type Uri = String;
    pub type Url = String;
    pub type Oid = String;
    pub type Uuid = String;
    pub type Canonical = String;
    pub type PositiveInt = usize;
    pub type UnsignedInt = usize;
    pub type Decimal = f64;
    pub type Integer = isize;
    pub type Integer64 = i64;
    
    pub trait Base {
        fn is_empty(&self) -> bool {
            false
        }
        fn type_name(&self) -> String;
    }
    
    impl Base for String {
        fn type_name(&self) -> String {
            "String".to_string()
        }
    }
    impl Base for Boolean {
        fn type_name(&self) -> String {
            "Boolean".to_string()
        }
    }
    impl Base for PositiveInt {
        fn type_name(&self) -> String {
            "PositiveInt".to_string()
        }
    }
    impl Base for Decimal {
        fn type_name(&self) -> String {
            "Decimal".to_string()
        }
    }
    impl Base for Integer {
        fn type_name(&self) -> String {
            "Integer".to_string()
        }
    }
    impl Base for Integer64 {
        fn type_name(&self) -> String {
            "Integer64".to_string()
        }
    }
    impl Base for DateTime {
        fn type_name(&self) -> String {
            "DateTime".to_string()
        }
    }
    impl Base for Time {
        fn type_name(&self) -> String {
            "Time".to_string()
        }
    }
    impl Base for Instant {
        fn type_name(&self) -> String {
            "Instant".to_string()
        }
    }
    impl<T> Base for Option<T> {
        fn type_name(&self) -> String {
            "Option".to_string()
        }
    }
    impl<T> Base for Vec<T> {
        fn type_name(&self) -> String {
            "Vec".to_string()
        }
    }
    impl<T> Base for Box<T> {
        fn type_name(&self) -> String {
            "Box".to_string()
        }
    }
    pub trait Element {
        fn has_id(&self) -> bool;
        fn id(&self) -> &Option<String>;
        fn set_id<T: Into<String>>(self, id: T) -> Self;
        fn has_extension(&self) -> bool;
        fn extension(&self) -> &Option<Vec<Extension>>;
        fn set_extension(self, ext: Vec<Extension>) -> Self;
        fn add_extension(self, ext: Extension) -> Self;
    }
    /// FHIR简单类型的特性
    /// FHIR简单类型是RUST简单数据类型的包装器
    ///
    pub trait Primitive: Display + FromStr {
        type T;
        fn new<A: Into<Self::T>>(v: A) -> Self;
        fn value(&self) -> &Option<Self::T>;
        fn set_value(self, v: Self::T) -> Self;
    }
    pub trait Resource {
        fn id(&self) -> &Option<Id>;
        fn set_id<T: Into<Id>>(self, id: T) -> Self;
        fn meta(&self) -> &Option<Meta>;
        fn set_meta(self, meta: Meta) -> Self;
    }
    pub trait DomainResource: Resource {
        fn extension(&self) -> &Option<Vec<Extension>>;
        fn set_extension(self, ext: Vec<Extension>) -> Self;
        fn add_extension(self, ext: Extension) -> Self;
        fn modifier_extension(&self) -> &Option<Vec<Extension>>;
        fn set_modifier_extension(self, ext: Vec<Extension>) -> Self;
        fn add_modifier_extension(self, ext: Extension) -> Self;
    }
    pub struct Date(chrono::NaiveDate, usize);
    #[automatically_derived]
    impl ::core::clone::Clone for Date {
        #[inline]
        fn clone(&self) -> Date {
            Date(
                ::core::clone::Clone::clone(&self.0),
                ::core::clone::Clone::clone(&self.1),
            )
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Date {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field2_finish(
                f,
                "Date",
                &self.0,
                &&self.1,
            )
        }
    }
    impl FromStr for Date {
        type Err = FhirError;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            let precision = s.len();
            let val = match precision {
                4 => {
                    let res = ::alloc::fmt::format(format_args!("{0}-01-01", s));
                    res
                }
                7 => {
                    let res = ::alloc::fmt::format(format_args!("{0}-01", s));
                    res
                }
                10 => {
                    let res = ::alloc::fmt::format(format_args!("{0}", s));
                    res
                }
                _ => {
                    return Err(
                        FhirError::error(
                            "错误的日期格式，只接受YYYY,YYYY-MM,YYYY-MM-DD三种格式",
                        ),
                    );
                }
            };
            let val = chrono::NaiveDate::from_str(val.as_str())?;
            Ok(Date(val, precision))
        }
    }
    impl Display for Date {
        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
            match self.1 {
                4 => f.write_fmt(format_args!("{0}", self.0.format("%Y"))),
                7 => f.write_fmt(format_args!("{0}", self.0.format("%Y-%m"))),
                10 => f.write_fmt(format_args!("{0}", self.0.format("%Y-%m-%d"))),
                _ => f.write_fmt(format_args!("Error")),
            }
        }
    }
    pub struct Time(chrono::NaiveTime, usize);
    #[automatically_derived]
    impl ::core::clone::Clone for Time {
        #[inline]
        fn clone(&self) -> Time {
            Time(
                ::core::clone::Clone::clone(&self.0),
                ::core::clone::Clone::clone(&self.1),
            )
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Time {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field2_finish(
                f,
                "Time",
                &self.0,
                &&self.1,
            )
        }
    }
    impl Display for Time {
        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
            match self.1 {
                8 => f.write_fmt(format_args!("{0}", self.0.format("%H:%M:%S"))),
                12 => f.write_fmt(format_args!("{0}", self.0.format("%H:%M:%S.%3f"))),
                _ => f.write_fmt(format_args!("Error")),
            }
        }
    }
    impl FromStr for Time {
        type Err = FhirError;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            let precision = s.len();
            let val = match precision {
                8 => chrono::NaiveTime::parse_from_str(s, "%H:%M:%S")?,
                12 => chrono::NaiveTime::parse_from_str(s, "%H:%M:%S.%3f")?,
                _ => {
                    return Err(
                        FhirError::error(
                            "错误的时间格式，只接受HH::MM::SS,HH:MM:SS.sss两种格式",
                        ),
                    );
                }
            };
            Ok(Time(val, precision))
        }
    }
    /// 日期与时间
    ///
    /// 精度不限，展示形式灵活.
    ///
    /// 可以表示：
    /// * 年 - 2023
    /// * 年月 - 2023-08
    /// * 年月日 - 2023-08-17
    /// * 年月日时分秒 - 2023-08-17T08:21:45
    /// * 年月日时分秒(毫秒) - 2023-08-17T08:21:45.234
    /// * 年月日时分秒(毫秒)时区 - 2023-08-17T08:21:45.234+08:00
    pub struct DateTime(chrono::DateTime<chrono::FixedOffset>, usize);
    #[automatically_derived]
    impl ::core::clone::Clone for DateTime {
        #[inline]
        fn clone(&self) -> DateTime {
            DateTime(
                ::core::clone::Clone::clone(&self.0),
                ::core::clone::Clone::clone(&self.1),
            )
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DateTime {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field2_finish(
                f,
                "DateTime",
                &self.0,
                &&self.1,
            )
        }
    }
    impl Display for DateTime {
        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
            match self.1 {
                4 => f.write_fmt(format_args!("{0}", self.0.format("%Y"))),
                7 => f.write_fmt(format_args!("{0}", self.0.format("%Y-%m"))),
                10 => f.write_fmt(format_args!("{0}", self.0.format("%Y-%m-%d"))),
                20 | 25 => {
                    f.write_fmt(
                        format_args!("{0}", self.0.format("%Y-%m-%dT%H:%M:%S%:z")),
                    )
                }
                24 | 29 => {
                    f.write_fmt(
                        format_args!("{0}", self.0.format("%Y-%m-%dT%H:%M:%S.%3f%:z")),
                    )
                }
                _ => f.write_fmt(format_args!("Error")),
            }
        }
    }
    impl FromStr for DateTime {
        type Err = FhirError;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            let pattern = "0000-01-01T00:00:00.000Z";
            let precision = s.len();
            let val = match precision {
                4 | 7 | 10 | 24 => {
                    let dt = {
                        let res = ::alloc::fmt::format(
                            format_args!("{0}{1}", s, &pattern[precision..]),
                        );
                        res
                    };
                    chrono::DateTime::<chrono::Local>::from_str(dt.as_str())?.into()
                }
                20 => {
                    let dt = {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "{0}{1}",
                                &s[0..precision - 1],
                                &pattern[precision - 1..],
                            ),
                        );
                        res
                    };
                    chrono::DateTime::<chrono::Local>::from_str(dt.as_str())?.into()
                }
                25 | 29 => chrono::DateTime::from_str(s)?,
                _ => {
                    return Err(
                        FhirError::error(
                            "错误的时间格式，只接受FHIR规范约定的日期时间格式",
                        ),
                    );
                }
            };
            Ok(DateTime(val, precision))
        }
    }
    /// 日期与时间
    ///
    /// 精度更高，最小精度要到秒，必须有时区。一般这种时间都是由机器生成的。
    ///
    /// 只接受FHIR规范约定的四种格式：
    /// * 2009-12-24T07:12:45Z
    /// * 2009-12-24T07:12:45.234Z
    /// * 2009-12-24T07:12:45+08:00
    /// * 2009-12-24T07:12:45.234+08:00
    ///
    /// 输出时，只有两种：
    /// * 2009-12-24T07:12:45+08:00
    /// * 2009-12-24T07:12:45.234+08:00
    /// 导入之后，会根据当地的时区将Z转换为对应的时区
    pub struct Instant(chrono::DateTime<chrono::FixedOffset>, usize);
    #[automatically_derived]
    impl ::core::clone::Clone for Instant {
        #[inline]
        fn clone(&self) -> Instant {
            Instant(
                ::core::clone::Clone::clone(&self.0),
                ::core::clone::Clone::clone(&self.1),
            )
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Instant {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field2_finish(
                f,
                "Instant",
                &self.0,
                &&self.1,
            )
        }
    }
    impl Display for Instant {
        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
            match self.1 {
                20 | 25 => {
                    f.write_fmt(
                        format_args!("{0}", self.0.format("%Y-%m-%dT%H:%M:%S%:z")),
                    )
                }
                24 | 29 => {
                    f.write_fmt(
                        format_args!("{0}", self.0.format("%Y-%m-%dT%H:%M:%S.%3f%:z")),
                    )
                }
                _ => f.write_fmt(format_args!("Error")),
            }
        }
    }
    impl FromStr for Instant {
        type Err = FhirError;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            let precision = s.len();
            let val = match precision {
                20 | 24 => chrono::DateTime::<chrono::Local>::from_str(s)?.into(),
                25 | 29 => chrono::DateTime::from_str(s)?,
                _ => {
                    return Err(
                        FhirError::error(
                            "错误的时间格式，只接受FHIR规范约定的日期时间格式",
                        ),
                    );
                }
            };
            Ok(Instant(val, precision))
        }
    }
    pub struct Extension {
        /// Unique id for inter-element referencing
        #[fhir(
            name = "id",
            min = "0",
            max = "1",
            summary = false,
            modifier = false,
            choice = ""
        )]
        pub id: Option<Id>,
        /// Additional content defined by implementations
        #[fhir(
            name = "extension",
            min = "0",
            max = "*",
            summary = false,
            modifier = false,
            choice = ""
        )]
        pub extension: Option<Vec<Extension>>,
        /// identifies the meaning of the extension
        #[fhir(
            name = "url",
            min = "1",
            max = "1",
            summary = false,
            modifier = false,
            choice = ""
        )]
        pub url: Option<Uri>,
        /// Value of extension
        #[fhir(
            name = "value",
            min = "0",
            max = "1",
            summary = false,
            modifier = false,
            choice = ""
        )]
        pub value: Option<AnyType>,
    }
    impl Element for Extension {
        fn has_id(&self) -> bool {
            self.id.is_some()
        }
        fn id(&self) -> &Option<String> {
            &self.id
        }
        fn set_id<T: Into<String>>(mut self, id: T) -> Self {
            self.id = Some(id.into());
            self
        }
        fn has_extension(&self) -> bool {
            self.extension.is_some()
        }
        fn extension(&self) -> &Option<Vec<Extension>> {
            &self.extension
        }
        fn set_extension(mut self, ext: Vec<Extension>) -> Self {
            self.extension = Some(ext);
            self
        }
        fn add_extension(mut self, ext: Extension) -> Self {
            match self.extension {
                Some(ref mut exts) => {
                    exts.push(ext);
                }
                None => {
                    self
                        .extension = Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([ext])),
                    );
                }
            }
            self
        }
    }
    impl Base for Extension {
        fn is_empty(&self) -> bool {
            self.url.is_none() & self.value.is_none()
        }
        fn type_name(&self) -> String {
            "Extension".to_string()
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Extension {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Extension",
                "id",
                &self.id,
                "extension",
                &self.extension,
                "url",
                &self.url,
                "value",
                &&self.value,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Extension {
        #[inline]
        fn clone(&self) -> Extension {
            Extension {
                id: ::core::clone::Clone::clone(&self.id),
                extension: ::core::clone::Clone::clone(&self.extension),
                url: ::core::clone::Clone::clone(&self.url),
                value: ::core::clone::Clone::clone(&self.value),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Extension {
        #[inline]
        fn default() -> Extension {
            Extension {
                id: ::core::default::Default::default(),
                extension: ::core::default::Default::default(),
                url: ::core::default::Default::default(),
                value: ::core::default::Default::default(),
            }
        }
    }
    impl Extension {
        pub fn new<U: Into<Url>>(url: U, value: AnyType) -> Extension {
            Extension {
                id: None,
                extension: None,
                url: Some(url.into()),
                value: Some(value),
            }
        }
        pub fn with_url<U: Into<Url>>(url: U) -> Extension {
            Extension {
                id: None,
                extension: None,
                url: Some(url.into()),
                value: None,
            }
        }
    }
    impl Executor for Extension {
        fn as_collection(&self) -> Collection {
            Collection(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([Box::new(self.clone())]),
                ),
            )
        }
    }
    impl Serialize for Extension {
        fn serialize<Ser>(&self, serializer: Ser) -> Result<()>
        where
            Ser: Serializer,
        {
            let mut extension = serializer.serialize_extension()?;
            extension.serialize_id(&self.id)?;
            extension.serialize_url(&self.url)?;
            extension.serialize_extension(&self.extension)?;
            extension.serialize_value(&self.value)?;
            extension.serialize_end()
        }
    }
    impl<'de> Deserialize<'de> for Extension {
        fn deserialize<De>(deserializer: De) -> Result<Self>
        where
            De: Deserializer<'de>,
        {
            pub struct ExtensionVisitor;
            impl<'de> Visitor<'de> for ExtensionVisitor {
                type Value = Extension;
                fn visit_map<V>(self, mut map: V) -> Result<Extension>
                where
                    V: MapAccess<'de>,
                {
                    let mut id: Option<String> = None;
                    let mut url: Option<String> = None;
                    let mut extension: Option<Vec<Extension>> = None;
                    let mut value: Option<AnyType> = None;
                    while let Some(key) = map.next_key()? {
                        match key.as_str() {
                            "id" => {
                                id = Some(map.next_value()?);
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:339",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(339u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &id) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "url" => {
                                url = Some(map.next_value()?);
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:343",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(343u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &url) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "extension" => {
                                extension = Some(map.next_value()?);
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:347",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(347u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &url) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "valueString" => {
                                let temp: StringDt = map.next_value()?;
                                value = Some(AnyType::String(temp));
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:352",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(352u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &value) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "valueBoolean" => {
                                let temp: BooleanDt = map.next_value()?;
                                value = Some(AnyType::Boolean(temp));
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:362",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(362u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &value) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "valueCode" => {
                                let temp: CodeDt = map.next_value()?;
                                value = Some(AnyType::Code(temp));
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:368",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(368u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &value) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "valueDateTime" => {
                                let temp: DateTimeDt = map.next_value()?;
                                value = Some(AnyType::DateTime(temp));
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:374",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(374u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &value) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "valueMarkdown" => {
                                let temp: MarkdownDt = map.next_value()?;
                                value = Some(AnyType::Markdown(temp));
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:384",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(384u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &value) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "valueUrl" => {
                                let temp: UrlDt = map.next_value()?;
                                value = Some(AnyType::Url(temp));
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:395",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(395u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &value) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "valueCoding" => {
                                let temp: Coding = map.next_value()?;
                                value = Some(AnyType::Coding(temp));
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:407",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(407u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &value) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            "valuePositiveInt" => {
                                let temp: PositiveIntDt = map.next_value()?;
                                value = Some(AnyType::PositiveInt(temp));
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event fhir-rs/src/datatype/mod.rs:439",
                                                "fhir_rs::datatype",
                                                ::tracing::Level::DEBUG,
                                                ::core::option::Option::Some("fhir-rs/src/datatype/mod.rs"),
                                                ::core::option::Option::Some(439u32),
                                                ::core::option::Option::Some("fhir_rs::datatype"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("读取到值: {0:?}", &value) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            other => {
                                return Err(
                                    FhirError::Message({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Extension读到不存在的[{0}]了", other),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    Ok(Extension {
                        id,
                        url,
                        extension,
                        value,
                    })
                }
            }
            deserializer.deserialize_struct("Extension", ExtensionVisitor)
        }
    }
    pub enum AnyType {
        String(StringDt),
        Id(IdDt),
        Base64Binary(Base64BinaryDt),
        Markdown(MarkdownDt),
        Uri(UriDt),
        Url(UrlDt),
        Oid(OidDt),
        Uuid(UuidDt),
        Canonical(CanonicalDt),
        Code(CodeDt),
        Boolean(BooleanDt),
        DateTime(DateTimeDt),
        Date(DateDt),
        Time(TimeDt),
        Instant(InstantDt),
        UnsignedInt(UnsignedIntDt),
        PositiveInt(PositiveIntDt),
        Integer(IntegerDt),
        Integer64(Integer64Dt),
        Decimal(DecimalDt),
        Address(Address),
        Age(Age),
        Annotation(Annotation),
        Attachment(Attachment),
        CodeableConcept(CodeableConcept),
        CodeableReference(CodeableReference),
        Coding(Coding),
        ContactPoint(ContactPoint),
        Count(Count),
        Distance(Distance),
        Duration(Duration),
        HumanName(HumanName),
        Identifier(Identifier),
        Money(Money),
        Period(Period),
        Quantity(Quantity),
        Range(Range),
        Ratio(Ratio),
        RatioRange(RatioRange),
        Reference(Reference),
        SampledData(SampledData),
        Signature(Signature),
        Timing(Timing),
        ContactDetail(ContactDetail),
        DataRequirement(DataRequirement),
        Expression(Expression),
        ParameterDefinition(ParameterDefinition),
        RelatedArtifact(RelatedArtifact),
        TriggerDefinition(TriggerDefinition),
        UsageContext(UsageContext),
        Availability(Availability),
        ExtendedContactDetail(ExtendedContactDetail),
        Dosage(Dosage),
        Meta(Meta),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnyType {
        #[inline]
        fn clone(&self) -> AnyType {
            match self {
                AnyType::String(__self_0) => {
                    AnyType::String(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Id(__self_0) => {
                    AnyType::Id(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Base64Binary(__self_0) => {
                    AnyType::Base64Binary(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Markdown(__self_0) => {
                    AnyType::Markdown(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Uri(__self_0) => {
                    AnyType::Uri(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Url(__self_0) => {
                    AnyType::Url(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Oid(__self_0) => {
                    AnyType::Oid(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Uuid(__self_0) => {
                    AnyType::Uuid(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Canonical(__self_0) => {
                    AnyType::Canonical(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Code(__self_0) => {
                    AnyType::Code(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Boolean(__self_0) => {
                    AnyType::Boolean(::core::clone::Clone::clone(__self_0))
                }
                AnyType::DateTime(__self_0) => {
                    AnyType::DateTime(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Date(__self_0) => {
                    AnyType::Date(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Time(__self_0) => {
                    AnyType::Time(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Instant(__self_0) => {
                    AnyType::Instant(::core::clone::Clone::clone(__self_0))
                }
                AnyType::UnsignedInt(__self_0) => {
                    AnyType::UnsignedInt(::core::clone::Clone::clone(__self_0))
                }
                AnyType::PositiveInt(__self_0) => {
                    AnyType::PositiveInt(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Integer(__self_0) => {
                    AnyType::Integer(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Integer64(__self_0) => {
                    AnyType::Integer64(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Decimal(__self_0) => {
                    AnyType::Decimal(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Address(__self_0) => {
                    AnyType::Address(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Age(__self_0) => {
                    AnyType::Age(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Annotation(__self_0) => {
                    AnyType::Annotation(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Attachment(__self_0) => {
                    AnyType::Attachment(::core::clone::Clone::clone(__self_0))
                }
                AnyType::CodeableConcept(__self_0) => {
                    AnyType::CodeableConcept(::core::clone::Clone::clone(__self_0))
                }
                AnyType::CodeableReference(__self_0) => {
                    AnyType::CodeableReference(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Coding(__self_0) => {
                    AnyType::Coding(::core::clone::Clone::clone(__self_0))
                }
                AnyType::ContactPoint(__self_0) => {
                    AnyType::ContactPoint(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Count(__self_0) => {
                    AnyType::Count(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Distance(__self_0) => {
                    AnyType::Distance(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Duration(__self_0) => {
                    AnyType::Duration(::core::clone::Clone::clone(__self_0))
                }
                AnyType::HumanName(__self_0) => {
                    AnyType::HumanName(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Identifier(__self_0) => {
                    AnyType::Identifier(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Money(__self_0) => {
                    AnyType::Money(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Period(__self_0) => {
                    AnyType::Period(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Quantity(__self_0) => {
                    AnyType::Quantity(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Range(__self_0) => {
                    AnyType::Range(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Ratio(__self_0) => {
                    AnyType::Ratio(::core::clone::Clone::clone(__self_0))
                }
                AnyType::RatioRange(__self_0) => {
                    AnyType::RatioRange(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Reference(__self_0) => {
                    AnyType::Reference(::core::clone::Clone::clone(__self_0))
                }
                AnyType::SampledData(__self_0) => {
                    AnyType::SampledData(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Signature(__self_0) => {
                    AnyType::Signature(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Timing(__self_0) => {
                    AnyType::Timing(::core::clone::Clone::clone(__self_0))
                }
                AnyType::ContactDetail(__self_0) => {
                    AnyType::ContactDetail(::core::clone::Clone::clone(__self_0))
                }
                AnyType::DataRequirement(__self_0) => {
                    AnyType::DataRequirement(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Expression(__self_0) => {
                    AnyType::Expression(::core::clone::Clone::clone(__self_0))
                }
                AnyType::ParameterDefinition(__self_0) => {
                    AnyType::ParameterDefinition(::core::clone::Clone::clone(__self_0))
                }
                AnyType::RelatedArtifact(__self_0) => {
                    AnyType::RelatedArtifact(::core::clone::Clone::clone(__self_0))
                }
                AnyType::TriggerDefinition(__self_0) => {
                    AnyType::TriggerDefinition(::core::clone::Clone::clone(__self_0))
                }
                AnyType::UsageContext(__self_0) => {
                    AnyType::UsageContext(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Availability(__self_0) => {
                    AnyType::Availability(::core::clone::Clone::clone(__self_0))
                }
                AnyType::ExtendedContactDetail(__self_0) => {
                    AnyType::ExtendedContactDetail(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Dosage(__self_0) => {
                    AnyType::Dosage(::core::clone::Clone::clone(__self_0))
                }
                AnyType::Meta(__self_0) => {
                    AnyType::Meta(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnyType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                AnyType::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                AnyType::Id(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Id", &__self_0)
                }
                AnyType::Base64Binary(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Base64Binary",
                        &__self_0,
                    )
                }
                AnyType::Markdown(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Markdown",
                        &__self_0,
                    )
                }
                AnyType::Uri(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uri",
                        &__self_0,
                    )
                }
                AnyType::Url(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Url",
                        &__self_0,
                    )
                }
                AnyType::Oid(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Oid",
                        &__self_0,
                    )
                }
                AnyType::Uuid(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uuid",
                        &__self_0,
                    )
                }
                AnyType::Canonical(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Canonical",
                        &__self_0,
                    )
                }
                AnyType::Code(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Code",
                        &__self_0,
                    )
                }
                AnyType::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                AnyType::DateTime(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DateTime",
                        &__self_0,
                    )
                }
                AnyType::Date(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Date",
                        &__self_0,
                    )
                }
                AnyType::Time(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Time",
                        &__self_0,
                    )
                }
                AnyType::Instant(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Instant",
                        &__self_0,
                    )
                }
                AnyType::UnsignedInt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UnsignedInt",
                        &__self_0,
                    )
                }
                AnyType::PositiveInt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PositiveInt",
                        &__self_0,
                    )
                }
                AnyType::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                AnyType::Integer64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer64",
                        &__self_0,
                    )
                }
                AnyType::Decimal(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Decimal",
                        &__self_0,
                    )
                }
                AnyType::Address(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Address",
                        &__self_0,
                    )
                }
                AnyType::Age(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Age",
                        &__self_0,
                    )
                }
                AnyType::Annotation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Annotation",
                        &__self_0,
                    )
                }
                AnyType::Attachment(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Attachment",
                        &__self_0,
                    )
                }
                AnyType::CodeableConcept(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CodeableConcept",
                        &__self_0,
                    )
                }
                AnyType::CodeableReference(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CodeableReference",
                        &__self_0,
                    )
                }
                AnyType::Coding(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Coding",
                        &__self_0,
                    )
                }
                AnyType::ContactPoint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ContactPoint",
                        &__self_0,
                    )
                }
                AnyType::Count(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Count",
                        &__self_0,
                    )
                }
                AnyType::Distance(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Distance",
                        &__self_0,
                    )
                }
                AnyType::Duration(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Duration",
                        &__self_0,
                    )
                }
                AnyType::HumanName(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "HumanName",
                        &__self_0,
                    )
                }
                AnyType::Identifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Identifier",
                        &__self_0,
                    )
                }
                AnyType::Money(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Money",
                        &__self_0,
                    )
                }
                AnyType::Period(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Period",
                        &__self_0,
                    )
                }
                AnyType::Quantity(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Quantity",
                        &__self_0,
                    )
                }
                AnyType::Range(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Range",
                        &__self_0,
                    )
                }
                AnyType::Ratio(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ratio",
                        &__self_0,
                    )
                }
                AnyType::RatioRange(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RatioRange",
                        &__self_0,
                    )
                }
                AnyType::Reference(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Reference",
                        &__self_0,
                    )
                }
                AnyType::SampledData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SampledData",
                        &__self_0,
                    )
                }
                AnyType::Signature(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Signature",
                        &__self_0,
                    )
                }
                AnyType::Timing(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Timing",
                        &__self_0,
                    )
                }
                AnyType::ContactDetail(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ContactDetail",
                        &__self_0,
                    )
                }
                AnyType::DataRequirement(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DataRequirement",
                        &__self_0,
                    )
                }
                AnyType::Expression(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Expression",
                        &__self_0,
                    )
                }
                AnyType::ParameterDefinition(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ParameterDefinition",
                        &__self_0,
                    )
                }
                AnyType::RelatedArtifact(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RelatedArtifact",
                        &__self_0,
                    )
                }
                AnyType::TriggerDefinition(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TriggerDefinition",
                        &__self_0,
                    )
                }
                AnyType::UsageContext(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UsageContext",
                        &__self_0,
                    )
                }
                AnyType::Availability(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Availability",
                        &__self_0,
                    )
                }
                AnyType::ExtendedContactDetail(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ExtendedContactDetail",
                        &__self_0,
                    )
                }
                AnyType::Dosage(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dosage",
                        &__self_0,
                    )
                }
                AnyType::Meta(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Meta",
                        &__self_0,
                    )
                }
            }
        }
    }
    impl Serialize for AnyType {
        fn serialize<Ser>(&self, serializer: Ser) -> Result<()>
        where
            Ser: Serializer,
        {
            match self {
                AnyType::String(value) => serializer.serialize_any("value", value),
                AnyType::Id(value) => serializer.serialize_any("value", value),
                AnyType::Base64Binary(value) => serializer.serialize_any("value", value),
                AnyType::Markdown(value) => serializer.serialize_any("value", value),
                AnyType::Uri(value) => serializer.serialize_any("value", value),
                AnyType::Url(value) => serializer.serialize_any("value", value),
                AnyType::Oid(value) => serializer.serialize_any("value", value),
                AnyType::Uuid(value) => serializer.serialize_any("value", value),
                AnyType::Canonical(value) => serializer.serialize_any("value", value),
                AnyType::Code(value) => serializer.serialize_any("value", value),
                AnyType::Boolean(value) => serializer.serialize_any("value", value),
                AnyType::DateTime(value) => serializer.serialize_any("value", value),
                AnyType::Date(value) => serializer.serialize_any("value", value),
                AnyType::Time(value) => serializer.serialize_any("value", value),
                AnyType::Instant(value) => serializer.serialize_any("value", value),
                AnyType::UnsignedInt(value) => serializer.serialize_any("value", value),
                AnyType::PositiveInt(value) => serializer.serialize_any("value", value),
                AnyType::Integer(value) => serializer.serialize_any("value", value),
                AnyType::Integer64(value) => serializer.serialize_any("value", value),
                AnyType::Decimal(value) => serializer.serialize_any("value", value),
                AnyType::Address(value) => serializer.serialize_any("value", value),
                AnyType::Age(value) => serializer.serialize_any("value", value),
                AnyType::Annotation(value) => serializer.serialize_any("value", value),
                AnyType::Attachment(value) => serializer.serialize_any("value", value),
                AnyType::CodeableConcept(value) => {
                    serializer.serialize_any("value", value)
                }
                AnyType::CodeableReference(value) => {
                    serializer.serialize_any("value", value)
                }
                AnyType::Coding(value) => serializer.serialize_any("value", value),
                AnyType::ContactPoint(value) => serializer.serialize_any("value", value),
                AnyType::Count(value) => serializer.serialize_any("value", value),
                AnyType::Distance(value) => serializer.serialize_any("value", value),
                AnyType::Duration(value) => serializer.serialize_any("value", value),
                AnyType::HumanName(value) => serializer.serialize_any("value", value),
                AnyType::Identifier(value) => serializer.serialize_any("value", value),
                AnyType::Money(value) => serializer.serialize_any("value", value),
                AnyType::Period(value) => serializer.serialize_any("value", value),
                AnyType::Quantity(value) => serializer.serialize_any("value", value),
                AnyType::Range(value) => serializer.serialize_any("value", value),
                AnyType::Ratio(value) => serializer.serialize_any("value", value),
                AnyType::RatioRange(value) => serializer.serialize_any("value", value),
                AnyType::Reference(value) => serializer.serialize_any("value", value),
                AnyType::SampledData(value) => serializer.serialize_any("value", value),
                AnyType::Signature(value) => serializer.serialize_any("value", value),
                AnyType::Timing(value) => serializer.serialize_any("value", value),
                AnyType::ContactDetail(value) => serializer.serialize_any("value", value),
                AnyType::DataRequirement(value) => {
                    serializer.serialize_any("value", value)
                }
                AnyType::Expression(value) => serializer.serialize_any("value", value),
                AnyType::ParameterDefinition(value) => {
                    serializer.serialize_any("value", value)
                }
                AnyType::RelatedArtifact(value) => {
                    serializer.serialize_any("value", value)
                }
                AnyType::TriggerDefinition(value) => {
                    serializer.serialize_any("value", value)
                }
                AnyType::UsageContext(value) => serializer.serialize_any("value", value),
                AnyType::Availability(value) => serializer.serialize_any("value", value),
                AnyType::ExtendedContactDetail(value) => {
                    serializer.serialize_any("value", value)
                }
                AnyType::Dosage(value) => serializer.serialize_any("value", value),
                AnyType::Meta(value) => serializer.serialize_any("value", value),
            }
        }
    }
    impl Executor for AnyType {
        fn exec(&self, comp: &PathComponent) -> Result<PathResponse> {
            match self {
                AnyType::String(value) => value.exec(comp),
                AnyType::Id(value) => value.exec(comp),
                AnyType::Base64Binary(value) => value.exec(comp),
                AnyType::Markdown(value) => value.exec(comp),
                AnyType::Uri(value) => value.exec(comp),
                AnyType::Url(value) => value.exec(comp),
                AnyType::Oid(value) => value.exec(comp),
                AnyType::Uuid(value) => value.exec(comp),
                AnyType::Canonical(value) => value.exec(comp),
                AnyType::Code(value) => value.exec(comp),
                AnyType::Boolean(value) => value.exec(comp),
                AnyType::DateTime(value) => value.exec(comp),
                AnyType::Date(value) => value.exec(comp),
                AnyType::Time(value) => value.exec(comp),
                AnyType::Instant(value) => value.exec(comp),
                AnyType::UnsignedInt(value) => value.exec(comp),
                AnyType::PositiveInt(value) => value.exec(comp),
                AnyType::Integer(value) => value.exec(comp),
                AnyType::Integer64(value) => value.exec(comp),
                AnyType::Decimal(value) => value.exec(comp),
                AnyType::Address(value) => value.exec(comp),
                AnyType::Age(value) => value.exec(comp),
                AnyType::Annotation(value) => value.exec(comp),
                AnyType::Attachment(value) => value.exec(comp),
                AnyType::CodeableConcept(value) => value.exec(comp),
                AnyType::CodeableReference(value) => value.exec(comp),
                AnyType::Coding(value) => value.exec(comp),
                AnyType::ContactPoint(value) => value.exec(comp),
                AnyType::Count(value) => value.exec(comp),
                AnyType::Distance(value) => value.exec(comp),
                AnyType::Duration(value) => value.exec(comp),
                AnyType::HumanName(value) => value.exec(comp),
                AnyType::Identifier(value) => value.exec(comp),
                AnyType::Money(value) => value.exec(comp),
                AnyType::Period(value) => value.exec(comp),
                AnyType::Quantity(value) => value.exec(comp),
                AnyType::Range(value) => value.exec(comp),
                AnyType::Ratio(value) => value.exec(comp),
                AnyType::RatioRange(value) => value.exec(comp),
                AnyType::Reference(value) => value.exec(comp),
                AnyType::SampledData(value) => value.exec(comp),
                AnyType::Signature(value) => value.exec(comp),
                AnyType::Timing(value) => value.exec(comp),
                AnyType::ContactDetail(value) => value.exec(comp),
                AnyType::DataRequirement(value) => value.exec(comp),
                AnyType::Expression(value) => value.exec(comp),
                AnyType::ParameterDefinition(value) => value.exec(comp),
                AnyType::RelatedArtifact(value) => value.exec(comp),
                AnyType::TriggerDefinition(value) => value.exec(comp),
                AnyType::UsageContext(value) => value.exec(comp),
                AnyType::Availability(value) => value.exec(comp),
                AnyType::ExtendedContactDetail(value) => value.exec(comp),
                AnyType::Dosage(value) => value.exec(comp),
                AnyType::Meta(value) => value.exec(comp),
            }
        }
        fn as_collection(&self) -> Collection {
            match self {
                AnyType::String(value) => value.as_collection(),
                AnyType::Id(value) => value.as_collection(),
                AnyType::Base64Binary(value) => value.as_collection(),
                AnyType::Markdown(value) => value.as_collection(),
                AnyType::Uri(value) => value.as_collection(),
                AnyType::Url(value) => value.as_collection(),
                AnyType::Oid(value) => value.as_collection(),
                AnyType::Uuid(value) => value.as_collection(),
                AnyType::Canonical(value) => value.as_collection(),
                AnyType::Code(value) => value.as_collection(),
                AnyType::Boolean(value) => value.as_collection(),
                AnyType::DateTime(value) => value.as_collection(),
                AnyType::Date(value) => value.as_collection(),
                AnyType::Time(value) => value.as_collection(),
                AnyType::Instant(value) => value.as_collection(),
                AnyType::UnsignedInt(value) => value.as_collection(),
                AnyType::PositiveInt(value) => value.as_collection(),
                AnyType::Integer(value) => value.as_collection(),
                AnyType::Integer64(value) => value.as_collection(),
                AnyType::Decimal(value) => value.as_collection(),
                AnyType::Address(value) => value.as_collection(),
                AnyType::Age(value) => value.as_collection(),
                AnyType::Annotation(value) => value.as_collection(),
                AnyType::Attachment(value) => value.as_collection(),
                AnyType::CodeableConcept(value) => value.as_collection(),
                AnyType::CodeableReference(value) => value.as_collection(),
                AnyType::Coding(value) => value.as_collection(),
                AnyType::ContactPoint(value) => value.as_collection(),
                AnyType::Count(value) => value.as_collection(),
                AnyType::Distance(value) => value.as_collection(),
                AnyType::Duration(value) => value.as_collection(),
                AnyType::HumanName(value) => value.as_collection(),
                AnyType::Identifier(value) => value.as_collection(),
                AnyType::Money(value) => value.as_collection(),
                AnyType::Period(value) => value.as_collection(),
                AnyType::Quantity(value) => value.as_collection(),
                AnyType::Range(value) => value.as_collection(),
                AnyType::Ratio(value) => value.as_collection(),
                AnyType::RatioRange(value) => value.as_collection(),
                AnyType::Reference(value) => value.as_collection(),
                AnyType::SampledData(value) => value.as_collection(),
                AnyType::Signature(value) => value.as_collection(),
                AnyType::Timing(value) => value.as_collection(),
                AnyType::ContactDetail(value) => value.as_collection(),
                AnyType::DataRequirement(value) => value.as_collection(),
                AnyType::Expression(value) => value.as_collection(),
                AnyType::ParameterDefinition(value) => value.as_collection(),
                AnyType::RelatedArtifact(value) => value.as_collection(),
                AnyType::TriggerDefinition(value) => value.as_collection(),
                AnyType::UsageContext(value) => value.as_collection(),
                AnyType::Availability(value) => value.as_collection(),
                AnyType::ExtendedContactDetail(value) => value.as_collection(),
                AnyType::Dosage(value) => value.as_collection(),
                AnyType::Meta(value) => value.as_collection(),
            }
        }
    }
    impl<'de> Deserialize<'de> for AnyType {
        fn deserialize<De>(deserializer: De) -> Result<Self>
        where
            De: Deserializer<'de>,
        {
            pub struct AnyVisitor;
            impl<'de> Visitor<'de> for AnyVisitor {
                type Value = AnyType;
            }
            deserializer.deserialize_enum(AnyVisitor)
        }
    }
}
